<documents>
<document index="1">
<source>directory-structure.txt</source>
<document_content>
.
â”œâ”€â”€ golf-tracker
â”‚Â Â  â”œâ”€â”€ src
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ components
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ FormButton.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ FormInput.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ config
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ database.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ contexts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ AuthContext.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ models
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Course.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Round.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ User.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ screens
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ auth
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ LandingScreen.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ LoginScreen.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ SignupScreen.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AddRoundScreen.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ HomeScreen.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ services
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ auth.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ courses.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ rounds.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ types
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ navigation.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ utils
â”‚Â Â  â”œâ”€â”€ .gitignore
â”‚Â Â  â”œâ”€â”€ App.tsx
â”‚Â Â  â”œâ”€â”€ app.json
â”‚Â Â  â”œâ”€â”€ index.js
â”‚Â Â  â”œâ”€â”€ package-lock.json
â”‚Â Â  â”œâ”€â”€ package.json
â”‚Â Â  â””â”€â”€ tsconfig.json
â”œâ”€â”€ server
â”‚Â Â  â”œâ”€â”€ middleware
â”‚Â Â  â”‚Â Â  â””â”€â”€ auth.ts
â”‚Â Â  â”œâ”€â”€ models
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Course.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Round.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ User.ts
â”‚Â Â  â”œâ”€â”€ routes
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ auth.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ courses.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ rounds.ts
â”‚Â Â  â”œâ”€â”€ .env
â”‚Â Â  â”œâ”€â”€ index.ts
â”‚Â Â  â”œâ”€â”€ package-lock.json
â”‚Â Â  â”œâ”€â”€ package.json
â”‚Â Â  â””â”€â”€ tsconfig.json
â”œâ”€â”€ shared
â”‚Â Â  â”œâ”€â”€ src
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ types
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ base.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ course.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ round.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ user.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ index.ts
â”‚Â Â  â”œâ”€â”€ package-lock.json
â”‚Â Â  â”œâ”€â”€ package.json
â”‚Â Â  â””â”€â”€ tsconfig.json
â”œâ”€â”€ .DS_Store
â”œâ”€â”€ .gitignore
â”œâ”€â”€ app_doc.txt
â”œâ”€â”€ dev.sh
â””â”€â”€ document-app.sh

19 directories, 48 files
</document_content>
</document>
<document index="2">
<source>golf-tracker/App.tsx</source>
<document_content>
// App.tsx
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { StatusBar } from 'expo-status-bar';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { AuthProvider, useAuth } from './src/contexts/AuthContext';

// Screens
import LandingScreen from './src/screens/auth/LandingScreen';
import LoginScreen from './src/screens/auth/LoginScreen';
import SignupScreen from './src/screens/auth/SignupScreen';
import HomeScreen from './src/screens/HomeScreen';
import AddRoundScreen from './src/screens/AddRoundScreen';

const AuthStack = createNativeStackNavigator();
const MainStack = createNativeStackNavigator();

// Separate the navigation components
function AuthNavigator() {
  return (
    <AuthStack.Navigator
      id={null}
      initialRouteName="Landing"
      screenOptions={{
        headerShown: false,
        contentStyle: { backgroundColor: '#fff' }
      }}
    >
      <AuthStack.Screen name="Landing" component={LandingScreen} />
      <AuthStack.Screen name="Login" component={LoginScreen} />
      <AuthStack.Screen name="Signup" component={SignupScreen} />
    </AuthStack.Navigator>
  );
}

function MainNavigator() {
  return (
    <MainStack.Navigator
      id={null}
      screenOptions={{
        headerShown: false,
        contentStyle: { backgroundColor: '#fff' }
      }}
    >
      <MainStack.Screen name="Home" component={HomeScreen} />
      <MainStack.Screen name="AddRound" component={AddRoundScreen} />
    </MainStack.Navigator>
  );
}

// Create a separate Navigation component
function Navigation() {
  const { user } = useAuth();
  
  return (
    <NavigationContainer>
      {user ? <MainNavigator /> : <AuthNavigator />}
    </NavigationContainer>
  );
}

// Main App component
export default function App() {
  return (
    <SafeAreaProvider>
      <AuthProvider>
        <StatusBar style="auto" />
        <Navigation />
      </AuthProvider>
    </SafeAreaProvider>
  );
}</document_content>
</document>
<document index="3">
<source>golf-tracker/src/types/navigation.ts</source>
<document_content>
// src/types/navigation.ts
export type AuthStackParamList = {
  Landing: undefined;
  Login: undefined;
  Signup: undefined;
};

export type MainStackParamList = {
  Home: undefined;
  AddRound: undefined;
  AddCourse: undefined;
};</document_content>
</document>
<document index="4">
<source>golf-tracker/src/contexts/AuthContext.tsx</source>
<document_content>
// src/contexts/AuthContext.tsx
import React, { createContext, useState, useContext, useEffect } from 'react';
import { User } from 'shared';
import { getAuthToken, validateToken, logout as authLogout } from '../services/auth';

interface AuthContextType {
  user: User | null;
  setUser: (user: User | null) => void;
  logout: () => Promise<void>;
  isLoading: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    checkAuthStatus();
  }, []);

  const checkAuthStatus = async () => {
    try {
      const token = await getAuthToken();
      if (token) {
        const userData = await validateToken(token);
        if (userData) {
          setUser(userData);
        }
      }
    } catch (error) {
      console.error('Error checking auth status:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const logout = async () => {
    try {
      await authLogout();
      setUser(null);
    } catch (error) {
      console.error('Error logging out:', error);
      throw error;
    }
  };

  return (
    <AuthContext.Provider value={{ user, setUser, logout, isLoading }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}</document_content>
</document>
<document index="5">
<source>golf-tracker/src/config/database.ts</source>
<document_content>
// src/config/database.ts
import mongoose from 'mongoose';

const connectDB = async () => {
  try {
    await mongoose.connect('your_mongodb_connection_string');
    console.log('MongoDB Connected...');
  } catch (err) {
    console.error('MongoDB connection error:', err);
    process.exit(1);
  }
};

export default connectDB;</document_content>
</document>
<document index="6">
<source>golf-tracker/src/models/Round.ts</source>
<document_content>
// server/models/Round.ts
import mongoose, { Schema } from 'mongoose';

const roundSchema = new Schema({
  course: {
    type: Schema.Types.ObjectId,
    ref: 'Course',
    required: true
  },
  date: {
    type: Date,
    required: true
  },
  tees: {
    type: String,
    required: true
  },
  score: {
    type: Number,
    required: true
  },
  putts: {
    type: Number,
    required: true
  },
  fairways: {
    type: Number,
    required: true
  },
  notes: {
    type: String
  },
  addedBy: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
  }
}, {
  timestamps: true
});

// Add indexes for common queries
roundSchema.index({ addedBy: 1, date: -1 });
roundSchema.index({ course: 1, addedBy: 1 });

export interface IRound extends mongoose.Document {
  course: mongoose.Types.ObjectId;
  date: Date;
  tees: string;
  score: number;
  putts: number;
  fairways: number;
  notes?: string;
  addedBy: mongoose.Types.ObjectId;
  createdAt: Date;
  updatedAt: Date;
}

const Round = mongoose.model<IRound>('Round', roundSchema);
export default Round;</document_content>
</document>
<document index="7">
<source>golf-tracker/src/models/Course.ts</source>
<document_content>
// server/models/Course.ts
import mongoose, { Schema } from 'mongoose';

const teeSchema = new Schema({
  name: {
    type: String,
    required: true,
  },
  rating: {
    type: Number,
    required: true,
  },
  slope: {
    type: Number,
    required: true,
  },
  numberOfFairways: {
    type: Number,
    required: true,
  }
});

const courseSchema = new Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  location: {
    city: {
      type: String,
      trim: true
    },
    state: {
      type: String,
      trim: true
    },
    country: {
      type: String,
      trim: true
    }
  },
  tees: [teeSchema],
  addedBy: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
  }
}, {
  timestamps: true
});

// Make courses unique by name + location
courseSchema.index({ 
  name: 1, 
  'location.city': 1, 
  'location.state': 1,
  'location.country': 1
}, { 
  unique: true,
  collation: { locale: 'en', strength: 2 } // Case-insensitive uniqueness
});

export interface ICourse extends mongoose.Document {
  name: string;
  location: {
    city?: string;
    state?: string;
    country?: string;
  };
  tees: Array<{
    name: string;
    rating: number;
    slope: number;
    numberOfFairways: number;
  }>;
  addedBy: mongoose.Types.ObjectId;
  createdAt: Date;
  updatedAt: Date;
}

const Course = mongoose.model<ICourse>('Course', courseSchema);
export default Course;</document_content>
</document>
<document index="8">
<source>golf-tracker/src/models/User.ts</source>
<document_content>
// src/models/User.ts
import mongoose from 'mongoose';
import bcrypt from 'bcryptjs';

const SALT_ROUNDS = 10;

const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: true,
    unique: true,
  },
  password: {
    type: String,
    required: true,
  },
  name: {
    type: String,
    required: false,
  }
}, {
  timestamps: true
});

// Hash password before saving
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();

  try {
    const salt = await bcrypt.genSalt(SALT_ROUNDS);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error as Error);
  }
});

// Method to compare passwords
userSchema.methods.comparePassword = async function(candidatePassword: string): Promise<boolean> {
  try {
    return await bcrypt.compare(candidatePassword, this.password);
  } catch (error) {
    throw error;
  }
};

export interface IUser extends mongoose.Document {
  email: string;
  password: string;
  name?: string;
  createdAt: Date;
  updatedAt: Date;
  comparePassword(candidatePassword: string): Promise<boolean>;
}

const User = mongoose.model<IUser>('User', userSchema);

export default User;</document_content>
</document>
<document index="9">
<source>golf-tracker/src/screens/auth/SignupScreen.tsx</source>
<document_content>
// src/screens/auth/SignupScreen.tsx
import React, { useState } from 'react';
import {
  StyleSheet,
  View,
  Text,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import { AuthStackParamList } from '../../types/navigation';
import { FormInput } from '../../components/FormInput';
import { FormButton } from '../../components/FormButton';
import { signup, AuthError } from '../../services/auth';

type Props = NativeStackScreenProps<AuthStackParamList, 'Signup'>;

interface FormErrors {
  name?: string;
  email?: string;
  password?: string;
  confirmPassword?: string;
}

export default function SignupScreen({ navigation }: Props) {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const [formErrors, setFormErrors] = useState<FormErrors>({});
  const [generalError, setGeneralError] = useState('');

  const validateForm = (): boolean => {
    const errors: FormErrors = {};
    let isValid = true;

    // Reset errors
    setFormErrors({});
    setGeneralError('');

    // Name validation
    if (!name.trim()) {
      errors.name = 'Name is required';
      isValid = false;
    }

    // Email validation
    if (!email) {
      errors.email = 'Email is required';
      isValid = false;
    } else if (!/\S+@\S+\.\S+/.test(email)) {
      errors.email = 'Please enter a valid email';
      isValid = false;
    }

    // Password validation
    if (!password) {
      errors.password = 'Password is required';
      isValid = false;
    } else if (password.length < 8) {
      errors.password = 'Password must be at least 8 characters';
      isValid = false;
    }

    // Confirm password validation
    if (!confirmPassword) {
      errors.confirmPassword = 'Please confirm your password';
      isValid = false;
    } else if (password !== confirmPassword) {
      errors.confirmPassword = 'Passwords do not match';
      isValid = false;
    }

    setFormErrors(errors);
    return isValid;
  };

  const handleSignup = async () => {
    if (!validateForm()) {
      return;
    }

    setLoading(true);
    setGeneralError('');

    try {
      const user = await signup({
        name,
        email,
        password,
      });
      
      // TODO: Store user data in your app's global state (e.g., Context or Redux)
      console.log('Signup successful:', user);
      
      // Show success message
      Alert.alert(
        'Success',
        'Your account has been created successfully!',
        [
          {
            text: 'OK',
            onPress: () => {
              // TODO: Navigate to main app screen
              // navigation.replace('MainApp');
            },
          },
        ]
      );
      
    } catch (err) {
      if (err instanceof AuthError) {
        // Handle specific auth errors
        if (err.message.toLowerCase().includes('email already registered')) {
          setFormErrors(prev => ({
            ...prev,
            email: 'This email is already registered'
          }));
        } else if (err.message.toLowerCase().includes('network')) {
          Alert.alert(
            'Connection Error',
            'Please check your internet connection and try again.'
          );
        } else {
          setGeneralError(err.message);
        }
      } else {
        // Handle unexpected errors
        console.error('Signup error:', err);
        Alert.alert(
          'Error',
          'An unexpected error occurred. Please try again later.'
        );
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardView}
      >
        <ScrollView contentContainerStyle={styles.scrollContent}>
          <View style={styles.header}>
            <Text style={styles.title}>Create Account</Text>
            <Text style={styles.subtitle}>Track your golf progress</Text>
          </View>

          <View style={styles.form}>
            {generalError ? (
              <Text style={styles.generalError}>{generalError}</Text>
            ) : null}

            <FormInput
              label="Name"
              value={name}
              onChangeText={(text) => {
                setName(text);
                setFormErrors(prev => ({ ...prev, name: undefined }));
              }}
              placeholder="Enter your name"
              autoComplete="name"
              error={formErrors.name}
              editable={!loading}
            />

            <FormInput
              label="Email"
              value={email}
              onChangeText={(text) => {
                setEmail(text);
                setFormErrors(prev => ({ ...prev, email: undefined }));
              }}
              placeholder="Enter your email"
              autoCapitalize="none"
              autoComplete="email"
              keyboardType="email-address"
              error={formErrors.email}
              editable={!loading}
            />

            <FormInput
              label="Password"
              value={password}
              onChangeText={(text) => {
                setPassword(text);
                setFormErrors(prev => ({ ...prev, password: undefined }));
              }}
              placeholder="Create a password"
              secureTextEntry
              autoComplete="new-password"
              error={formErrors.password}
              editable={!loading}
            />

            <FormInput
              label="Confirm Password"
              value={confirmPassword}
              onChangeText={(text) => {
                setConfirmPassword(text);
                setFormErrors(prev => ({ ...prev, confirmPassword: undefined }));
              }}
              placeholder="Confirm your password"
              secureTextEntry
              autoComplete="new-password"
              error={formErrors.confirmPassword}
              editable={!loading}
            />

            <FormButton
              title="Create Account"
              onPress={handleSignup}
              loading={loading}
            />
          </View>

          <View style={styles.footer}>
            <Text style={styles.footerText}>Already have an account? </Text>
            <TouchableOpacity 
              onPress={() => navigation.navigate('Login')}
              disabled={loading}
            >
              <Text style={styles.footerLink}>Log In</Text>
            </TouchableOpacity>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  keyboardView: {
    flex: 1,
  },
  scrollContent: {
    flexGrow: 1,
    padding: 20,
  },
  header: {
    marginTop: 40,
    marginBottom: 32,
    alignItems: 'center',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
  },
  form: {
    marginBottom: 24,
  },
  generalError: {
    color: '#ff3b30',
    textAlign: 'center',
    marginBottom: 16,
    backgroundColor: '#ffebeb',
    padding: 10,
    borderRadius: 8,
  },
  error: {
    color: '#ff3b30',
    textAlign: 'center',
    marginBottom: 16,
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginTop: 'auto',
    paddingVertical: 16,
  },
  footerText: {
    color: '#666',
  },
  footerLink: {
    color: '#2f95dc',
    fontWeight: '600',
  },
});</document_content>
</document>
<document index="10">
<source>golf-tracker/src/screens/auth/LandingScreen.tsx</source>
<document_content>
// src/screens/auth/LandingScreen.tsx
import React from 'react';
import {
  StyleSheet,
  View,
  Text,
  useWindowDimensions,
  Platform,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import { AuthStackParamList } from '../../types/navigation';
import { FormButton } from '../../components/FormButton';

type Props = NativeStackScreenProps<AuthStackParamList, 'Landing'>;

export default function LandingScreen({ navigation }: Props) {
  const { height } = useWindowDimensions();

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.content}>
        {/* Top Section with Logo/Branding */}
        <View style={[styles.topSection, { height: height * 0.5 }]}>
          <View style={styles.logoContainer}>
            <Text style={styles.emoji}>â›³ï¸</Text>
            <Text style={styles.appName}>HandiMan</Text>
          </View>
          <Text style={styles.tagline}>Track your scores.</Text>
          <Text style={styles.taglineSecondary}>Improve your game.</Text>
        </View>

        {/* Bottom Section with Feature Points and Buttons */}
        <View style={styles.bottomSection}>
          <View style={styles.features}>
            <FeaturePoint text="Track your rounds and progress" />
            <FeaturePoint text="Calculate your handicap" />
            <FeaturePoint text="Connect with other golfers" />
          </View>

          <View style={styles.buttonContainer}>
            <FormButton
              title="Get Started"
              onPress={() => navigation.navigate('Signup')}
            />
            <FormButton
              title="I already have an account"
              onPress={() => navigation.navigate('Login')}
              variant="secondary"
            />
          </View>
        </View>
      </View>
    </SafeAreaView>
  );
}

function FeaturePoint({ text }: { text: string }) {
  return (
    <View style={styles.featurePoint}>
      <Text style={styles.featureIcon}>âœ“</Text>
      <Text style={styles.featureText}>{text}</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  content: {
    flex: 1,
  },
  topSection: {
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 20,
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 24,
  },
  emoji: {
    fontSize: 64,
    marginBottom: 16,
  },
  appName: {
    fontSize: 42,
    fontWeight: 'bold',
    color: '#2f95dc',
    letterSpacing: -1,
  },
  tagline: {
    fontSize: 28,
    fontWeight: '600',
    textAlign: 'center',
    marginBottom: 8,
  },
  taglineSecondary: {
    fontSize: 28,
    fontWeight: '600',
    textAlign: 'center',
    color: '#2f95dc',
  },
  bottomSection: {
    flex: 1,
    paddingHorizontal: 20,
    justifyContent: 'space-between',
    paddingBottom: Platform.OS === 'ios' ? 20 : 40,
  },
  features: {
    gap: 16,
    marginBottom: 32,
  },
  featurePoint: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  featureIcon: {
    color: '#2f95dc',
    fontSize: 20,
    fontWeight: 'bold',
  },
  featureText: {
    fontSize: 16,
    color: '#333',
  },
  buttonContainer: {
    gap: 12,
  },
});</document_content>
</document>
<document index="11">
<source>golf-tracker/src/screens/auth/LoginScreen.tsx</source>
<document_content>
import React, { useState } from 'react';
import {
  StyleSheet,
  View,
  Text,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import { AuthStackParamList } from '../../types/navigation';
import { FormInput } from '../../components/FormInput';
import { FormButton } from '../../components/FormButton';
import { login, AuthError } from '../../services/auth';
import { useAuth } from '../../contexts/AuthContext';
import { User } from 'shared';

type Props = NativeStackScreenProps<AuthStackParamList, 'Login'>;

interface FormErrors {
  email?: string;
  password?: string;
}

export default function LoginScreen({ navigation }: Props) {
  const { setUser } = useAuth();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const [formErrors, setFormErrors] = useState<FormErrors>({});
  const [generalError, setGeneralError] = useState('');

  const validateForm = (): boolean => {
    const errors: FormErrors = {};
    let isValid = true;

    setFormErrors({});
    setGeneralError('');

    if (!email) {
      errors.email = 'Email is required';
      isValid = false;
    } else if (!/\S+@\S+\.\S+/.test(email)) {
      errors.email = 'Please enter a valid email';
      isValid = false;
    }

    if (!password) {
      errors.password = 'Password is required';
      isValid = false;
    }

    setFormErrors(errors);
    return isValid;
  };

  const handleLogin = async () => {
    if (!validateForm()) return;
  
    setLoading(true);
    setGeneralError('');
  
    try {
      const userData = await login(email, password);
      const user: User = {
        _id: userData._id,
        email: userData.email,
        name: userData.name,
        createdAt: new Date(userData.createdAt),
        updatedAt: new Date(userData.updatedAt)
      };
      setUser(user);
    } catch (err) {
      console.error('Login error:', err);
      if (err instanceof AuthError) {
        if (err.message.toLowerCase().includes('invalid credentials')) {
          setGeneralError('Invalid email or password');
        } else if (err.message.toLowerCase().includes('network')) {
          Alert.alert(
            'Connection Error',
            'Please check your internet connection and try again.'
          );
        } else {
          setGeneralError(err.message);
        }
      } else {
        console.error('Login error:', err);
        Alert.alert(
          'Error',
          'An unexpected error occurred. Please try again later.'
        );
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardView}
      >
        <ScrollView contentContainerStyle={styles.scrollContent}>
          <View style={styles.header}>
            <Text style={styles.title}>Welcome Back!</Text>
            <Text style={styles.subtitle}>Sign in to continue</Text>
          </View>

          <View style={styles.form}>
            {generalError ? (
              <Text style={styles.generalError}>{generalError}</Text>
            ) : null}

            <FormInput
              label="Email"
              value={email}
              onChangeText={(text) => {
                setEmail(text);
                setFormErrors(prev => ({ ...prev, email: undefined }));
              }}
              placeholder="Enter your email"
              autoCapitalize="none"
              autoComplete="email"
              keyboardType="email-address"
              error={formErrors.email}
              editable={!loading}
            />

            <FormInput
              label="Password"
              value={password}
              onChangeText={(text) => {
                setPassword(text);
                setFormErrors(prev => ({ ...prev, password: undefined }));
              }}
              placeholder="Enter your password"
              secureTextEntry
              autoComplete="password"
              error={formErrors.password}
              editable={!loading}
            />

            <FormButton
              title="Login"
              onPress={handleLogin}
              loading={loading}
            />
          </View>

          <View style={styles.footer}>
            <Text style={styles.footerText}>Don't have an account? </Text>
            <TouchableOpacity 
              onPress={() => navigation.navigate('Signup')}
              disabled={loading}
            >
              <Text style={styles.footerLink}>Sign Up</Text>
            </TouchableOpacity>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  keyboardView: {
    flex: 1,
  },
  scrollContent: {
    flexGrow: 1,
    padding: 20,
  },
  header: {
    marginTop: 40,
    marginBottom: 32,
    alignItems: 'center',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
  },
  form: {
    marginBottom: 24,
  },
  generalError: {
    color: '#ff3b30',
    textAlign: 'center',
    marginBottom: 16,
    backgroundColor: '#ffebeb',
    padding: 10,
    borderRadius: 8,
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginTop: 'auto',
    paddingVertical: 16,
  },
  footerText: {
    color: '#666',
  },
  footerLink: {
    color: '#2f95dc',
    fontWeight: '600',
  },
});</document_content>
</document>
<document index="12">
<source>golf-tracker/src/screens/AddRoundScreen.tsx</source>
<document_content>
import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet, Alert, TouchableOpacity, Modal, ScrollView, ActivityIndicator } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import DateTimePicker from '@react-native-community/datetimepicker';
import { NativeStackScreenProps } from '@react-navigation/native-stack';
import { FormInput } from '../components/FormInput';
import { FormButton } from '../components/FormButton';
import { createRound } from '../services/rounds';
import { searchCourses, createCourse } from '../services/courses';
import { useAuth } from '../contexts/AuthContext';
import { MainStackParamList } from '../types/navigation';
import { Course } from 'shared';
import { X } from 'lucide-react';

type Props = NativeStackScreenProps<MainStackParamList, 'AddRound'>;

// Add Course Modal Component
function AddCourseModal({ visible, onClose, onAdd }: {
  visible: boolean;
  onClose: () => void;
  onAdd: (courseData: { name: string; location: { city?: string; state?: string; country?: string; } }) => Promise<void>;
}) {
  const [name, setName] = useState('');
  const [city, setCity] = useState('');
  const [state, setState] = useState('');
  const [country, setCountry] = useState('');
  const [loading, setLoading] = useState(false);
  const [errors, setErrors] = useState<{[key: string]: string}>({});

  const handleSubmit = async () => {
    // Validate
    const newErrors: {[key: string]: string} = {};
    if (!name.trim()) newErrors.name = 'Course name is required';
    
    if (Object.keys(newErrors).length > 0) {
      setErrors(newErrors);
      return;
    }

    setLoading(true);
    try {
      await onAdd({
        name,
        location: {
          city: city.trim() || undefined,
          state: state.trim() || undefined,
          country: country.trim() || undefined,
        }
      });
      onClose();
    } catch (error) {
      Alert.alert('Error', 'Failed to add course');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Modal visible={visible} animationType="slide" transparent>
      <View style={styles.modalOverlay}>
        <View style={styles.modalContent}>
          <View style={styles.modalHeader}>
            <Text style={styles.modalTitle}>Add New Course</Text>
            <TouchableOpacity onPress={onClose} style={styles.closeButton}>
              <X size={24} color="#666" />
            </TouchableOpacity>
          </View>
          
          <ScrollView style={styles.modalForm}>
            <FormInput
              label="Course Name"
              value={name}
              onChangeText={setName}
              placeholder="Enter course name"
              error={errors.name}
              editable={!loading}
            />
            <FormInput
              label="City"
              value={city}
              onChangeText={setCity}
              placeholder="Enter city"
              editable={!loading}
            />
            <FormInput
              label="State/Province"
              value={state}
              onChangeText={setState}
              placeholder="Enter state/province"
              editable={!loading}
            />
            <FormInput
              label="Country"
              value={country}
              onChangeText={setCountry}
              placeholder="Enter country"
              editable={!loading}
            />
            
            <View style={styles.modalButtons}>
              <FormButton
                title="Cancel"
                onPress={onClose}
                variant="secondary"
                loading={loading}
              />
              <FormButton
                title="Add Course"
                onPress={handleSubmit}
                loading={loading}
              />
            </View>
          </ScrollView>
        </View>
      </View>
    </Modal>
  );
}

// Course Selection Component
function CourseSelector({ onSelect }: { onSelect: (course: Course) => void }) {
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState<Course[]>([]);
  const [showAddModal, setShowAddModal] = useState(false);
  const [searching, setSearching] = useState(false);
  const { user } = useAuth();

  const handleSearch = async () => {
    if (!searchQuery.trim()) return;
    
    setSearching(true);
    try {
      const courses = await searchCourses(searchQuery);
      setSearchResults(courses);
    } catch (error) {
      Alert.alert('Error', 'Failed to search courses');
    } finally {
      setSearching(false);
    }
  };

  const handleAddCourse = async (courseData: {
    name: string;
    location: {
      city?: string;
      state?: string;
      country?: string;
    };
  }) => {
    if (!user) throw new Error('User not authenticated');

    const course = await createCourse({
      ...courseData,
      addedBy: user._id,
    });
    
    onSelect(course);
  };

  return (
    <View>
      <View style={styles.searchContainer}>
        <FormInput
          label="Search Courses"
          value={searchQuery}
          onChangeText={setSearchQuery}
          placeholder="Enter course name"
          onSubmitEditing={handleSearch}
          style={styles.searchInput}
        />
        <FormButton
          title="Search"
          onPress={handleSearch}
          loading={searching}
        />
      </View>

      {searching ? (
        <ActivityIndicator style={styles.searchingIndicator} />
      ) : searchResults.length > 0 ? (
        <View style={styles.searchResults}>
          {searchResults.map((course) => (
            <TouchableOpacity
              key={course._id}
              style={styles.courseItem}
              onPress={() => onSelect(course)}
            >
              <Text style={styles.courseName}>{course.name}</Text>
              {course.location.city && (
                <Text style={styles.courseLocation}>
                  {[course.location.city, course.location.state].filter(Boolean).join(', ')}
                </Text>
              )}
            </TouchableOpacity>
          ))}
        </View>
      ) : null}

      <TouchableOpacity
        style={styles.addCourseButton}
        onPress={() => setShowAddModal(true)}
      >
        <Text style={styles.addCourseText}>+ Add New Course</Text>
      </TouchableOpacity>

      <AddCourseModal
        visible={showAddModal}
        onClose={() => setShowAddModal(false)}
        onAdd={handleAddCourse}
      />
    </View>
  );
}

export default function AddRoundScreen({ navigation }: Props) {
  const { user } = useAuth();
  const [selectedCourse, setSelectedCourse] = useState<Course | null>(null);
  const [selectedTee, setSelectedTee] = useState('');
  const [date, setDate] = useState(new Date());
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [score, setScore] = useState('');
  const [putts, setPutts] = useState('');
  const [fairways, setFairways] = useState('');
  const [notes, setNotes] = useState('');
  const [loading, setLoading] = useState(false);
  const [errors, setErrors] = useState<{[key: string]: string}>({});

  const validateForm = () => {
    const newErrors: {[key: string]: string} = {};
    
    if (!selectedCourse) newErrors.course = 'Please select a course';
    if (!selectedTee) newErrors.tee = 'Please select tee';
    if (!score) {
      newErrors.score = 'Score is required';
    } else if (isNaN(Number(score)) || Number(score) < 1) {
      newErrors.score = 'Please enter a valid score';
    }
    if (!putts) {
      newErrors.putts = 'Number of putts is required';
    } else if (isNaN(Number(putts)) || Number(putts) < 0) {
      newErrors.putts = 'Please enter a valid number of putts';
    }
    if (!fairways) {
      newErrors.fairways = 'Fairways hit is required';
    } else if (isNaN(Number(fairways)) || Number(fairways) < 0) {
      newErrors.fairways = 'Please enter a valid number of fairways';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async () => {
    if (!validateForm() || !user || !selectedCourse) return;

    setLoading(true);
    try {
      await createRound({
        course: selectedCourse._id,
        date: date.toISOString(),
        tees: selectedTee,
        score: Number(score),
        putts: Number(putts),
        fairways: Number(fairways),
        notes: notes.trim() || undefined,
        addedBy: user._id,
      });

      Alert.alert('Success', 'Round added successfully', [{
        text: 'OK',
        onPress: () => navigation.goBack()
      }]);
    } catch (error) {
      Alert.alert('Error', 'Failed to add round');
    } finally {
      setLoading(false);
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView style={styles.scrollView}>
        <View style={styles.content}>
          <Text style={styles.title}>Add New Round</Text>

          {/* Course Selection */}
          {!selectedCourse ? (
            <CourseSelector onSelect={setSelectedCourse} />
          ) : (
            <View style={styles.selectedCourse}>
              <View style={styles.selectedCourseHeader}>
                <View>
                  <Text style={styles.selectedCourseName}>{selectedCourse.name}</Text>
                  {selectedCourse.location.city && (
                    <Text style={styles.selectedCourseLocation}>
                      {[selectedCourse.location.city, selectedCourse.location.state]
                        .filter(Boolean)
                        .join(', ')}
                    </Text>
                  )}
                </View>
                <TouchableOpacity
                  onPress={() => setSelectedCourse(null)}
                  style={styles.changeCourseButton}
                >
                  <Text style={styles.changeCourseText}>Change</Text>
                </TouchableOpacity>
              </View>

              {/* Tee Selection */}
              <View style={styles.teeSelection}>
                <Text style={styles.label}>Select Tee</Text>
                <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                  {selectedCourse.tees.map((tee) => (
                    <TouchableOpacity
                      key={tee.name}
                      style={[
                        styles.teeButton,
                        selectedTee === tee.name && styles.teeButtonSelected
                      ]}
                      onPress={() => setSelectedTee(tee.name)}
                    >
                      <Text style={[
                        styles.teeButtonText,
                        selectedTee === tee.name && styles.teeButtonTextSelected
                      ]}>
                        {tee.name}
                      </Text>
                    </TouchableOpacity>
                  ))}
                </ScrollView>
                {errors.tee && <Text style={styles.errorText}>{errors.tee}</Text>}
              </View>

              {/* Date Selection */}
              <TouchableOpacity
                style={styles.dateButton}
                onPress={() => setShowDatePicker(true)}
              >
                <Text style={styles.label}>Date</Text>
                <Text style={styles.dateText}>
                  {date.toLocaleDateString()}
                </Text>
              </TouchableOpacity>

              {showDatePicker && (
                <DateTimePicker
                  value={date}
                  mode="date"
                  display="default"
                  onChange={(event, selectedDate) => {
                    setShowDatePicker(false);
                    if (selectedDate) {
                      setDate(selectedDate);
                    }
                  }}
                />
              )}

              {/* Score Inputs */}
              <View style={styles.scoreInputs}>
                <FormInput
                  label="Score"
                  value={score}
                  onChangeText={setScore}
                  keyboardType="numeric"
                  placeholder="Enter total score"
                  error={errors.score}
                  editable={!loading}
                />
                <FormInput
                  label="Putts"
                  value={putts}
                  onChangeText={setPutts}
                  keyboardType="numeric"
                  placeholder="Total putts"
                  error={errors.putts}
                  editable={!loading}
                />
                <FormInput
                  label="Fairways Hit"
                  value={fairways}
                  onChangeText={setFairways}
                  keyboardType="numeric"
                  placeholder="Fairways hit"
                  error={errors.fairways}
                  editable={!loading}
                />
              </View>

              {/* Notes */}
              <FormInput
                label="Notes"
                value={notes}
                onChangeText={setNotes}
                placeholder="Add notes about your round"
                multiline
                numberOfLines={4}
                editable={!loading}
              />

              {/* Submit Button */}
              <FormButton
                title="Save Round"
                onPress={handleSubmit}
                loading={loading}
              />
            </View>
          )}
        </View>
      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollView: {
    flex: 1,
  },
  content: {
    padding: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 24,
    color: '#333',
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'flex-end',
    gap: 8,
    marginBottom: 16,
  },
  searchInput: {
    flex: 1,
  },
  searchingIndicator: {
    marginVertical: 16,
  },
  searchResults: {
    marginTop: 8,
    backgroundColor: '#fff',
    borderRadius: 8,
    overflow: 'hidden',
  },
  courseItem: {
    padding: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  courseName: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
  },
  courseLocation: {
    fontSize: 14,
    color: '#666',
    marginTop: 4,
  },
  addCourseButton: {
    padding: 16,
    alignItems: 'center',
    marginTop: 16,
    backgroundColor: '#fff',
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#2f95dc',
    borderStyle: 'dashed',
  },
  addCourseText: {
    color: '#2f95dc',
    fontSize: 16,
    fontWeight: '600',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    backgroundColor: '#fff',
    borderRadius: 12,
    width: '90%',
    maxHeight: '80%',
    elevation: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 4,
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
  },
  closeButton: {
    padding: 4,
  },
  modalForm: {
    padding: 16,
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    gap: 12,
    marginTop: 24,
  },
  selectedCourse: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
  },
  selectedCourseHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 16,
  },
  selectedCourseName: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  selectedCourseLocation: {
    fontSize: 14,
    color: '#666',
    marginTop: 4,
  },
  changeCourseButton: {
    padding: 8,
  },
  changeCourseText: {
    color: '#2f95dc',
    fontSize: 14,
    fontWeight: '600',
  },
  teeSelection: {
    marginBottom: 16,
  },
  label: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
  },
  teeButton: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: '#ddd',
    marginRight: 8,
    backgroundColor: '#fff',
  },
  teeButtonSelected: {
    backgroundColor: '#2f95dc',
    borderColor: '#2f95dc',
  },
  teeButtonText: {
    fontSize: 14,
    color: '#666',
  },
  teeButtonTextSelected: {
    color: '#fff',
  },
  dateButton: {
    marginBottom: 16,
  },
  dateText: {
    fontSize: 16,
    color: '#333',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    backgroundColor: '#fff',
  },
  scoreInputs: {
    gap: 16,
    marginBottom: 16,
  },
  errorText: {
    color: '#ff3b30',
    fontSize: 14,
    marginTop: 4,
  }
});</document_content>
</document>
<document index="13">
<source>golf-tracker/src/screens/HomeScreen.tsx</source>
<document_content>
// src/screens/HomeScreen.tsx
import React, { useState, useEffect } from 'react';
import {
  StyleSheet,
  View,
  Text,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useAuth } from '../contexts/AuthContext';
import { fetchUserRounds } from '../services/rounds';
import { Round } from 'shared';
import { MainStackParamList } from '../types/navigation';
import { NativeStackScreenProps } from '@react-navigation/native-stack';

type Props = NativeStackScreenProps<MainStackParamList, 'Home'>;

export default function HomeScreen({ navigation }: Props) {
  const { user, logout } = useAuth();
  const [rounds, setRounds] = useState<Round[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchRounds = async () => {
      try {
        if (user) {
          const userRounds = await fetchUserRounds(user._id);
          setRounds(userRounds);
        }
      } catch (error) {
        console.error('Error fetching rounds:', error);
        Alert.alert('Error', 'Failed to fetch rounds. Please try again later.');
      } finally {
        setLoading(false);
      }
    };

    fetchRounds();
  }, [user]);

  const handleLogout = async () => {
    try {
      await logout();
    } catch (error) {
      console.error('Error logging out:', error);
      Alert.alert(
        'Error',
        'There was a problem logging out. Please try again.'
      );
    }
  };

  if (loading) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#2f95dc" />
        </View>
      </SafeAreaView>
    );
  }

  const handicapIndex = 14.2; // This would come from actual user data
  const recentScores = rounds.slice(0, 5).map((round) => round.score);

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView contentContainerStyle={styles.scrollContent}>
        {/* Header Section */}
        <View style={styles.header}>
          <View style={styles.welcomeContainer}>
            <Text style={styles.welcomeText}>Welcome back, </Text>
            <Text style={styles.nameText}>{user.name || 'Golfer'}</Text>
          </View>
          <TouchableOpacity 
            style={styles.logoutButton}
            onPress={handleLogout}
          >
            <Text style={styles.logoutText}>Logout</Text>
          </TouchableOpacity>
        </View>

        {/* Handicap Card */}
        <View style={styles.card}>
          <Text style={styles.cardTitle}>Current Handicap</Text>
          <Text style={styles.handicapText}>{handicapIndex}</Text>
          <TouchableOpacity style={styles.actionButton}>
            <Text style={styles.actionButtonText}>View Details</Text>
          </TouchableOpacity>
        </View>

        {/* Quick Actions */}
        <View style={styles.quickActions}>
          <TouchableOpacity style={styles.quickActionButton} onPress={() => navigation.navigate('AddRound')}>
            <Text style={styles.quickActionEmoji}>ğŸŒï¸</Text>
            <Text style={styles.quickActionText}>New Round</Text>
          </TouchableOpacity>
          <TouchableOpacity style={styles.quickActionButton}>
            <Text style={styles.quickActionEmoji}>ğŸ“Š</Text>
            <Text style={styles.quickActionText}>Statistics</Text>
          </TouchableOpacity>
          <TouchableOpacity style={styles.quickActionButton}>
            <Text style={styles.quickActionEmoji}>ğŸ¯</Text>
            <Text style={styles.quickActionText}>Goals</Text>
          </TouchableOpacity>
        </View>

        {/* Recent Scores */}
        <View style={styles.card}>
          <Text style={styles.cardTitle}>Recent Scores</Text>
          {rounds.length === 0 ? (
            <Text style={styles.noRoundsText}>
              Add rounds to begin tracking your stats!
            </Text>
          ) : (
            <View style={styles.recentScores}>
              {recentScores.map((score, index) => (
                <View key={index} style={styles.scoreItem}>
                  <Text style={styles.scoreText}>{score}</Text>
                  <Text style={styles.scoreDate}>
                    {new Date(rounds[index].date).toLocaleDateString()}
                  </Text>
                </View>
              ))}
            </View>
          )}
          <TouchableOpacity
            style={[
              styles.actionButton,
              rounds.length === 0 && styles.disabledButton,
            ]}
            disabled={rounds.length === 0}
          >
            <Text style={styles.actionButtonText}>View All Rounds</Text>
          </TouchableOpacity>
        </View>

        {/* Tips Section */}
        <View style={styles.card}>
          <Text style={styles.cardTitle}>Today's Tip</Text>
          <Text style={styles.tipText}>
            "Focus on your tempo during practice swings. A consistent tempo leads to more consistent shots."
          </Text>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  scrollContent: {
    padding: 16,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  welcomeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  welcomeText: {
    fontSize: 20,
    color: '#666',
  },
  nameText: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
  },
  logoutButton: {
    padding: 8,
  },
  logoutText: {
    color: '#2f95dc',
    fontSize: 16,
  },
  card: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  cardTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
    marginBottom: 12,
  },
  handicapText: {
    fontSize: 48,
    fontWeight: 'bold',
    color: '#2f95dc',
    textAlign: 'center',
    marginVertical: 16,
  },
  quickActions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 16,
  },
  quickActionButton: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    alignItems: 'center',
    width: '31%',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  quickActionEmoji: {
    fontSize: 24,
    marginBottom: 8,
  },
  quickActionText: {
    fontSize: 14,
    color: '#333',
    textAlign: 'center',
  },
  recentScores: {
    marginBottom: 12,
  },
  scoreItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  scoreText: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
  },
  scoreDate: {
    fontSize: 14,
    color: '#666',
  },
  actionButton: {
    backgroundColor: '#2f95dc',
    borderRadius: 8,
    padding: 12,
    alignItems: 'center',
    marginTop: 8,
  },
  actionButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  tipText: {
    fontSize: 16,
    color: '#666',
    fontStyle: 'italic',
    lineHeight: 24,
  },
  noRoundsText: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginVertical: 16,
  },
  disabledButton: {
    backgroundColor: '#ccc',
  },
});</document_content>
</document>
<document index="14">
<source>golf-tracker/src/components/FormButton.tsx</source>
<document_content>
// src/components/FormButton.tsx
import React from 'react';
import { 
  StyleSheet, 
  TouchableOpacity, 
  Text, 
  ActivityIndicator 
} from 'react-native';

interface FormButtonProps {
  title: string;
  onPress: () => void;
  variant?: 'primary' | 'secondary';
  loading?: boolean;
}

export function FormButton({ 
  title, 
  onPress, 
  variant = 'primary',
  loading = false 
}: FormButtonProps) {
  return (
    <TouchableOpacity
      style={[
        styles.button,
        variant === 'secondary' && styles.secondaryButton,
        loading && styles.buttonDisabled
      ]}
      onPress={onPress}
      disabled={loading}
    >
      {loading ? (
        <ActivityIndicator color={variant === 'primary' ? '#fff' : '#2f95dc'} />
      ) : (
        <Text 
          style={[
            styles.buttonText,
            variant === 'secondary' && styles.secondaryButtonText
          ]}
        >
          {title}
        </Text>
      )}
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  button: {
    height: 48,
    borderRadius: 8,
    backgroundColor: '#2f95dc',
    justifyContent: 'center',
    alignItems: 'center',
  },
  secondaryButton: {
    backgroundColor: 'transparent',
    borderWidth: 2,
    borderColor: '#2f95dc',
  },
  buttonDisabled: {
    opacity: 0.6,
  },
  buttonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  secondaryButtonText: {
    color: '#2f95dc',
  },
});</document_content>
</document>
<document index="15">
<source>golf-tracker/src/components/FormInput.tsx</source>
<document_content>
// src/components/FormInput.tsx
import React from 'react';
import { StyleSheet, TextInput, TextInputProps, View, Text } from 'react-native';

interface FormInputProps extends TextInputProps {
  label?: string;
  error?: string;
}

export function FormInput({ label, error, style, ...props }: FormInputProps) {
  return (
    <View style={styles.container}>
      {label && <Text style={styles.label}>{label}</Text>}
      <TextInput
        style={[styles.input, error && styles.inputError, style]}
        placeholderTextColor="#999"
        {...props}
      />
      {error && <Text style={styles.errorText}>{error}</Text>}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    marginBottom: 16,
  },
  label: {
    fontSize: 16,
    marginBottom: 8,
    color: '#333',
  },
  input: {
    height: 48,
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    paddingHorizontal: 16,
    fontSize: 16,
    backgroundColor: '#fff',
  },
  inputError: {
    borderColor: '#ff3b30',
  },
  errorText: {
    color: '#ff3b30',
    fontSize: 14,
    marginTop: 4,
  },
});</document_content>
</document>
<document index="16">
<source>golf-tracker/src/services/courses.ts</source>
<document_content>
// src/services/courses.ts
import { Course, CreateCourseInput } from 'shared';
import { getAuthToken } from './auth';

const API_URL = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:3000/api';

export async function searchCourses(query: string): Promise<Course[]> {
  try {
    const token = await getAuthToken();
    if (!token) {
      throw new Error('No auth token found');
    }

    const response = await fetch(`${API_URL}/courses?search=${encodeURIComponent(query)}`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error('Failed to search courses');
    }

    const data = await response.json();
    return data.data as Course[];
  } catch (error) {
    console.error('Error searching courses:', error);
    throw error;
  }
}

export async function createCourse(courseData: CreateCourseInput): Promise<Course> {
  try {
    const token = await getAuthToken();
    if (!token) {
      throw new Error('No auth token found');
    }

    const response = await fetch(`${API_URL}/courses`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(courseData)
    });

    if (!response.ok) {
      throw new Error('Failed to create course');
    }

    const data = await response.json();
    return data.data as Course;
  } catch (error) {
    console.error('Error creating course:', error);
    throw error;
  }
}</document_content>
</document>
<document index="17">
<source>golf-tracker/src/services/rounds.ts</source>
<document_content>
// src/services/rounds.ts
import { Round, CreateRoundInput } from 'shared';
import { getAuthToken } from './auth';

const API_URL = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:3000/api';

export async function fetchUserRounds(userId: string): Promise<Round[]> {
  try {
    const token = await getAuthToken();
    if (!token) {
      throw new Error('No auth token found');
    }

    const response = await fetch(`${API_URL}/rounds?userId=${userId}`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error('Failed to fetch rounds');
    }

    const data = await response.json();
    return data.data.map((round: Round) => ({
      ...round,
      date: new Date(round.date)
    }));
  } catch (error) {
    console.error('Error fetching rounds:', error);
    throw error;
  }
}

export async function createRound(roundData: CreateRoundInput): Promise<Round> {
  try {
    const token = await getAuthToken();
    if (!token) {
      throw new Error('No auth token found');
    }

    // Ensure date is an ISO string
    const formattedRoundData = {
      ...roundData,
      date: roundData.date instanceof Date 
        ? roundData.date.toISOString() 
        : new Date(roundData.date).toISOString()
    };

    const response = await fetch(`${API_URL}/rounds`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(formattedRoundData)
    });

    if (!response.ok) {
      // Try to parse error message
      const errorData = await response.json().catch(() => null);
      throw new Error(errorData?.message || 'Failed to create round');
    }

    const data = await response.json();
    // Convert date to Date object
    return {
      ...data.data,
      date: new Date(data.data.date)
    };
  } catch (error) {
    console.error('Error creating round:', error);
    throw error;
  }
}</document_content>
</document>
<document index="18">
<source>golf-tracker/src/services/auth.ts</source>
<document_content>
// src/services/auth.ts
import * as SecureStore from 'expo-secure-store';
import { User, CreateUserInput } from 'shared';

const API_URL = 'http://localhost:3000/api';
const AUTH_TOKEN_KEY = 'auth_token';

export class AuthError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'AuthError';
  }
}

interface ServerUser {
  _id: string;
  email: string;
  name?: string;
  createdAt: string;
  updatedAt: string;
}

interface AuthResponse {
  success: boolean;
  message?: string;
  data?: {
    user: ServerUser;
    token: string;
  };
}

function transformUser(serverUser: ServerUser): User {
  return {
    ...serverUser,
    createdAt: new Date(serverUser.createdAt),
    updatedAt: new Date(serverUser.updatedAt)
  };
}

async function storeAuthToken(token: string): Promise<void> {
  await SecureStore.setItemAsync(AUTH_TOKEN_KEY, token);
}

export async function getAuthToken(): Promise<string | null> {
  return await SecureStore.getItemAsync(AUTH_TOKEN_KEY);
}

export async function removeAuthToken(): Promise<void> {
  await SecureStore.deleteItemAsync(AUTH_TOKEN_KEY);
}

export async function validateToken(token: string): Promise<User | null> {
  try {
    const response = await fetch(`${API_URL}/auth/validate`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) return null;

    const data: AuthResponse = await response.json();
    return data.success && data.data?.user ? transformUser(data.data.user) : null;
  } catch (error) {
    console.error('Token validation error:', error);
    return null;
  }
}

export async function signup(userData: CreateUserInput): Promise<User> {
  const response = await fetch(`${API_URL}/auth/signup`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(userData),
  });

  const data: AuthResponse = await response.json();

  if (!data.success || !data.data?.user || !data.data?.token) {
    throw new AuthError(data.message || 'Error creating account');
  }

  await storeAuthToken(data.data.token);
  return transformUser(data.data.user);
}

export async function login(email: string, password: string): Promise<User> {
  try {
    const response = await fetch(`${API_URL}/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    });

    console.log('Response status:', response.status);
    const text = await response.text();
    console.log('Raw response:', text);

    let data;
    try {
      data = JSON.parse(text);
    } catch (e) {
      console.error('JSON parse error:', e);
      throw new AuthError('Invalid server response');
    }
    console.log('API Response:', JSON.stringify(data, null, 2));

    if (!data.success || !data.data?.user || !data.data?.token) {
      throw new AuthError(data.message || 'Invalid credentials');
    }

    const { user, token } = data.data;
    console.log('User data before transform:', user);

    await storeAuthToken(token);

    // Create user object explicitly
    const transformedUser: User = {
      _id: user._id,
      email: user.email,
      name: user.name,
      createdAt: new Date(user.createdAt),
      updatedAt: new Date(user.updatedAt)
    };

    console.log('Transformed user:', transformedUser);
    return transformedUser;
  } catch (error) {
    console.error('Login error:', error);
    throw new AuthError('Login failed');
  }
}

export async function logout(): Promise<void> {
  try {
    await removeAuthToken();
  } catch (error) {
    throw new AuthError('Error logging out');
  }
}</document_content>
</document>
<document index="2">
<source>server/middleware/auth.ts</source>
<document_content>
// server/middleware/auth.ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { User } from 'shared';
import UserModel, { IUser } from '../models/User';

// Extend Express Request type to include user
interface AuthRequest extends Request {
  user?: User;
}

interface JwtPayload {
  userId: string;
  email: string;
}

export const authenticateToken = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader?.startsWith('Bearer ')) {
      return res.status(401).json({
        success: false,
        message: 'No token provided'
      });
    }

    const token = authHeader.split(' ')[1];
    
    const decoded = jwt.verify(
      token, 
      process.env.JWT_SECRET!
    ) as JwtPayload;
    
    // Explicitly type the mongoose document
    const user = await UserModel.findById(decoded.userId)
      .select('-password') as IUser | null;

    if (!user) {
      return res.status(401).json({
        success: false,
        message: 'User not found'
      });
    }

    // Transform mongoose document to shared User type
    req.user = {
      _id: user._id.toString(), // Convert mongoose ObjectId to string
      email: user.email,
      name: user.name,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt
    };

    next();
  } catch (error) {
    if (error instanceof jwt.JsonWebTokenError) {
      return res.status(401).json({
        success: false,
        message: 'Invalid token'
      });
    }

    console.error('Auth middleware error:', error);
    return res.status(500).json({
      success: false,
      message: 'Internal server error'
    });
  }
};</document_content>
</document>
<document index="3">
<source>server/models/Round.ts</source>
<document_content>
// server/models/Round.ts
import mongoose from 'mongoose';
import { Round } from 'shared';

export interface IRound extends Omit<Round, '_id' | 'course' | 'addedBy'> {
  _id: mongoose.Types.ObjectId;
  course: mongoose.Types.ObjectId;
  addedBy: mongoose.Types.ObjectId;
  calculateDifferential(): Promise<number>;
}

const roundSchema = new mongoose.Schema({
  course: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Course',
    required: true
  },
  date: {
    type: Date,
    required: true,
    default: Date.now
  },
  tees: {
    type: String,
    required: true
  },
  score: {
    type: Number,
    required: true
  },
  putts: {
    type: Number,
    required: true
  },
  fairways: {
    type: Number,
    required: true
  },
  notes: {
    type: String
  },
  addedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  }
}, {
  timestamps: true
});

// Add indexes for common queries
roundSchema.index({ addedBy: 1, date: -1 });
roundSchema.index({ course: 1, addedBy: 1 });

// Calculate differential for handicap index
roundSchema.methods.calculateDifferential = async function(): Promise<number> {
  const course = await mongoose.model('Course').findById(this.course);
  if (!course) throw new Error('Course not found');
  
  const tee = course.tees.find((t: { name: string; }) => t.name === this.tees);
  if (!tee) throw new Error('Tee not found');
  
  return ((this.score - tee.rating) * 113) / tee.slope;
};

const Round = mongoose.model<IRound>('Round', roundSchema);
export default Round;</document_content>
</document>
<document index="4">
<source>server/models/Course.ts</source>
<document_content>
// server/models/Course.ts
import mongoose from 'mongoose';
import { Course } from 'shared';

export interface ICourse extends Omit<Course, '_id' | 'addedBy'> {
  _id: mongoose.Types.ObjectId;
  addedBy: mongoose.Types.ObjectId;
}

const teeSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true
  },
  rating: {
    type: Number,
    required: true
  },
  slope: {
    type: Number,
    required: true
  },
  numberOfFairways: {
    type: Number,
    required: true,
    min: 0,
    max: 18,
    validate: {
      validator: Number.isInteger,
      message: 'Number of fairways must be a whole number'
    }
  }
});

const courseSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  location: {
    city: {
      type: String,
      trim: true
    },
    state: {
      type: String,
      trim: true
    },
    country: {
      type: String,
      trim: true
    }
  },
  tees: [teeSchema],
  addedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  }
}, {
  timestamps: true
});

// Make courses unique by name + location
courseSchema.index({ 
  name: 1, 
  'location.city': 1, 
  'location.state': 1,
  'location.country': 1
}, { 
  unique: true,
  collation: { locale: 'en', strength: 2 } // Case-insensitive uniqueness
});

const Course = mongoose.model<ICourse>('Course', courseSchema);
export default Course;</document_content>
</document>
<document index="5">
<source>server/models/User.ts</source>
<document_content>
// server/models/User.ts
import mongoose from 'mongoose';
import { User } from 'shared';
import bcrypt from 'bcryptjs';

const SALT_ROUNDS = 10;

export interface IUser extends Omit<User, '_id'> {
  _id: mongoose.Types.ObjectId;
  password: string;
  comparePassword(candidatePassword: string): Promise<boolean>;
}

const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: true,
    unique: true,
  },
  password: {
    type: String,
    required: true,
  },
  name: String
}, {
  timestamps: true
});

// Hash password before saving
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();

  try {
    const salt = await bcrypt.genSalt(SALT_ROUNDS);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error as Error);
  }
});

// Method to compare passwords
userSchema.methods.comparePassword = async function(candidatePassword: string): Promise<boolean> {
  try {
    return await bcrypt.compare(candidatePassword, this.password);
  } catch (error) {
    throw error;
  }
};

const UserModel = mongoose.model<IUser>('User', userSchema);

export default UserModel;</document_content>
</document>
<document index="6">
<source>server/index.ts</source>
<document_content>
// server/index.ts
import express from 'express';
import mongoose from 'mongoose';
import cors from 'cors';
import dotenv from 'dotenv';
import authRoutes from './routes/auth';
import courseRoutes from './routes/courses';
import roundRoutes from './routes/rounds';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;
const MONGODB_URI = process.env.MONGODB_URI;

if (!MONGODB_URI) {
  throw new Error('MONGODB_URI must be defined in environment variables');
}

app.use(cors({
  origin: ['http://localhost:19006', 'http://localhost:19000'],
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'Accept'],
  credentials: true
}));

app.use(express.json());

mongoose.connect(MONGODB_URI)
  .then(() => console.log('Connected to MongoDB'))
  .catch(err => {
    console.error('MongoDB connection error:', err);
    process.exit(1);
  });

app.use('/api/auth', authRoutes);
app.use('/api/courses', courseRoutes);
app.use('/api/rounds', roundRoutes);

app.get('/health', (req, res) => {
  res.json({ 
    status: 'healthy',
    timestamp: new Date().toISOString()
  });
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});</document_content>
</document>
<document index="7">
<source>server/routes/courses.ts</source>
<document_content>
// server/routes/courses.ts
import express, { Request } from 'express';
import { Course, CreateCourseInput } from 'shared';
import CourseModel, { ICourse } from '../models/Course';
import { authenticateToken } from '../middleware/auth';

const router = express.Router();

function mapCourseToResponse(course: ICourse): Course {
  return {
    _id: course._id.toString(),
    name: course.name,
    location: course.location,
    tees: course.tees,
    addedBy: course.addedBy.toString(),
    createdAt: course.createdAt,
    updatedAt: course.updatedAt
  };
}

router.get('/', authenticateToken, async (req, res) => {
  try {
    const { search } = req.query;
    const query = search ? {
      $or: [
        { name: new RegExp(search as string, 'i') },
        { 'location.city': new RegExp(search as string, 'i') }
      ]
    } : {};

    const courses = await CourseModel.find(query).sort({ name: 1 }).limit(50);
    res.json({
      success: true,
      data: courses.map(mapCourseToResponse)
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching courses'
    });
  }
});

router.post('/', authenticateToken, async (req: Request & { user?: { _id: string } }, res) => {
  try {
    const userId = req.user?._id;
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'Unauthorized'
      });
    }

    const courseData: CreateCourseInput = {
      ...req.body,
      addedBy: userId
    };

    const course = new CourseModel(courseData);
    await course.save();

    res.status(201).json({
      success: true,
      data: mapCourseToResponse(course)
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error creating course'
    });
  }
});

export default router;</document_content>
</document>
<document index="8">
<source>server/routes/rounds.ts</source>
<document_content>
// server/routes/rounds.ts
import express, { Request } from 'express';
import { Round } from 'shared';
import RoundModel from '../models/Round';
import { authenticateToken } from '../middleware/auth';

interface AuthRequest extends Request {
  user?: {
    _id: string;
    email: string;
  };
}

const router = express.Router();

function mapRoundToResponse(round: any): Round {
  return {
    _id: round._id.toString(),
    course: round.course.toString(),
    date: round.date,
    tees: round.tees,
    score: round.score,
    putts: round.putts,
    fairways: round.fairways,
    notes: round.notes,
    addedBy: round.addedBy.toString(),
    createdAt: round.createdAt,
    updatedAt: round.updatedAt
  };
}

router.get('/', authenticateToken, async (req: AuthRequest, res) => {
  try {
    const userId = req.user?._id;
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User not authenticated'
      });
    }

    const rounds = await RoundModel.find({ addedBy: userId })
      .populate('course')
      .sort({ date: -1 });

    res.json({
      success: true,
      data: rounds.map(mapRoundToResponse)
    });
  } catch (error) {
    console.error('Error fetching rounds:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching rounds'
    });
  }
});

router.post('/', authenticateToken, async (req: AuthRequest, res) => {
  try {
    const userId = req.user?._id;
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User not authenticated'
      });
    }

    const roundData = {
      ...req.body,
      addedBy: userId
    };

    const round = new RoundModel(roundData);
    await round.save();

    // Populate the course to get the full course details
    await round.populate('course');

    res.status(201).json({
      success: true,
      data: mapRoundToResponse(round)
    });
  } catch (error) {
    console.error('Error creating round:', error);
    res.status(500).json({
      success: false,
      message: 'Error creating round'
    });
  }
});

export default router;</document_content>
</document>
<document index="9">
<source>server/routes/auth.ts</source>
<document_content>
// server/routes/auth.ts
import express from 'express';
import jwt from 'jsonwebtoken';
import { z } from 'zod';
import { User, CreateUserInput } from 'shared';
import UserModel, { IUser } from '../models/User';

const router = express.Router();

const signupSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
  name: z.string().min(1)
});

const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8)
});

function generateToken(user: IUser): string {
  return jwt.sign(
    { userId: user._id.toString(), email: user.email },
    process.env.JWT_SECRET!,
    { expiresIn: '24h' }
  );
}

function mapUserToResponse(user: IUser): User {
  return {
    _id: user._id.toString(),
    email: user.email,
    name: user.name,
    createdAt: user.createdAt,
    updatedAt: user.updatedAt
  };
}

router.post('/signup', async (req, res) => {
  try {
    const validatedData = signupSchema.parse(req.body);
    const existingUser = await UserModel.findOne({
      email: { $regex: new RegExp(`^${validatedData.email}$`, 'i') }
    });

    if (existingUser) {
      return res.status(400).json({
        success: false,
        message: 'Email already registered'
      });
    }

    const user = new UserModel(validatedData);
    await user.save();

    res.status(201).json({
      success: true,
      data: {
        user: mapUserToResponse(user),
        token: generateToken(user)
      }
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        success: false,
        message: 'Validation error',
        errors: error.errors
      });
    }
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

router.post('/login', async (req, res) => {
  try {
    const validatedData = loginSchema.parse(req.body);
    const user = await UserModel.findOne({
      email: { $regex: new RegExp(`^${validatedData.email}$`, 'i') }
    });

    if (!user) {
      return res.status(401).json({
        success: false,
        message: 'Invalid credentials'
      });
    }

    const isValidPassword = await user.comparePassword(validatedData.password);
    if (!isValidPassword) {
      return res.status(401).json({
        success: false,
        message: 'Invalid credentials'
      });
    }

    const token = generateToken(user);
    res.json({
      success: true,
      data: {
        user: mapUserToResponse(user),
        token
      }
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        success: false,
        message: 'Validation error',
        errors: error.errors
      });
    }
    console.error('Login error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

export default router;</document_content>
</document>
<document index="2">
<source>shared/dist/types/course.d.ts</source>
<document_content>
import { BaseDocument } from './base';
export interface Course extends BaseDocument {
    name: string;
    location: {
        city?: string;
        state?: string;
        country?: string;
    };
    tees: Array<{
        name: string;
        rating: number;
        slope: number;
        numberOfFairways: number;
    }>;
    addedBy: string;
}
export interface CreateCourseInput {
    name: string;
    location: {
        city?: string;
        state?: string;
        country?: string;
    };
    addedBy: string;
}
</document_content>
</document>
<document index="3">
<source>shared/dist/types/user.d.ts</source>
<document_content>
import { BaseDocument } from './base';
export interface User extends BaseDocument {
    email: string;
    name?: string;
}
export interface CreateUserInput {
    email: string;
    password: string;
    name?: string;
}
</document_content>
</document>
<document index="4">
<source>shared/dist/types/base.d.ts</source>
<document_content>
export interface BaseDocument {
    _id: string;
    createdAt: Date;
    updatedAt: Date;
}
</document_content>
</document>
<document index="5">
<source>shared/dist/types/round.d.ts</source>
<document_content>
import { BaseDocument } from './base';
export interface Round extends BaseDocument {
    course: string;
    date: Date | string;
    tees: string;
    score: number;
    putts: number;
    fairways: number;
    notes?: string;
    addedBy: string;
}
export interface CreateRoundInput {
    course: string;
    date: Date | string;
    tees: string;
    score: number;
    putts: number;
    fairways: number;
    notes?: string;
    addedBy: string;
}
</document_content>
</document>
<document index="6">
<source>shared/dist/index.d.ts</source>
<document_content>
export * from './types/user';
export * from './types/course';
export * from './types/round';
</document_content>
</document>
<document index="7">
<source>shared/src/types/base.ts</source>
<document_content>
// shared/src/types/base.ts
export interface BaseDocument {
  _id: string;
  createdAt: Date;
  updatedAt: Date;
}
</document_content>
</document>
<document index="8">
<source>shared/src/types/round.ts</source>
<document_content>
// shared/src/types/round.ts
import { BaseDocument } from './base';

export interface Round extends BaseDocument {
  course: string;
  date: Date | string;
  tees: string;
  score: number;
  putts: number;
  fairways: number;
  notes?: string;
  addedBy: string;
}

export interface CreateRoundInput {
  course: string;
  date: Date | string;
  tees: string;
  score: number;
  putts: number;
  fairways: number;
  notes?: string;
  addedBy: string;
}</document_content>
</document>
<document index="9">
<source>shared/src/types/course.ts</source>
<document_content>
// shared/src/types/course.ts
import { BaseDocument } from './base';

export interface Course extends BaseDocument {
  name: string;
  location: {
    city?: string;
    state?: string;
    country?: string;
  };
  tees: Array<{
    name: string;
    rating: number;
    slope: number;
    numberOfFairways: number;
  }>;
  addedBy: string;
}

export interface CreateCourseInput {
  name: string;
  location: {
    city?: string;
    state?: string;
    country?: string;
  };
  addedBy: string;
}</document_content>
</document>
<document index="10">
<source>shared/src/types/user.ts</source>
<document_content>
// shared/src/types/user.ts
import { BaseDocument } from './base';

export interface User extends BaseDocument {
  email: string;
  name?: string;
}

export interface CreateUserInput {
  email: string;
  password: string;
  name?: string;
}</document_content>
</document>
<document index="11">
<source>shared/src/index.ts</source>
<document_content>
// shared/src/index.ts
export * from './types/user';
export * from './types/course';
export * from './types/round';</document_content>
</document>
</documents>
