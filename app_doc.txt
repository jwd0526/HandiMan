<documents>
<document index="1">
<source>directory-structure.txt</source>
<document_content>
.
├── golf-tracker
│   ├── src
│   │   ├── components
│   │   │   ├── common
│   │   │   │   ├── BackButton
│   │   │   │   │   ├── index.tsx
│   │   │   │   │   └── styles.ts
│   │   │   │   ├── ErrorBoundary
│   │   │   │   │   ├── index.tsx
│   │   │   │   │   └── styles.ts
│   │   │   │   └── LoadingScreen
│   │   │   │       ├── index.tsx
│   │   │   │       └── styles.ts
│   │   │   ├── course
│   │   │   │   ├── CourseSearch
│   │   │   │   │   ├── index.tsx
│   │   │   │   │   └── styles.ts
│   │   │   │   └── TeeSelector
│   │   │   │       ├── index.tsx
│   │   │   │       └── styles.ts
│   │   │   ├── forms
│   │   │   │   ├── FormButton
│   │   │   │   │   ├── index.tsx
│   │   │   │   │   └── styles.ts
│   │   │   │   └── FormInput
│   │   │   │       ├── index.tsx
│   │   │   │       └── styles.ts
│   │   │   ├── layout
│   │   │   │   ├── AuthLayout
│   │   │   │   │   ├── index.tsx
│   │   │   │   │   └── styles.ts
│   │   │   │   └── MainLayout
│   │   │   │       ├── index.tsx
│   │   │   │       └── styles.ts
│   │   │   ├── providers
│   │   │   │   ├── AuthProvider.tsx
│   │   │   │   ├── CourseProvider.tsx
│   │   │   │   └── GoalsProvider.tsx
│   │   │   └── round
│   │   │       └── RoundDetails
│   │   │           ├── index.tsx
│   │   │           └── styles.ts
│   │   ├── config
│   │   │   ├── constants.ts
│   │   │   ├── navigation.ts
│   │   │   └── theme.ts
│   │   ├── hooks
│   │   │   ├── useAuth.ts
│   │   │   ├── useCourses.ts
│   │   │   ├── useForm.ts
│   │   │   ├── useGoals.ts
│   │   │   └── useRounds.ts
│   │   ├── screens
│   │   │   ├── Goals
│   │   │   │   ├── index.tsx
│   │   │   │   └── styles.ts
│   │   │   ├── Home
│   │   │   │   ├── index.tsx
│   │   │   │   └── styles.ts
│   │   │   ├── Statistics
│   │   │   │   ├── index.tsx
│   │   │   │   └── styles.ts
│   │   │   ├── auth
│   │   │   │   ├── Landing
│   │   │   │   │   ├── index.tsx
│   │   │   │   │   └── styles.ts
│   │   │   │   ├── Login
│   │   │   │   │   ├── index.tsx
│   │   │   │   │   └── styles.ts
│   │   │   │   └── Signup
│   │   │   │       ├── index.tsx
│   │   │   │       └── styles.ts
│   │   │   ├── course
│   │   │   │   └── AddCourse
│   │   │   │       ├── index.tsx
│   │   │   │       └── styles.ts
│   │   │   └── rounds
│   │   │       ├── AddRound
│   │   │       │   ├── index.tsx
│   │   │       │   └── styles.ts
│   │   │       └── AllRounds
│   │   │           ├── index.tsx
│   │   │           └── styles.ts
│   │   ├── services
│   │   │   ├── api
│   │   │   │   ├── auth.ts
│   │   │   │   ├── courses.ts
│   │   │   │   ├── goals.ts
│   │   │   │   └── rounds.ts
│   │   │   └── storage
│   │   │       └── secureStorage.ts
│   │   ├── types
│   │   │   └── navigation.ts
│   │   └── utils
│   │       ├── date.ts
│   │       ├── handicap.ts
│   │       └── validation.ts
│   ├── .DS_Store
│   ├── .gitignore
│   ├── App.tsx
│   ├── app.json
│   ├── index.js
│   ├── package-lock.json
│   ├── package.json
│   └── tsconfig.json
├── server
│   ├── middleware
│   │   └── auth.ts
│   ├── models
│   │   ├── Course.ts
│   │   ├── Goal.ts
│   │   ├── Round.ts
│   │   └── User.ts
│   ├── routes
│   │   ├── auth.ts
│   │   ├── courses.ts
│   │   ├── goals.ts
│   │   └── rounds.ts
│   ├── .DS_Store
│   ├── .env
│   ├── README.md
│   ├── index.ts
│   ├── package-lock.json
│   ├── package.json
│   ├── simulate-courses.ts
│   ├── simulate-rounds.ts
│   └── tsconfig.json
├── shared
│   ├── src
│   │   ├── types
│   │   │   ├── base.ts
│   │   │   ├── course.ts
│   │   │   ├── goal.ts
│   │   │   ├── round.ts
│   │   │   └── user.ts
│   │   └── index.ts
│   ├── package-lock.json
│   ├── package.json
│   └── tsconfig.json
├── .DS_Store
├── .gitignore
├── app_doc.txt
├── dev.sh
├── document-app.sh
└── package-lock.json

47 directories, 99 files
</document_content>
</document>
<document index="2">
<source>golf-tracker/App.tsx</source>
<document_content>
// App.tsx
import React, { useMemo } from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { StatusBar } from 'expo-status-bar';
import { SafeAreaProvider } from 'react-native-safe-area-context';

// Screens
import { LandingScreen } from './src/screens/auth/Landing';
import { LoginScreen } from './src/screens/auth/Login';
import { SignupScreen } from './src/screens/auth/Signup';
import { HomeScreen } from './src/screens/Home';
import { AddRoundScreen } from './src/screens/rounds/AddRound';
import { AllRoundsScreen } from './src/screens/rounds/AllRounds';
import { AddCourseScreen } from './src/screens/course/AddCourse';
import { StatisticsScreen } from './src/screens/Statistics';
import { GoalsScreen } from './src/screens/Goals';

// Types
import { AuthStackParamList, MainStackParamList } from './src/config/navigation';

// Context Providers
import { AuthProvider, useAuthContext } from './src/components/providers/AuthProvider';
import { CoursesProvider } from './src/components/providers/CourseProvider';
import { GoalsProvider } from './src/components/providers/GoalsProvider';


const AuthStack = createNativeStackNavigator<AuthStackParamList>();
const MainStack = createNativeStackNavigator<MainStackParamList>();

const AuthNavigator = React.memo(() => {
  return (
    <AuthStack.Navigator
      id={null}
      screenOptions={{
        headerShown: false,
        contentStyle: { backgroundColor: '#fff' }
      }}
    >
      <AuthStack.Screen name="Landing" component={LandingScreen} />
      <AuthStack.Screen name="Login" component={LoginScreen} />
      <AuthStack.Screen name="Signup" component={SignupScreen} />
    </AuthStack.Navigator>
  );
});

const MainNavigator = React.memo(() => {
  return (
    <MainStack.Navigator
      id={null}
      screenOptions={{
        headerShown: false,
        contentStyle: { backgroundColor: '#fff' }
      }}
    >
      <MainStack.Screen name="Home" component={HomeScreen} />
      <MainStack.Screen name="AddRound" component={AddRoundScreen} />
      <MainStack.Screen name="AllRounds" component={AllRoundsScreen} />
      <MainStack.Screen name="AddCourse" component={AddCourseScreen} />
      <MainStack.Screen name="Statistics" component={StatisticsScreen} />
      <MainStack.Screen name="Goals" component={GoalsScreen} />
    </MainStack.Navigator>
  );
});

const Navigation = React.memo(() => {
  const { user, loading } = useAuthContext();

  const navigator = useMemo(() => {
    if (loading) return null;
    return user ? <MainNavigator /> : <AuthNavigator />;
  }, [user, loading]);
  
  return (
    <NavigationContainer>
      {navigator}
    </NavigationContainer>
  );
});

export default function App() {
  return (
    <SafeAreaProvider>
      <AuthProvider>
        <CoursesProvider>
          <GoalsProvider>
            <StatusBar style="auto" />
            <Navigation />
          </GoalsProvider>
        </CoursesProvider>
      </AuthProvider>
    </SafeAreaProvider>
  );
}</document_content>
</document>
<document index="3">
<source>golf-tracker/src/types/navigation.ts</source>
<document_content>
// src/types/navigation.ts
export type AuthStackParamList = {
  Landing: undefined;
  Login: undefined;
  Signup: undefined;
};

export type MainStackParamList = {
  Home: undefined;
  AddRound: undefined;
  AddCourse: undefined;
  AllRounds: undefined;
};</document_content>
</document>
<document index="4">
<source>golf-tracker/src/config/navigation.ts</source>
<document_content>
// src/config/navigation.ts
import { NavigatorScreenParams } from '@react-navigation/native';

// Auth Stack
export type AuthStackParamList = {
  Landing: undefined;
  Login: undefined;
  Signup: undefined;
};

// Main Stack
export type MainStackParamList = {
  Home: undefined;
  AddRound: undefined;
  AllRounds: undefined;
  CourseDetails: { courseId: string };
  AddCourse: undefined;
  Profile: undefined;
  Settings: undefined;
  Statistics: undefined;
  Goals: undefined;
};

// Root Stack
export type RootStackParamList = {
  Auth: NavigatorScreenParams<AuthStackParamList>;
  Main: NavigatorScreenParams<MainStackParamList>;
};

// Type helpers for useNavigation hook
declare global {
  namespace ReactNavigation {
    interface RootParamList extends RootStackParamList {}
  }
}</document_content>
</document>
<document index="5">
<source>golf-tracker/src/config/constants.ts</source>
<document_content>
// src/config/constants.ts
export const API_URL = process.env.EXPO_PUBLIC_API_URL || 'http://192.168.1.80:3000/api';

// Animation durations
export const ANIMATION = {
  DURATION: {
    FAST: 200,
    NORMAL: 300,
    SLOW: 500
  }
};

// Form validation limits
export const VALIDATION = {
  PASSWORD_MIN_LENGTH: 8,
  NAME_MAX_LENGTH: 50,
  EMAIL_MAX_LENGTH: 100,
  NOTES_MAX_LENGTH: 500
};

// Storage keys
export const STORAGE = {
  AUTH_TOKEN: 'auth_token',
  USER_DATA: 'user_data',
  SETTINGS: 'user_settings',
  RECENT_COURSES: 'recent_courses'
} as const;

// Limits and thresholds
export const LIMITS = {
  MAX_RECENT_COURSES: 5,
  MAX_ROUNDS_PER_PAGE: 20,
  MAX_SEARCH_RESULTS: 50,
  MIN_SEARCH_CHARS: 2
};

// Date formats
export const DATE_FORMATS = {
  DISPLAY: 'MMM D, YYYY',
  API: 'YYYY-MM-DD',
  MONTH_YEAR: 'MMMM YYYY'
};

// Golf specific constants
export const GOLF = {
  MAX_HOLE_SCORE: 15,
  MIN_COURSE_RATING: 55,
  MAX_COURSE_RATING: 155,
  MAX_FAIRWAYS: 18,
  MAX_GREENS: 18,
  MAX_PUTTS_PER_HOLE: 6,
  HANDICAP_ROUNDS_REQUIRED: 3
};

// Error messages
export const ERROR_MESSAGES = {
  NETWORK: 'Please check your internet connection and try again.',
  SERVER: 'Something went wrong on our end. Please try again later.',
  AUTH: {
    INVALID_CREDENTIALS: 'Invalid email or password',
    EMAIL_IN_USE: 'This email is already registered',
    WEAK_PASSWORD: 'Password must be at least 8 characters and include uppercase, lowercase, and numbers'
  },
  VALIDATION: {
    REQUIRED: 'This field is required',
    INVALID_EMAIL: 'Please enter a valid email address',
    PASSWORD_MISMATCH: 'Passwords do not match',
    INVALID_SCORE: 'Please enter a valid score'
  }
};

// App info
export const APP_INFO = {
  NAME: 'HandiMan',
  VERSION: '1.0.0',
  DESCRIPTION: 'Your personal golf handicap tracker',
  SUPPORT_EMAIL: 'support@handiman.app',
  PRIVACY_POLICY_URL: 'https://handiman.app/privacy',
  TERMS_URL: 'https://handiman.app/terms'
};</document_content>
</document>
<document index="6">
<source>golf-tracker/src/config/theme.ts</source>
<document_content>
// src/config/theme.ts
import { Platform } from 'react-native';

export const colors = {
  // Primary colors
  primary: '#2f95dc',
  primaryLight: '#5fb4e8',
  primaryDark: '#1c7ab8',

  // Secondary colors
  secondary: '#32cd32',
  secondaryLight: '#66d966',
  secondaryDark: '#28a428',

  // Neutral colors
  background: '#ffffff',
  surface: '#f5f5f5',
  text: '#333333',
  textSecondary: '#666666',
  border: '#dddddd',

  // State colors
  success: '#28a745',
  error: '#dc3545',
  warning: '#ffc107',
  info: '#17a2b8',

  // Specific UI colors
  divider: '#eeeeee',
  placeholder: '#999999',
  disabled: '#cccccc',
  overlay: 'rgba(0, 0, 0, 0.5)'
};

export const spacing = {
  xs: 4,
  sm: 8,
  md: 16,
  lg: 24,
  xl: 32,
  xxl: 48
};

export const typography = {
  sizes: {
    xs: 12,
    sm: 14,
    md: 16,
    lg: 20,
    xl: 24,
    xxl: 32
  },
  weights: {
    regular: '400',
    medium: '500',
    semibold: '600',
    bold: '700'
  },
  families: {
    regular: Platform.select({ ios: 'System', android: 'Roboto' }),
    medium: Platform.select({ ios: 'System', android: 'Roboto' }),
    bold: Platform.select({ ios: 'System', android: 'Roboto' }),
  }
};

export const borderRadius = {
  sm: 4,
  md: 8,
  lg: 12,
  xl: 16,
  round: 9999
};

export const shadows = {
  sm: Platform.select({
    ios: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 1 },
      shadowOpacity: 0.18,
      shadowRadius: 1.0
    },
    android: {
      elevation: 1
    }
  }),
  md: Platform.select({
    ios: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.22,
      shadowRadius: 2.22
    },
    android: {
      elevation: 3
    }
  }),
  lg: Platform.select({
    ios: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: 0.25,
      shadowRadius: 3.84
    },
    android: {
      elevation: 5
    }
  })
};

// Common style mixins
export const mixins = {
  row: {
    flexDirection: 'row' as const,
    alignItems: 'center' as const
  },
  center: {
    justifyContent: 'center' as const,
    alignItems: 'center' as const
  },
  shadow: shadows.md,
  card: {
    backgroundColor: colors.background,
    borderRadius: borderRadius.md,
    padding: spacing.md,
    ...shadows.md
  }
};</document_content>
</document>
<document index="7">
<source>golf-tracker/src/utils/validation.ts</source>
<document_content>
// src/utils/validation.ts
type ValidationRule<T> = {
    validate: (value: any, formValues: T) => boolean;
    message: string;
  };
  
  export const required = <T extends Record<string, any>>(message = 'This field is required'): ValidationRule<T> => ({
    validate: (value: any) => {
      if (typeof value === 'string') return value.trim().length > 0;
      if (typeof value === 'number') return true;
      if (Array.isArray(value)) return value.length > 0;
      return value !== null && value !== undefined;
    },
    message
  });
  
  export const email = <T extends Record<string, any>>(message = 'Please enter a valid email'): ValidationRule<T> => ({
    validate: (value: any) => {
      if (typeof value !== 'string') return false;
      return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value);
    },
    message
  });
  
  export const minLength = <T extends Record<string, any>>(
    length: number,
    message = `Must be at least ${length} characters`
  ): ValidationRule<T> => ({
    validate: (value: any) => {
      if (typeof value !== 'string') return false;
      return value.length >= length;
    },
    message
  });
  
  export const matches = <T extends Record<string, any>>(
    pattern: RegExp,
    message: string
  ): ValidationRule<T> => ({
    validate: (value: any) => {
      if (typeof value !== 'string') return false;
      return pattern.test(value);
    },
    message
  });
  
  export const matchesField = <T extends Record<string, any>>(
    fieldToMatch: keyof T,
    message: string
  ): ValidationRule<T> => ({
    validate: (value: any, formValues: T) => value === formValues[fieldToMatch],
    message
  });</document_content>
</document>
<document index="8">
<source>golf-tracker/src/utils/date.ts</source>
<document_content>
</document_content>
</document>
<document index="9">
<source>golf-tracker/src/utils/handicap.ts</source>
<document_content>
import { Round } from "shared";

export const calculateHandicap = (rounds: Round[]) => {
  if (rounds.length < 3) return 0;

  // Get the last 20 rounds
  const recentRounds = [...rounds]
    .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
    .slice(0, 20);
  // Extract and sort differentials
  const difs = recentRounds
    .map((round) => round.differential)
    .sort((a, b) => a - b);

  // Calculate handicap based on number of rounds
  switch (difs.length) {
    case 3:
      return Math.round((difs[0] - 2) * 10) / 10;
    case 4:
      return Math.round((difs[0] - 1) * 10) / 10;
    case 5:
      return Math.round(difs[0] * 10) / 10;
    case 6:
      return Math.round(((difs[0] + difs[1]) / 2 - 1) * 10) / 10;
    case 7:
    case 8:
      return Math.round(((difs[0] + difs[1]) / 2) * 10) / 10;
    case 9:
    case 10:
    case 11:
      return Math.round(((difs[0] + difs[1] + difs[2]) / 3) * 10) / 10;
    case 12:
    case 13:
    case 14:
      return (
        Math.round((difs.slice(0, 4).reduce((a, b) => a + b, 0) / 4) * 10) / 10
      );
    case 15:
    case 16:
      return (
        Math.round((difs.slice(0, 5).reduce((a, b) => a + b, 0) / 5) * 10) / 10
      );
    case 17:
    case 18:
      return (
        Math.round((difs.slice(0, 6).reduce((a, b) => a + b, 0) / 6) * 10) / 10
      );
    case 19:
      return (
        Math.round((difs.slice(0, 7).reduce((a, b) => a + b, 0) / 7) * 10) / 10
      );
    case 20:
      return (
        Math.round((difs.slice(0, 8).reduce((a, b) => a + b, 0) / 8) * 10) / 10
      );
    default:
      return 0;
  }
};</document_content>
</document>
<document index="10">
<source>golf-tracker/src/screens/Statistics/index.tsx</source>
<document_content>
// src/screens/Statistics/index.tsx
import React, { useCallback, useState, useMemo } from 'react';
import {
  View,
  Text,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  Dimensions,
  FlatList,
  Platform
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useFocusEffect } from '@react-navigation/native';
import { NativeStackScreenProps } from '@react-navigation/native-stack';
import { MainStackParamList } from '../../config/navigation';
import { useRounds } from '../../hooks/useRounds';
import { Round } from 'shared';
import { BackButton } from '../../components/common/BackButton';
import { 
  ArrowDownAZ, 
  Calendar, 
  Flag, 
  Target, 
  BarChart as BarChartIcon,
  ArrowUp, 
  ArrowDown,
  CalendarClock,
  Clock,
  Circle
} from 'lucide-react-native';
import {
  LineChart
} from 'react-native-chart-kit';
import { styles } from './styles';

type Props = NativeStackScreenProps<MainStackParamList, 'Statistics'>;

// Size for charts
const screenWidth = Dimensions.get('window').width - 50; // Account for padding

// Statistic type
type StatType = 'score' | 'differential' | 'fairways' | 'greens' | 'putts';

// View type
type ViewType = 'byRound' | 'byDate';

// Time range for date view
type TimeRange = '1m' | '3m' | '1y' | 'all';

// Round range for round view
type RoundRange = '20' | '50' | '100' | 'all';

// Get color for the tee
function getTeeColor(teeName: string): string {
  const teeColorMap: Record<string, string> = {
    'black': '#000000',
    'blue': '#0066CC',
    'white': '#FFFFFF',
    'red': '#CC0000',
    'gold': '#FFD700',
    'green': '#006400',
    'yellow': '#FFFF00',
    'silver': '#C0C0C0',
    'copper': '#B87333',
    'championship': '#000000',
    'tournament': '#000000',
    'member': '#0066CC',
    'senior': '#CC0000',
    'ladies': '#CC0000',
    'forward': '#CC0000',
    'middle': '#FFFFFF'
  };

  const lowercaseTee = teeName.toLowerCase();
  return teeColorMap[lowercaseTee] || '#AAAAAA'; // Default to gray if not found
}

// Select rounds based on time range
function filterRoundsByTimeRange(rounds: Round[], timeRange: TimeRange): Round[] {
  const now = new Date();
  let cutoffDate = new Date();
  
  switch (timeRange) {
    case '1m':
      cutoffDate.setMonth(now.getMonth() - 1);
      break;
    case '3m':
      cutoffDate.setMonth(now.getMonth() - 3);
      break;
    case '1y':
      cutoffDate.setFullYear(now.getFullYear() - 1);
      break;
    case 'all':
      return rounds;
  }
  
  return rounds.filter(round => new Date(round.date) >= cutoffDate);
}

// Select rounds based on round range
function filterRoundsByCount(rounds: Round[], roundRange: RoundRange): Round[] {
  const sortedRounds = [...rounds].sort(
    (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()
  );
  
  switch (roundRange) {
    case '20':
      return sortedRounds.slice(0, 20).reverse();
    case '50':
      return sortedRounds.slice(0, 50).reverse();
    case '100':
      return sortedRounds.slice(0, 100).reverse();
    case 'all':
      return sortedRounds.reverse();
  }
}

// Get stat value from a round
function getStatValue(round: Round, statType: StatType): number {
  switch (statType) {
    case 'score':
      return round.score;
    case 'differential':
      return round.differential;
    case 'fairways':
      return round.fairways;
    case 'greens':
      return round.greens;
    case 'putts':
      return round.putts;
    default:
      return 0;
  }
}

// Format date for display
function formatDate(date: Date): string {
  // Format as MM/DD (e.g., 4/15)
  return `${date.getMonth() + 1}/${date.getDate()}`;
}

// Format date for detailed display
function formatFullDate(date: Date): string {
  // Keep month and day but leave out month name
  return `${date.getMonth() + 1}/${date.getDate()}`;
}

// Process rounds data for the chart
// Calculate linear regression (line of best fit)
function calculateRegression(data: number[]): { slope: number; intercept: number } {
  if (data.length < 2) return { slope: 0, intercept: 0 };
  
  const n = data.length;
  let sumX = 0;
  let sumY = 0;
  let sumXY = 0;
  let sumXX = 0;
  
  for (let i = 0; i < n; i++) {
    sumX += i;
    sumY += data[i];
    sumXY += i * data[i];
    sumXX += i * i;
  }
  
  const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
  const intercept = (sumY - slope * sumX) / n;
  
  return { slope, intercept };
}

function generateRegressionLine(data: number[]): number[] {
  if (data.length < 2) return [];
  
  const { slope, intercept } = calculateRegression(data);
  const result = [];
  
  for (let i = 0; i < data.length; i++) {
    result.push(slope * i + intercept);
  }
  
  return result;
}

function processChartData(rounds: Round[], statType: StatType, viewType: ViewType) {
  if (rounds.length === 0) {
    return {
      chartData: {
        labels: [],
        datasets: [{
          data: [],
          color: () => '#2f95dc',
          strokeWidth: 2
        }]
      },
      keyLabels: [],
      trend: {
        value: 0,
        isPositive: false
      },
      colors: [],
      tees: [],
      regressionLine: []
    };
  }
  
  // Get key rounds (best scores, top fairways/greens hits)
  const statValues = rounds.map(round => ({
    round,
    value: getStatValue(round, statType)
  }));
  
  // Sort by value (ascending for score/differential/putts, descending for fairways/greens)
  const isHigherBetter = statType === 'fairways' || statType === 'greens';
  const sortedByValue = [...statValues].sort((a, b) => 
    isHigherBetter ? b.value - a.value : a.value - b.value
  );
  
  // Get top 3 rounds
  const keyRounds = new Set(sortedByValue.slice(0, 3).map(item => item.round._id));
  
  // Prepare data
  let labels: string[] = [];
  let data: number[] = [];
  let colors: string[] = [];
  let keyLabels: { 
    value: number; 
    index: number; 
    label: string;
    course: string;
    date: Date;
    teeColor: string;
  }[] = [];
  
  rounds.forEach((round, index) => {
    const value = getStatValue(round, statType);
    data.push(value);
    
    // Create label based on view type
    if (viewType === 'byDate') {
      labels.push(formatDate(new Date(round.date)));
    } else {
      // For round view, still show dates
      labels.push(formatDate(new Date(round.date)));
    }
    
    // Mark key rounds
    const isKey = keyRounds.has(round._id);
    const color = isKey 
      ? (isHigherBetter ? '#28a745' : '#dc3545')
      : '#2f95dc';
      
    colors.push(color);
    
    if (isKey) {
      const courseName = typeof round.course === 'object' ? round.course.name : 'Unknown';
      keyLabels.push({
        value,
        index,
        label: `${courseName} (${round.tees}): ${value}`,
        course: courseName,
        date: new Date(round.date),
        teeColor: getTeeColor(round.tees)
      });
    }
  });
  
  // For a sparse display, keep only every nth label if there are too many, but always keep key round labels
  let finalLabels = [...labels];
  if (labels.length > 5) {
    const step = Math.ceil(labels.length / 5); // Reduce number of labels for better readability
    // Keep key round indices to ensure they always have labels
    const keyIndices = keyLabels.map(item => item.index);
    finalLabels = labels.map((label, i) => {
      if (i % step === 0 || keyIndices.includes(i)) {
        // For key points, provide more detail
        if (keyIndices.includes(i)) {
          const keyItem = keyLabels.find(item => item.index === i);
          if (keyItem && viewType === 'byDate') {
            return formatDate(keyItem.date);
          }
        }
        return label;
      }
      return '';
    });
  }
  
  // Calculate trend
  const trend = data.length >= 2 ? data[data.length - 1] - data[0] : 0;
  const isPositiveTrend = (isHigherBetter && trend > 0) || (!isHigherBetter && trend < 0);
  
  // Generate regression line data
  const regressionLine = generateRegressionLine(data);
  
  return {
    chartData: {
      labels: finalLabels,
      datasets: [
        {
          data,
          // We'll handle the color at the chart config level
          strokeWidth: 2
        },
        // Add regression line dataset - always gray
        {
          data: regressionLine,
          color: (opacity = 1) => `rgba(128, 128, 128, ${opacity})`,
          strokeWidth: 2.5,
          strokeDashArray: [6, 3], // Dashed line
          withDots: false,
          withShadow: false
        }
      ]
    },
    keyLabels,
    trend: {
      value: Math.abs(trend),
      isPositive: isPositiveTrend
    },
    colors,
    tees: rounds.map(r => r.tees),
    regressionLine
  };
}

// Chart option buttons for time/round ranges
function RangeButtons({ 
  currentRange, 
  options, 
  onChange 
}: { 
  currentRange: string; 
  options: { label: string; value: string }[];
  onChange: (value: string) => void;
}) {
  return (
    <View style={styles.rangeContainer}>
      {options.map(option => (
        <TouchableOpacity
          key={option.value}
          style={[
            styles.rangeButton,
            currentRange === option.value && styles.rangeButtonActive
          ]}
          onPress={() => onChange(option.value)}
        >
          <Text
            style={[
              styles.rangeButtonText,
              currentRange === option.value && styles.rangeButtonTextActive
            ]}
          >
            {option.label}
          </Text>
        </TouchableOpacity>
      ))}
    </View>
  );
}

// Statistic selector
function StatSelector({
  stats,
  selectedStat,
  onSelect
}: {
  stats: { label: string; value: StatType; icon: React.ReactNode }[];
  selectedStat: StatType;
  onSelect: (stat: StatType) => void;
}) {
  return (
    <View style={styles.statSelectorContainer}>
      <FlatList
        horizontal
        data={stats}
        keyExtractor={item => item.value}
        showsHorizontalScrollIndicator={false}
        renderItem={({ item }) => (
          <TouchableOpacity
            style={[
              styles.statButton,
              selectedStat === item.value && styles.statButtonActive
            ]}
            onPress={() => onSelect(item.value)}
          >
            <View style={styles.statButtonIcon}>
              {item.icon}
            </View>
            <Text style={[
              styles.statButtonText,
              selectedStat === item.value && styles.statButtonTextActive
            ]}>
              {item.label}
            </Text>
          </TouchableOpacity>
        )}
        contentContainerStyle={styles.statList}
      />
    </View>
  );
}

export function StatisticsScreen({ navigation }: Props) {
  const { rounds, loading, error, getUserRounds } = useRounds();
  const [viewType, setViewType] = useState<ViewType>('byRound');
  const [selectedStat, setSelectedStat] = useState<StatType>('score');
  const [timeRange, setTimeRange] = useState<TimeRange>('3m');
  const [roundRange, setRoundRange] = useState<RoundRange>('20');
  const [activePointIndex, setActivePointIndex] = useState<number | null>(null);
  
  // Load rounds when the screen comes into focus
  useFocusEffect(
    useCallback(() => {
      console.log('Statistics screen in focus - loading rounds');
      getUserRounds();
    }, [getUserRounds])
  );

  // Toggle view type
  const toggleViewType = () => {
    setViewType(prev => prev === 'byRound' ? 'byDate' : 'byRound');
  };

  // Filter rounds based on selected range
  const filteredRounds = useMemo(() => {
    if (viewType === 'byDate') {
      return filterRoundsByTimeRange(rounds, timeRange);
    } else {
      return filterRoundsByCount(rounds, roundRange);
    }
  }, [rounds, viewType, timeRange, roundRange]);

  // Process chart data
  const { chartData, keyLabels, trend, colors, tees } = useMemo(() => {
    // Make sure rounds are chronologically sorted for evenly distributed dates
    const chronologicalRounds = [...filteredRounds].sort(
      (a, b) => new Date(a.date).getTime() - new Date(b.date).getTime()
    );
    const result = processChartData(chronologicalRounds, selectedStat, viewType);
    console.log("Chart data generated:", result);
    return result;
  }, [filteredRounds, selectedStat, viewType]);

  // Get domain information - Calculate min/max for better Y axis visualization
  const yAxisBounds = useMemo(() => {
    if (!chartData || !chartData.datasets || !chartData.datasets[0] || chartData.datasets[0].data.length === 0) {
      return { min: 0, max: 100 };
    }
    
    const data = chartData.datasets[0].data;
    const minY = Math.min(...data);
    const maxY = Math.max(...data);
    const range = maxY - minY;
    
    let adjustedMinY, adjustedMaxY;
    
    if (selectedStat === 'fairways' || selectedStat === 'greens') {
      // For fairways and greens, start at 0 and go up to next multiple of 5 above max
      adjustedMinY = 0;
      adjustedMaxY = Math.min(18, Math.ceil((maxY + 1) / 5) * 5);
    } else {
      // For score, differential, putts, add padding
      adjustedMinY = Math.max(0, Math.floor((minY - range * 0.1) / 5) * 5);
      adjustedMaxY = Math.ceil((maxY + range * 0.1) / 5) * 5;
    }
    
    return {
      min: adjustedMinY,
      max: adjustedMaxY
    };
  }, [chartData, selectedStat]);

  // Get chart config
  const chartConfig = useMemo(() => {
    // Determine if higher values are better for this stat
    const isHigherBetter = selectedStat === 'fairways' || selectedStat === 'greens';
    
    // Always get chronologically sorted rounds for consistent trend calculation
    const chronologicalRounds = [...filteredRounds].sort(
      (a, b) => new Date(a.date).getTime() - new Date(b.date).getTime()
    );
    
    // Calculate trend from oldest to newest round
    const trendData = chronologicalRounds.length >= 2 ? 
      getStatValue(chronologicalRounds[chronologicalRounds.length-1], selectedStat) - 
      getStatValue(chronologicalRounds[0], selectedStat) : 0;
    
    // Determine color based on trend and stat type
    let lineColor;
    
    // No change = gray
    if (trendData === 0 || chronologicalRounds.length < 2) {
      lineColor = '128, 128, 128'; // Gray
    } 
    // For score, differential, putts: green when decreasing, red when increasing
    else if (selectedStat === 'score' || selectedStat === 'differential' || selectedStat === 'putts') {
      lineColor = trendData < 0 
        ? '40, 167, 69'  // Green (good) - score decreasing
        : '220, 53, 69'; // Red (bad) - score increasing
    }
    // For fairways, greens: green when increasing, red when decreasing
    else {
      lineColor = trendData > 0
        ? '40, 167, 69'  // Green (good) - fairways/greens increasing
        : '220, 53, 69'; // Red (bad) - fairways/greens decreasing
    }
    
    return {
      backgroundGradientFrom: "#ffffff",
      backgroundGradientTo: "#ffffff",
      color: (opacity = 1) => `rgba(${lineColor}, ${opacity})`,
      strokeWidth: 2,
      decimalPlaces: 0,
      propsForDots: {
        r: "5",
        strokeWidth: "1",
        stroke: "#fff"
      },
      useShadowColorFromDataset: false,
      fillShadowGradient: lineColor.includes('128') ? '#808080' : 
                          lineColor.includes('40') ? '#28a745' : '#dc3545',
      fillShadowGradientOpacity: 0.1 // Light fill under the curve
    };
  }, [selectedStat, filteredRounds]);

  // Available stats with icons
  const stats = [
    { 
      label: 'Score', 
      value: 'score' as StatType,
      icon: <Target size={18} color="#2f95dc" />
    },
    { 
      label: 'Differential', 
      value: 'differential' as StatType,
      icon: <Clock size={18} color="#2f95dc" />
    },
    { 
      label: 'Fairways', 
      value: 'fairways' as StatType,
      icon: <ArrowUp size={18} color="#2f95dc" />
    },
    { 
      label: 'Greens', 
      value: 'greens' as StatType,
      icon: <Flag size={18} color="#2f95dc" />
    },
    { 
      label: 'Putts', 
      value: 'putts' as StatType,
      icon: <BarChartIcon size={18} color="#2f95dc" />
    }
  ];

  // Range options
  const timeRangeOptions = [
    { label: '1M', value: '1m' },
    { label: '3M', value: '3m' },
    { label: '1Y', value: '1y' },
    { label: 'All', value: 'all' }
  ];

  const roundRangeOptions = [
    { label: '20', value: '20' },
    { label: '50', value: '50' },
    { label: '100', value: '100' },
    { label: 'All', value: 'all' }
  ];

  // Chart title
  const getChartTitle = () => {
    switch (selectedStat) {
      case 'score': return 'Score Trend';
      case 'differential': return 'Handicap Differential';
      case 'fairways': return 'Fairways Hit';
      case 'greens': return 'Greens in Regulation';
      case 'putts': return 'Putts per Round';
    }
  };

  // Collect unique tee types
  const uniqueTees = useMemo(() => {
    return Array.from(new Set(tees));
  }, [tees]);

  if (loading) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#2f95dc" />
        </View>
      </SafeAreaView>
    );
  }

  if (error) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>{error}</Text>
          <TouchableOpacity 
            style={styles.retryButton}
            onPress={() => getUserRounds()}
          >
            <Text style={styles.retryButtonText}>Retry</Text>
          </TouchableOpacity>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <BackButton />
      <View style={styles.header}>
        <Text style={styles.title}>Statistics</Text>
        <TouchableOpacity style={styles.viewTypeButton} onPress={toggleViewType}>
          {viewType === 'byRound' ? (
            <ArrowDownAZ size={20} color="#2f95dc" />
          ) : (
            <Calendar size={20} color="#2f95dc" />
          )}
          <Text style={styles.viewTypeLabel}>
            {viewType === 'byRound' ? 'By Round' : 'By Date'}
          </Text>
        </TouchableOpacity>
      </View>

      {/* Stat selector */}
      <StatSelector
        stats={stats}
        selectedStat={selectedStat}
        onSelect={setSelectedStat}
      />

      {/* Range selector */}
      {viewType === 'byDate' ? (
        <RangeButtons
          currentRange={timeRange}
          options={timeRangeOptions}
          onChange={(value) => setTimeRange(value as TimeRange)}
        />
      ) : (
        <RangeButtons
          currentRange={roundRange}
          options={roundRangeOptions}
          onChange={(value) => setRoundRange(value as RoundRange)}
        />
      )}

      <ScrollView contentContainerStyle={styles.scrollContent}>
        {!chartData || !chartData.datasets || !chartData.datasets[0] || chartData.datasets[0].data.length === 0 ? (
          <View style={styles.noDataContainer}>
            <Text style={styles.noDataText}>
              No rounds available for the selected time range.
            </Text>
            <TouchableOpacity
              style={styles.addButton}
              onPress={() => navigation.navigate('AddRound')}
            >
              <Text style={styles.addButtonText}>Add Round</Text>
            </TouchableOpacity>
          </View>
        ) : (
          <View style={styles.chartContainer}>
            <View style={styles.chartHeader}>
              <Text style={styles.chartTitle}>{getChartTitle()}</Text>
              {trend.value > 0 && (
                <View style={styles.trendContainer}>
                  {/* For score, differential and putts, we want down arrows to be green (lower is better) */}
                  {(selectedStat === 'score' || selectedStat === 'differential' || selectedStat === 'putts') ? (
                    trend.isPositive ? (
                      <ArrowDown size={16} color="#28a745" />
                    ) : (
                      <ArrowUp size={16} color="#dc3545" />
                    )
                  ) : (
                    /* For fairways and greens, we want up arrows to be green (higher is better) */
                    trend.isPositive ? (
                      <ArrowUp size={16} color="#28a745" />
                    ) : (
                      <ArrowDown size={16} color="#dc3545" />
                    )
                  )}
                  <Text
                    style={[
                      styles.trendValue,
                      trend.isPositive ? styles.goodTrend : styles.badTrend
                    ]}
                  >
                    {trend.value.toFixed(1)}
                  </Text>
                </View>
              )}
            </View>
            
            <View style={styles.chart}>
              <LineChart
                data={chartData}
                width={screenWidth}
                height={240}
                chartConfig={{
                  ...chartConfig,
                  // Add additional styling but keep the color logic from chartConfig
                  propsForBackgroundLines: {
                    strokeDasharray: '',
                  },
                  propsForLabels: {
                    fontSize: 12,
                  },
                  // Configure y-axis labels to be horizontal
                  propsForVerticalLabels: {
                    rotation: 85,
                    fontSize: 11,
                    fill: 'black'
                  },
                  // Configure x-axis labels to be angled
                  propsForHorizontalLabels: {
                    rotation: 0,
                    fontSize: 10,
                    fill: 'black'
                  }
                }}
                bezier
                style={styles.chartStyle}
                fromZero={selectedStat === 'fairways' || selectedStat === 'greens'}
                yAxisSuffix=""
                yAxisLabel=""
                withInnerLines={true}
                withOuterLines={true}
                withHorizontalLabels={true}
                withVerticalLabels={true}
                withDots={true}
                segments={5}
                yAxisInterval={1}
                formatYLabel={(value) => value}
                formatXLabel={(label) => label}
                verticalLabelRotation={0}
                horizontalLabelRotation={75}
                withShadow={true}
                // Custom dot rendering
                renderDotContent={({ x, y, indexData, index }) => {
                  // Only show dots for the first dataset (main data)
                  if (index > 0) return null;
                  return null; // We handle this with our interactive layer
                }}
                fromNumber={yAxisBounds.max}
                // Chart padding config available as chart-specific props
              />
              
              {/* Interactive data points area */}
              <View 
                style={[styles.chartInteractionLayer, { width: screenWidth, height: 240 }]}
                onStartShouldSetResponder={() => true}
                onMoveShouldSetResponder={() => true}
                onResponderGrant={(evt) => {
                  const { locationX } = evt.nativeEvent;
                  const pointWidth = screenWidth / chartData.datasets[0].data.length;
                  const index = Math.floor(locationX / pointWidth);
                  if (index >= 0 && index < chartData.datasets[0].data.length) {
                    setActivePointIndex(index);
                  }
                }}
                onResponderMove={(evt) => {
                  const { locationX } = evt.nativeEvent;
                  const pointWidth = screenWidth / chartData.datasets[0].data.length;
                  const index = Math.min(
                    Math.max(0, Math.floor(locationX / pointWidth)),
                    chartData.datasets[0].data.length - 1
                  );
                  setActivePointIndex(index);
                }}
                onResponderRelease={() => {
                  setActivePointIndex(null);
                }}
              />
              
              {/* Active point tooltip */}
              {activePointIndex !== null && chartData.datasets[0].data[activePointIndex] !== undefined && (
                <View 
                  style={[
                    styles.activePointLabel,
                    {
                      left: (activePointIndex / (chartData.datasets[0].data.length - 1)) * (screenWidth - 40) + 35,
                      top: 240 - ((chartData.datasets[0].data[activePointIndex] - yAxisBounds.min) / (yAxisBounds.max - yAxisBounds.min)) * 200 - 40
                    }
                  ]}
                >
                  <Text style={styles.activePointValue}>
                    {chartData.datasets[0].data[activePointIndex]}
                  </Text>
                  
                  <View style={styles.activePointDetails}>
                    <View style={styles.activePointDetail}>
                      <CalendarClock size={12} color="#666" />
                      <Text style={styles.activePointText}>
                        {formatFullDate(new Date(filteredRounds[activePointIndex].date))}
                      </Text>
                    </View>
                    
                    <View style={styles.activePointDetail}>
                      <Flag size={12} color="#666" />
                      <Text style={styles.activePointText} numberOfLines={1} ellipsizeMode="tail">
                        {typeof filteredRounds[activePointIndex].course === 'object' 
                          ? filteredRounds[activePointIndex].course.name 
                          : 'Unknown course'}
                      </Text>
                    </View>
                    
                    <View style={styles.activePointDetail}>
                      <Circle size={12} color={getTeeColor(filteredRounds[activePointIndex].tees)} />
                      <Text style={styles.activePointText}>
                        {filteredRounds[activePointIndex].tees}
                      </Text>
                    </View>
                  </View>
                </View>
              )}
              
              {/* Chart details section */}
              <View style={styles.chartDetailsSection}>
                <Text style={styles.chartDetailsSectionTitle}>Chart Details</Text>
                <View style={styles.chartDetailsRow}>
                  <View style={styles.chartDetailItem}>
                    <Text style={styles.chartDetailLabel}>Rounds</Text>
                    <Text style={styles.chartDetailValue}>{filteredRounds.length}</Text>
                  </View>
                  <View style={styles.chartDetailItem}>
                    <Text style={styles.chartDetailLabel}>Average</Text>
                    <Text style={styles.chartDetailValue}>
                      {chartData.datasets[0].data.length > 0 
                        ? (chartData.datasets[0].data.reduce((a, b) => a + b, 0) / chartData.datasets[0].data.length).toFixed(1)
                        : "N/A"}
                    </Text>
                  </View>
                  <View style={styles.chartDetailItem}>
                    <Text style={styles.chartDetailLabel}>Best</Text>
                    <Text style={styles.chartDetailValue}>
                      {chartData.datasets[0].data.length > 0 
                        ? (selectedStat === 'fairways' || selectedStat === 'greens'
                            ? Math.max(...chartData.datasets[0].data)
                            : Math.min(...chartData.datasets[0].data))
                        : "N/A"}
                    </Text>
                  </View>
                </View>
                
                <View style={styles.chartDetailsRow}>
                  <View style={styles.chartDetailItem}>
                    <Text style={styles.chartDetailLabel}>Trend</Text>
                    <View style={styles.trendDetail}>
                      {trend.value > 0 && (
                        <View style={styles.trendIconContainer}>
                          {/* For score, differential and putts, we want down arrows to be green (lower is better) */}
                          {(selectedStat === 'score' || selectedStat === 'differential' || selectedStat === 'putts') ? (
                            trend.isPositive ? (
                              <ArrowDown size={14} color="#28a745" />
                            ) : (
                              <ArrowUp size={14} color="#dc3545" />
                            )
                          ) : (
                            /* For fairways and greens, we want up arrows to be green (higher is better) */
                            trend.isPositive ? (
                              <ArrowUp size={14} color="#28a745" />
                            ) : (
                              <ArrowDown size={14} color="#dc3545" />
                            )
                          )}
                        </View>
                      )}
                      <Text 
                        style={[
                          styles.chartDetailValue,
                          trend.value > 0 ? (trend.isPositive ? styles.goodTrend : styles.badTrend) : {}
                        ]}
                      >
                        {trend.value.toFixed(1)}
                      </Text>
                    </View>
                  </View>
                  
                  <View style={styles.chartDetailItem}>
                    <Text style={styles.chartDetailLabel}>Date Range</Text>
                    <Text style={styles.chartDetailValue}>
                      {filteredRounds.length > 0 
                        ? `${formatFullDate(new Date(filteredRounds[0].date))} - ${formatFullDate(new Date(filteredRounds[filteredRounds.length-1].date))}` 
                        : "N/A"}
                    </Text>
                  </View>
                </View>
              </View>
            </View>
          </View>
        )}
      </ScrollView>
    </SafeAreaView>
  );
}</document_content>
</document>
<document index="11">
<source>golf-tracker/src/screens/Statistics/styles.ts</source>
<document_content>
// src/screens/Statistics/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
  },
  viewTypeButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f0f0f0',
    padding: 8,
    borderRadius: 8,
    gap: 6,
    marginVertical: -20
  },
  viewTypeLabel: {
    fontSize: 14,
    color: '#2f95dc',
    fontWeight: '500',
  },
  scrollContent: {
    padding: 16,
    paddingBottom: 0,
  },
  chartContainer: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 0,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  chartHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
  },
  chartTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
  },
  trendContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
  },
  trendValue: {
    fontSize: 14,
    fontWeight: '500',
  },
  goodTrend: {
    color: '#28a745',
  },
  badTrend: {
    color: '#dc3545',
  },
  chart: {
    borderRadius: 8,
    position: 'relative',

  },
  chartStyle: {
    marginVertical: 8,
    borderRadius: 16,
    marginLeft: 0, // Adjusted margin
    paddingBottom: 10,
    paddingRight: 30,
    paddingLeft: 0
  },
  keyLabelsContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    pointerEvents: 'none',
  },
  // Interactive chart components
  chartInteractionLayer: {
    position: 'absolute',
    top: 0,
    left: 0,
    backgroundColor: 'transparent',
    zIndex: 10,
  },
  keyPointsContainer: {
    position: 'absolute',
    left: 0,
    right: 0,
    bottom: -40, // Position directly on the x-axis, adjusted for vertical labels
    height: 16, // Just tall enough for the key points
    pointerEvents: 'none',
    zIndex: 5,
  },
  keyPoint: {
    position: 'absolute',
    width: 16,
    height: 16,
    borderRadius: 8,
    borderWidth: 2,
    borderColor: '#fff',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
    elevation: 3,
    transform: [{ translateX: -8 }, { translateY: -4 }], // Center the dot horizontally and position at x-axis
  },
  activePointLabel: {
    position: 'absolute',
    backgroundColor: 'rgba(255, 255, 255, 0.95)',
    borderRadius: 12,
    paddingHorizontal: 12,
    paddingVertical: 8,
    minWidth: 130,
    maxWidth: 180,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 5,
    borderWidth: 1,
    borderColor: 'rgba(200, 200, 200, 0.7)',
    transform: [{ translateX: -65 }], // Center the label
    zIndex: 20,
  },
  activePointValue: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    textAlign: 'center',
    marginBottom: 4,
  },
  activePointDetails: {
    width: '100%',
    paddingTop: 4,
    borderTopWidth: 1,
    borderTopColor: 'rgba(200, 200, 200, 0.5)',
  },
  activePointDetail: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 2,
  },
  activePointText: {
    fontSize: 12,
    marginLeft: 8,
    color: '#666',
    flex: 1,
  },
  
  // Chart details section
  chartDetailsSection: {
    marginTop: 16,
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  chartDetailsSectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 12,
  },
  chartDetailsRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 16,
  },
  chartDetailItem: {
    flex: 1,
  },
  chartDetailLabel: {
    fontSize: 12,
    color: '#666',
    marginBottom: 4,
  },
  chartDetailValue: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
  },
  trendDetail: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  trendIconContainer: {
    marginRight: 4,
  },
  statSelectorContainer: {
    paddingHorizontal: 16,
    marginBottom: 16,
  },
  statList: {
    paddingVertical: 4,
  },
  statButton: {
    backgroundColor: '#fff',
    borderRadius: 8,
    paddingHorizontal: 16,
    paddingVertical: 8,
    marginRight: 8,
    flexDirection: 'row',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  statButtonActive: {
    backgroundColor: '#2f95dc',
  },
  statButtonIcon: {
    marginRight: 8,
  },
  statButtonText: {
    fontSize: 14,
    color: '#333',
    fontWeight: '500',
  },
  statButtonTextActive: {
    color: '#fff',
  },
  rangeContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
  },
  rangeButton: {
    backgroundColor: '#fff',
    borderRadius: 8,
    paddingHorizontal: 12,
    paddingVertical: 6,
    minWidth: 60,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  rangeButtonActive: {
    backgroundColor: '#2f95dc',
  },
  rangeButtonText: {
    fontSize: 14,
    color: '#333',
    fontWeight: '500',
  },
  rangeButtonTextActive: {
    color: '#fff',
  },
  teeColorLegend: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'flex-start',
    marginTop: 8,
    gap: 8,
  },
  teeColorItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f0f0f0',
    paddingVertical: 4,
    paddingHorizontal: 8,
    borderRadius: 16,
  },
  teeColorDot: {
    width: 12,
    height: 12,
    borderRadius: 6,
    marginRight: 6,
    borderWidth: 1,
    borderColor: '#ddd',
  },
  teeColorText: {
    fontSize: 12,
    color: '#666',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  errorText: {
    color: '#dc3545',
    fontSize: 16,
    textAlign: 'center',
    marginBottom: 16,
  },
  retryButton: {
    backgroundColor: '#2f95dc',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 8,
  },
  retryButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  noDataContainer: {
    padding: 32,
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#fff',
    borderRadius: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  noDataText: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginBottom: 16,
  },
  addButton: {
    backgroundColor: '#2f95dc',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 8,
  },
  addButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
});</document_content>
</document>
<document index="12">
<source>golf-tracker/src/screens/Home/index.tsx</source>
<document_content>
// src/screens/Home/index.tsx
import React, { useCallback, useState } from 'react';
import {
  View,
  Text,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  Modal
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useFocusEffect } from '@react-navigation/native';
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import { MainStackParamList } from '../../config/navigation';
import { useAuth } from '../../hooks/useAuth';
import { useRounds } from '../../hooks/useRounds';
import { Round } from 'shared';
import { LogOut, Target, Trophy, CirclePlus, PieChart, Info } from 'lucide-react-native';
import { styles } from './styles';
import { calculateHandicap } from '../../utils/handicap';

type Props = NativeStackScreenProps<MainStackParamList, 'Home'>;

function HandicapCard({ handicap, rounds, onViewDetails }: { 
  handicap: number; 
  rounds: Round[]; 
  onViewDetails: () => void;
}) {
  return (
    <View style={styles.card}>
      <Text style={styles.cardTitle}>Current Handicap</Text>
      <View style={styles.handicapContainer}>
        <Text style={styles.handicapText}>{handicap.toFixed(1)}</Text>
      </View>
      <Text style={styles.handicapSubtext}>
        Based on {Math.min(rounds.length, 20)} rounds
      </Text>
      <TouchableOpacity style={styles.actionButton} onPress={onViewDetails}>
        <Info size={16} color="#2f95dc" style={{marginRight: 6}} />
        <Text style={styles.actionButtonText}>View Details</Text>
      </TouchableOpacity>
    </View>
  );
}

function QuickActions({ onAddRound, onViewStats, onViewGoals }: { 
  onAddRound: () => void;
  onViewStats: () => void;
  onViewGoals: () => void;
}) {
  return (
    <View style={styles.quickActions}>
      <TouchableOpacity style={styles.quickActionButton} onPress={onAddRound}>
        <CirclePlus size={24} color="#2f95dc" />
        <Text style={styles.quickActionText}>New Round</Text>
      </TouchableOpacity>
      <TouchableOpacity 
        style={styles.quickActionButton}
        onPress={onViewStats}
      >
        <PieChart size={24} color="#2f95dc" />
        <Text style={styles.quickActionText}>Statistics</Text>
      </TouchableOpacity>
      <TouchableOpacity style={styles.quickActionButton} onPress={onViewGoals}>
        <Trophy size={24} color="#2f95dc" />
        <Text style={styles.quickActionText}>Goals</Text>
      </TouchableOpacity>
    </View>
  );
}

function RecentRounds({ 
  rounds,
  onViewAll
}: { 
  rounds: Round[],
  onViewAll: () => void
}) {
  const recentScores = rounds.slice(0, 5);

  return (
    <View style={styles.card}>
      <Text style={styles.cardTitle}>Recent Scores</Text>
      {rounds.length === 0 ? (
        <Text style={styles.noRoundsText}>
          Add rounds to begin tracking your stats!
        </Text>
      ) : (
        <View style={styles.recentScores}>
          {recentScores.map((round, index) => (
            <View key={round._id} style={styles.scoreItem}>
              <Text style={styles.scoreText}>{round.score}</Text>
              <Text style={styles.scoreDate}>
                {new Date(round.date).toLocaleDateString()}
              </Text>
            </View>
          ))}
        </View>
      )}
      <TouchableOpacity
        style={[styles.actionButton, rounds.length === 0 && styles.disabledButton]}
        disabled={rounds.length === 0}
        onPress={onViewAll}
      >
        <Text style={styles.actionButtonText}>View All Rounds</Text>
      </TouchableOpacity>
    </View>
  );
}

function TipCard() {
  return (
    <View style={styles.card}>
      <Text style={styles.cardTitle}>Today's Tip</Text>
      <Text style={styles.tipText}>
        "Focus on your tempo during practice swings. A consistent tempo leads to more consistent shots."
      </Text>
    </View>
  );
}

export function HomeScreen({ navigation }: Props) {
  const { user, logout } = useAuth();
  const { rounds, loading, error, getUserRounds } = useRounds();
  const [showHandicapDetails, setShowHandicapDetails] = useState(false);

  useFocusEffect(
    useCallback(() => {
      if (user) {
        getUserRounds();
      }
    }, [user, getUserRounds])
  );

  const handleLogout = async () => {
    try {
      await logout();
    } catch (error) {
      Alert.alert('Error', 'Failed to log out. Please try again.');
    }
  };

  // Calculate handicap from rounds
  const handicap = calculateHandicap(rounds);

  // Calculate which differentials are used for handicap
  const getHandicapDifferentials = useCallback(() => {
    if (rounds.length < 3) return { usedDifferentials: [], allDifferentials: [] };
    
    // Get the last 20 rounds and their differentials
    const recentRounds = [...rounds]
      .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
      .slice(0, 20);
    
    // Sort differentials for calculation
    const sortedDifferentials = [...recentRounds]
      .sort((a, b) => a.differential - b.differential);
    
    // Determine how many differentials are used based on total rounds
    let usedCount = 0;
    if (sortedDifferentials.length <= 4) {
      usedCount = 1;
    } else if (sortedDifferentials.length <= 6) {
      usedCount = 2;
    } else if (sortedDifferentials.length <= 8) {
      usedCount = 2;
    } else if (sortedDifferentials.length <= 11) {
      usedCount = 3;
    } else if (sortedDifferentials.length <= 14) {
      usedCount = 4;
    } else if (sortedDifferentials.length <= 16) {
      usedCount = 5;
    } else if (sortedDifferentials.length <= 18) {
      usedCount = 6;
    } else if (sortedDifferentials.length === 19) {
      usedCount = 7;
    } else if (sortedDifferentials.length === 20) {
      usedCount = 8;
    }
    
    // Get the differentials used in calculation
    const usedDifferentials = sortedDifferentials.slice(0, usedCount);
    
    return {
      usedDifferentials,
      allDifferentials: recentRounds
    };
  }, [rounds]);

  const renderHandicapDetailsModal = () => (
    <Modal
      visible={showHandicapDetails}
      transparent={true}
      animationType="fade"
      onRequestClose={() => setShowHandicapDetails(false)}
    >
      <View style={styles.modalOverlay}>
        <View style={styles.modalContent}>
          <View style={styles.modalHeader}>
            <Text style={styles.modalTitle}>Handicap Details</Text>
            <TouchableOpacity 
              style={styles.closeButton} 
              onPress={() => setShowHandicapDetails(false)}
            >
              <Text style={{ color: '#2f95dc', fontSize: 16 }}>Close</Text>
            </TouchableOpacity>
          </View>
          
          <ScrollView>
            <View style={styles.handicapExplanation}>
              <Text style={styles.explanationText}>
                Your handicap index is {handicap.toFixed(1)}, calculated using the 
                lowest {getHandicapDifferentials().usedDifferentials.length} differentials 
                from your last {Math.min(rounds.length, 20)} rounds.
              </Text>
              <Text style={styles.explanationText}>
                A differential is calculated as: (Score - Course Rating) × 113 ÷ Slope Rating
              </Text>
              <Text style={styles.explanationText}>
                The highlighted differentials below are used in your handicap calculation.
              </Text>
            </View>
            
            <View style={styles.differentialsList}>
              {getHandicapDifferentials().allDifferentials.map((round, index) => {
                const isUsed = getHandicapDifferentials().usedDifferentials.some(r => r._id === round._id);
                return (
                  <View key={round._id} style={styles.differentialItem}>
                    <Text style={[
                      styles.courseText,
                      isUsed ? styles.usedDifferential : styles.unusedDifferential
                    ]}>
                      {typeof round.course === 'object' ? round.course.name : 'Unknown Course'}
                    </Text>
                    <Text style={[
                      styles.differentialText,
                      isUsed ? styles.usedDifferential : styles.unusedDifferential
                    ]}>
                      {round.differential.toFixed(1)}
                    </Text>
                    <Text style={styles.dateText}>
                      {new Date(round.date).toLocaleDateString()}
                    </Text>
                  </View>
                );
              })}
            </View>
          </ScrollView>
        </View>
      </View>
    </Modal>
  );

  if (loading) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#2f95dc" />
        </View>
      </SafeAreaView>
    );
  }

  if (error) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>{error}</Text>
          <TouchableOpacity 
            style={styles.retryButton}
            onPress={() => getUserRounds()}
          >
            <Text style={styles.retryButtonText}>Retry</Text>
          </TouchableOpacity>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      {renderHandicapDetailsModal()}
      <ScrollView contentContainerStyle={styles.scrollContent}>
        {/* Header Section */}
        <View style={styles.header}>
          <View style={styles.welcomeContainer}>
            <Text style={styles.welcomeText}>Welcome back, </Text>
            <Text style={styles.nameText}>{user?.name?.split(' ')[0] || 'Golfer'}</Text>
          </View>
          <TouchableOpacity 
            style={styles.logoutButton} 
            onPress={handleLogout}
          >
            <LogOut size={20} color="#2f95dc" />
          </TouchableOpacity>
        </View>

        {/* Handicap Card */}
        <HandicapCard 
          handicap={handicap} 
          rounds={rounds} 
          onViewDetails={() => setShowHandicapDetails(true)} 
        />

        {/* Quick Actions */}
        <QuickActions 
          onAddRound={() => navigation.navigate('AddRound')} 
          onViewStats={() => navigation.navigate('Statistics')}
          onViewGoals={() => navigation.navigate('Goals')}
        />

        {/* Recent Rounds */}
        <RecentRounds
          rounds={rounds}
          onViewAll={() => navigation.navigate('AllRounds')}
        />

        {/* Tip Card */}
        <TipCard />
      </ScrollView>
    </SafeAreaView>
  );
}</document_content>
</document>
<document index="13">
<source>golf-tracker/src/screens/Home/styles.ts</source>
<document_content>
// src/screens/Home/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollContent: {
    padding: 16,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  errorText: {
    color: '#dc3545',
    fontSize: 16,
    textAlign: 'center',
    marginBottom: 16,
  },
  retryButton: {
    backgroundColor: '#2f95dc',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 8,
  },
  retryButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  welcomeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  welcomeText: {
    fontSize: 20,
    color: '#666',
  },
  nameText: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
  },
  logoutButton: {
    padding: 8,
  },
  card: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  cardTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
    marginBottom: 12,
  },
  handicapContainer: {
    flexDirection: 'row',
    alignItems: 'baseline',
    justifyContent: 'center',
  },
  handicapText: {
    fontSize: 48,
    fontWeight: 'bold',
    color: '#2f95dc',
    textAlign: 'center',
    marginVertical: 8,
  },
  handicapLabel: {
    fontSize: 16,
    color: '#666',
    marginLeft: 8,
    fontWeight: '500',
  },
  handicapSubtext: {
    textAlign: 'center',
    color: '#888',
    fontSize: 14,
    marginBottom: 8,
  },
  quickActions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 16,
  },
  quickActionButton: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    alignItems: 'center',
    width: '31%',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  quickActionText: {
    fontSize: 14,
    color: '#333',
    marginTop: 8,
    textAlign: 'center',
  },
  recentScores: {
    marginBottom: 12,
  },
  scoreItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  scoreText: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
  },
  scoreDate: {
    fontSize: 14,
    color: '#666',
  },
  actionButton: {
    backgroundColor: '#2f95dc',
    borderRadius: 8,
    padding: 12,
    alignItems: 'center',
    marginTop: 8,
    flexDirection: 'row',
    justifyContent: 'center',
  },
  actionButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  
  // Modal styles for handicap details
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  modalContent: {
    backgroundColor: 'white',
    borderRadius: 12,
    padding: 20,
    width: '100%',
    maxHeight: '80%',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
  },
  closeButton: {
    padding: 8,
  },
  handicapExplanation: {
    marginBottom: 16,
  },
  explanationText: {
    fontSize: 14,
    color: '#444',
    lineHeight: 20,
    marginBottom: 10,
  },
  differentialsList: {
    marginVertical: 12,
  },
  differentialItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  usedDifferential: {
    fontWeight: 'bold',
    color: '#2f95dc',
  },
  unusedDifferential: {
    color: '#666',
  },
  courseText: {
    flex: 1,
    fontSize: 14,
  },
  differentialText: {
    fontSize: 14,
    width: 50,
    textAlign: 'right',
  },
  dateText: {
    fontSize: 12,
    color: '#888',
    width: 80,
    textAlign: 'right',
  },
  noRoundsText: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginVertical: 16,
  },
  disabledButton: {
    backgroundColor: '#ccc',
  },
  tipText: {
    fontSize: 16,
    color: '#666',
    fontStyle: 'italic',
    lineHeight: 24,
  },
});</document_content>
</document>
<document index="14">
<source>golf-tracker/src/screens/course/AddCourse/index.tsx</source>
<document_content>
// src/screens/course/AddCourse/index.tsx
import React, { useState } from 'react';
import { View, Alert } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { NativeStackScreenProps } from '@react-navigation/native-stack';
import { MainStackParamList } from '../../../config/navigation';
import { FormInput } from '../../../components/forms/FormInput';
import { FormButton } from '../../../components/forms/FormButton';
import { BackButton } from '../../../components/common/BackButton';
import { useCourses } from '../../../hooks/useCourses';
import { useAuth } from '../../../hooks/useAuth';
import { styles } from './styles';

type Props = NativeStackScreenProps<MainStackParamList, 'AddCourse'>;

export function AddCourseScreen({ navigation }: Props) {
  const { createCourse } = useCourses();
  const { user } = useAuth();
  const [loading, setLoading] = useState(false);
  
  const [name, setName] = useState('');
  const [city, setCity] = useState('');
  const [state, setState] = useState('');
  const [country, setCountry] = useState('');
  const [errors, setErrors] = useState<{ [key: string]: string }>({});

  const validateForm = () => {
    const newErrors: { [key: string]: string } = {};
    
    if (!name.trim()) {
      newErrors.name = 'Course name is required';
    }
    
    // At least city and state are required if in the US
    if (country.toLowerCase() === 'usa' || country.toLowerCase() === 'us' || country.toLowerCase() === 'united states') {
      if (!city.trim()) newErrors.city = 'City is required for US courses';
      if (!state.trim()) newErrors.state = 'State is required for US courses';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async () => {
    if (!validateForm() || !user) return;

    setLoading(true);
    try {
      await createCourse({
        name: name.trim(),
        location: {
          city: city.trim(),
          state: state.trim(),
          country: country.trim()
        },
        addedBy: user._id
      });

      Alert.alert(
        'Success',
        'Course added successfully',
        [{
          text: 'OK',
          onPress: () => navigation.goBack()
        }]
      );
    } catch (error) {
      Alert.alert(
        'Error',
        error instanceof Error 
          ? error.message 
          : 'Failed to add course'
      );
    } finally {
      setLoading(false);
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <BackButton />
      <View style={styles.content}>
        <FormInput
          label="Course Name"
          value={name}
          onChangeText={setName}
          placeholder="Enter course name"
          error={errors.name}
          editable={!loading}
          required
        />

        <FormInput
          label="City"
          value={city}
          onChangeText={setCity}
          placeholder="Enter city"
          error={errors.city}
          editable={!loading}
        />

        <FormInput
          label="State/Province"
          value={state}
          onChangeText={setState}
          placeholder="Enter state or province"
          error={errors.state}
          editable={!loading}
        />

        <FormInput
          label="Country"
          value={country}
          onChangeText={setCountry}
          placeholder="Enter country"
          error={errors.country}
          editable={!loading}
        />

        <FormButton
          title="Add Course"
          onPress={handleSubmit}
          loading={loading}
          style={styles.submitButton}
        />
      </View>
    </SafeAreaView>
  );
}</document_content>
</document>
<document index="15">
<source>golf-tracker/src/screens/course/AddCourse/styles.ts</source>
<document_content>
// src/screens/course/AddCourse/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  content: {
    padding: 16,
    gap: 16,
  },
  submitButton: {
    marginTop: 24,
  },
});</document_content>
</document>
<document index="16">
<source>golf-tracker/src/screens/Goals/index.tsx</source>
<document_content>
// src/screens/Goals/index.tsx
import React, { useState, useCallback, useEffect } from 'react';
import { API_URL } from '../../config/constants';
import {
  View,
  Text,
  ScrollView,
  TouchableOpacity,
  Modal,
  TextInput,
  Platform,
  Switch,
  Alert,
  ActivityIndicator,
  Animated,
  Button
} from 'react-native';
import DateTimePicker from '@react-native-community/datetimepicker';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useFocusEffect } from '@react-navigation/native';
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import { MainStackParamList } from '../../config/navigation';
import { styles } from './styles';
import { useAuth } from '../../hooks/useAuth';
import { useGoals } from '../../hooks/useGoals';
import type { Goal, CreateGoalInput } from 'shared';
import { BackButton } from '../../components/common/BackButton';
import { ArrowUp, ArrowDown, Target, CheckCircle, Trophy, Calendar, Flag, Award } from 'lucide-react-native';
import { FormInput } from '../../components/forms/FormInput';
import { FormButton } from '../../components/forms/FormButton';
import { LoadingScreen } from '../../components/common/LoadingScreen';

// CustomDatePicker using direct input fields for better control and stability
const CustomDatePicker = ({ value, onChange, minimumDate }: { 
  value: Date, 
  onChange: (date: Date) => void,
  minimumDate?: Date
}) => {
  const [show, setShow] = useState(false);
  
  // State for manual date entry controls
  const [day, setDay] = useState(String(value.getDate()).padStart(2, '0'));
  const [month, setMonth] = useState(String(value.getMonth() + 1).padStart(2, '0'));
  const [year, setYear] = useState(String(value.getFullYear()));
  
  // When the modal opens, initialize from the value prop
  useEffect(() => {
    if (show) {
      setDay(String(value.getDate()).padStart(2, '0'));
      setMonth(String(value.getMonth() + 1).padStart(2, '0'));
      setYear(String(value.getFullYear()));
    }
  }, [show, value]);
  
  const showPicker = () => {
    setShow(true);
  };
  
  const handleConfirm = () => {
    // Validate inputs
    const dayNum = parseInt(day, 10);
    const monthNum = parseInt(month, 10) - 1; // 0-indexed in JS Date
    const yearNum = parseInt(year, 10);
    
    if (isNaN(dayNum) || isNaN(monthNum) || isNaN(yearNum) ||
        dayNum < 1 || dayNum > 31 || monthNum < 0 || monthNum > 11 || yearNum < 2000) {
      // Invalid date, don't update
      Alert.alert("Invalid Date", "Please enter a valid date");
      return;
    }
    
    // Create and validate the date
    const newDate = new Date(yearNum, monthNum, dayNum);
    
    // Check if date is valid (some months don't have 31 days)
    if (newDate.getDate() !== dayNum || newDate.getMonth() !== monthNum) {
      Alert.alert("Invalid Date", "Please enter a valid date for the selected month");
      return;
    }
    
    // Check if it's after minimum date if provided
    if (minimumDate && newDate < minimumDate) {
      Alert.alert("Invalid Date", "The date must be in the future");
      return;
    }
    
    setShow(false);
    onChange(newDate);
  };
  
  const handleCancel = () => {
    setShow(false);
  };
  
  // Months array for dropdown
  const months = [
    { label: "January", value: "01" },
    { label: "February", value: "02" },
    { label: "March", value: "03" },
    { label: "April", value: "04" },
    { label: "May", value: "05" },
    { label: "June", value: "06" },
    { label: "July", value: "07" },
    { label: "August", value: "08" },
    { label: "September", value: "09" },
    { label: "October", value: "10" },
    { label: "November", value: "11" },
    { label: "December", value: "12" }
  ];
  
  // Get days array for current month
  const getDaysInMonth = (month: number, year: number) => {
    return new Date(year, month, 0).getDate();
  };
  
  const generateDaysArray = () => {
    const monthNum = parseInt(month, 10);
    const yearNum = parseInt(year, 10);
    
    if (isNaN(monthNum) || isNaN(yearNum)) return Array.from({length: 31}, (_, i) => ({ label: String(i + 1), value: String(i + 1).padStart(2, '0') }));
    
    const daysInMonth = getDaysInMonth(monthNum, yearNum);
    return Array.from({length: daysInMonth}, (_, i) => ({ 
      label: String(i + 1), 
      value: String(i + 1).padStart(2, '0') 
    }));
  };
  
  // Generate years (current year to current year + 10)
  const currentYear = new Date().getFullYear();
  const years = Array.from({length: 11}, (_, i) => ({ 
    label: String(currentYear + i), 
    value: String(currentYear + i) 
  }));
  
  return (
    <View>
      <TouchableOpacity onPress={showPicker} style={styles.dateButton}>
        <Calendar size={16} color="#2f95dc" />
        <Text style={styles.dateButtonText}>
          {value.toLocaleDateString()} (Tap to change)
        </Text>
      </TouchableOpacity>
      
      {/* Custom date picker modal */}
      <Modal
        visible={show}
        transparent={true}
        animationType="slide"
        onRequestClose={handleCancel}
      >
        <View style={styles.datePickerModalOverlay}>
          <View style={styles.datePickerModalContent}>
            <View style={styles.datePickerModalHeader}>
              <TouchableOpacity 
                onPress={handleCancel}
                style={styles.datePickerHeaderButton}
              >
                <Text style={styles.datePickerCancelText}>Cancel</Text>
              </TouchableOpacity>
              <Text style={styles.datePickerModalTitle}>Select Date</Text>
              <TouchableOpacity 
                onPress={handleConfirm}
                style={styles.datePickerHeaderButton}
              >
                <Text style={styles.datePickerDoneText}>Done</Text>
              </TouchableOpacity>
            </View>
            
            <View style={styles.dateInputContainer}>
              {/* Month Picker */}
              <View style={styles.datePickerColumn}>
                <Text style={styles.datePickerLabel}>Month</Text>
                <ScrollView style={styles.datePickerScrollView}>
                  {months.map(item => (
                    <TouchableOpacity
                      key={item.value}
                      style={[
                        styles.datePickerItem,
                        month === item.value && styles.datePickerItemSelected
                      ]}
                      onPress={() => setMonth(item.value)}
                    >
                      <Text 
                        style={[
                          styles.datePickerItemText,
                          month === item.value && styles.datePickerItemTextSelected
                        ]}
                      >
                        {item.label}
                      </Text>
                    </TouchableOpacity>
                  ))}
                </ScrollView>
              </View>
              
              {/* Day Picker */}
              <View style={styles.datePickerColumn}>
                <Text style={styles.datePickerLabel}>Day</Text>
                <ScrollView style={styles.datePickerScrollView}>
                  {generateDaysArray().map(item => (
                    <TouchableOpacity
                      key={item.value}
                      style={[
                        styles.datePickerItem,
                        day === item.value && styles.datePickerItemSelected
                      ]}
                      onPress={() => setDay(item.value)}
                    >
                      <Text 
                        style={[
                          styles.datePickerItemText,
                          day === item.value && styles.datePickerItemTextSelected
                        ]}
                      >
                        {item.label}
                      </Text>
                    </TouchableOpacity>
                  ))}
                </ScrollView>
              </View>
              
              {/* Year Picker */}
              <View style={styles.datePickerColumn}>
                <Text style={styles.datePickerLabel}>Year</Text>
                <ScrollView style={styles.datePickerScrollView}>
                  {years.map(item => (
                    <TouchableOpacity
                      key={item.value}
                      style={[
                        styles.datePickerItem,
                        year === item.value && styles.datePickerItemSelected
                      ]}
                      onPress={() => setYear(item.value)}
                    >
                      <Text 
                        style={[
                          styles.datePickerItemText,
                          year === item.value && styles.datePickerItemTextSelected
                        ]}
                      >
                        {item.label}
                      </Text>
                    </TouchableOpacity>
                  ))}
                </ScrollView>
              </View>
            </View>
          </View>
        </View>
      </Modal>
    </View>
  );
};

type Props = NativeStackScreenProps<MainStackParamList, 'Goals'>;

export function GoalsScreen({ navigation }: Props) {
  const { user } = useAuth();
  const { 
    goals, 
    loading, 
    error, 
    fetchGoals, 
    addGoal, 
    updateGoal,
    removeGoal,
    toggleAchievement 
  } = useGoals();
  
  const [showAddModal, setShowAddModal] = useState(false);
  const [newGoal, setNewGoal] = useState({
    name: '',
    targetValue: '',
    category: 'scoring' as 'handicap' | 'scoring' | 'fairways' | 'greens' | 'putts' | 'custom',
    description: '',
    hasTargetDate: false,
    targetDate: new Date()
  });
  
  // For celebration animation
  const [showCelebration, setShowCelebration] = useState(false);
  const [celebrationScale] = useState(new Animated.Value(0));
  
  // State for active/completed tab
  const [activeTab, setActiveTab] = useState<'active' | 'completed'>('active');

  // Add effect to show API info
  useEffect(() => {
    console.log('Current API URL:', API_URL);
    
    // Test direct fetch to server
    fetch(`${API_URL}/goals/test`)
      .then(response => {
        console.log('Direct test fetch status:', response.status);
        return response.text();
      })
      .then(text => {
        console.log('Direct test fetch result:', text);
      })
      .catch(err => {
        console.error('Direct test fetch error:', err);
      });
  }, []);
  
  // Fetch goals on screen focus
  useFocusEffect(
    useCallback(() => {
      console.log('Goals screen focused, fetching goals...');
      fetchGoals().catch(err => {
        console.error('Error in fetchGoals on focus:', err);
      });
    }, [fetchGoals])
  );

  const handleAddGoal = async () => {
    if (!newGoal.name || !newGoal.targetValue) {
      Alert.alert('Validation Error', 'Please provide a name and target value for your goal');
      return;
    }

    const goalData: CreateGoalInput = {
      name: newGoal.name,
      targetValue: parseFloat(newGoal.targetValue),
      category: newGoal.category,
      description: newGoal.description
    };

    if (newGoal.hasTargetDate) {
      goalData.targetDate = newGoal.targetDate;
    }

    try {
      await addGoal(goalData);
      setShowAddModal(false);
      
      // Reset form
      setNewGoal({
        name: '',
        targetValue: '',
        category: 'scoring',
        description: '',
        hasTargetDate: false,
        targetDate: new Date()
      });
    } catch (err) {
      Alert.alert('Error', 'Failed to create goal. Please try again.');
    }
  };

  // Handle target date change
  const handleDateChange = (date: Date) => {
    setNewGoal(prev => ({...prev, targetDate: date}));
  };
  
  // Render celebration modal
  const renderCelebrationModal = () => (
    <Modal
      visible={showCelebration}
      transparent={true}
      animationType="fade"
    >
      <View style={styles.celebrationOverlay}>
        <Animated.View 
          style={[
            styles.celebrationContent,
            { transform: [{ scale: celebrationScale }] }
          ]}
        >
          <Award size={60} color="#4CAF50" />
          <Text style={styles.celebrationTitle}>Goal Achieved!</Text>
          <Text style={styles.celebrationText}>Congratulations on reaching your goal!</Text>
        </Animated.View>
      </View>
    </Modal>
  );

  // State for tracking the name of the completed goal
  const [completedGoalName, setCompletedGoalName] = useState('');
  
  // Show celebration animation
  const playCelebrationAnimation = (goalName: string) => {
    setCompletedGoalName(goalName);
    setShowCelebration(true);
    Animated.sequence([
      Animated.timing(celebrationScale, {
        toValue: 1.2,
        duration: 300,
        useNativeDriver: true
      }),
      Animated.timing(celebrationScale, {
        toValue: 1,
        duration: 200,
        useNativeDriver: true
      })
    ]).start(() => {
      setTimeout(() => {
        setShowCelebration(false);
        celebrationScale.setValue(0);
      }, 2000);
    });
  };

  const handleToggleAchieved = async (goalId: string, newStatus: boolean) => {
    try {
      const updatedGoal = await toggleAchievement(goalId, newStatus);
      
      // If the goal was just marked as achieved, show celebration
      if (newStatus) {
        // Find the goal to get its name for the celebration
        const achievedGoal = goals.find(g => g._id === goalId);
        playCelebrationAnimation(achievedGoal?.name || 'Goal');
      }
    } catch (err) {
      Alert.alert('Error', 'Failed to update goal status. Please try again.');
    }
  };
  
  const handleDeleteGoal = async (goalId: string) => {
    try {
      await removeGoal(goalId);
      // The UI will update automatically from the hook's state management
    } catch (err) {
      Alert.alert('Error', 'Failed to delete goal. Please try again.');
    }
  };

  const getCategoryIcon = (category: string, achieved: boolean = false) => {
    const iconColor = achieved ? "#4CAF50" : "#2f95dc";
    
    switch (category) {
      case 'handicap':
        return <Target size={20} color={iconColor} />;
      case 'scoring':
        return <Flag size={20} color={iconColor} />;
      case 'fairways':
        return <ArrowUp size={20} color={iconColor} />;
      case 'greens':
        return <ArrowDown size={20} color={iconColor} />;
      case 'putts':
        return <Trophy size={20} color={iconColor} />;
      default:
        return <Target size={20} color={iconColor} />;
    }
  };

  const renderGoalItem = (goal: Goal) => {
    // Check if deadline has passed
    const deadlinePassed = goal.targetDate ? new Date() > new Date(goal.targetDate) : false;
    
    // Calculate progress percentage for visual indicator
    let progressPercent = 0;
    if (goal.currentValue !== undefined && goal.targetValue) {
      // For handicap, scoring, putts - lower is better
      if (['handicap', 'scoring', 'putts'].includes(goal.category)) {
        const initialValue = goal.category === 'handicap' ? 36 : 
                            goal.category === 'scoring' ? 120 : 45;
        progressPercent = Math.min(100, Math.max(0, 
          ((initialValue - goal.currentValue) / (initialValue - goal.targetValue)) * 100
        ));
      } else {
        // For fairways, greens - higher is better
        progressPercent = Math.min(100, Math.max(0, 
          (goal.currentValue / goal.targetValue) * 100
        ));
      }
    }
    
    // Create action sheet menu for delete/other actions
    const showOptions = () => {
      Alert.alert(
        'Goal Options', 
        'What would you like to do with this goal?',
        [
          {
            text: 'Delete Goal',
            onPress: () => confirmDelete(goal._id),
            style: 'destructive',
          },
          {
            text: goal.achieved ? 'Mark as Not Achieved' : 'Mark as Achieved',
            onPress: () => handleToggleAchieved(goal._id, !goal.achieved),
          },
          {
            text: 'Cancel',
            style: 'cancel',
          },
        ]
      );
    };
    
    const confirmDelete = (goalId: string) => {
      Alert.alert(
        'Confirm Delete',
        'Are you sure you want to delete this goal? This cannot be undone.',
        [
          {
            text: 'Cancel',
            style: 'cancel',
          },
          {
            text: 'Delete',
            style: 'destructive',
            onPress: () => handleDeleteGoal(goalId),
          },
        ]
      );
    };
    
    // Format date for display
    const formatDate = (dateString?: string) => {
      if (!dateString) return '';
      const date = new Date(dateString);
      return date.toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'short', 
        day: 'numeric' 
      });
    };
    
    return (
      <TouchableOpacity 
        key={goal._id} 
        onLongPress={showOptions}
        activeOpacity={0.7}
      >
        <View style={[
          styles.goalCard, 
          goal.achieved && styles.achievedGoal,
          deadlinePassed && !goal.achieved && styles.expiredGoal
        ]}>
          <TouchableOpacity 
            style={[
              styles.achieveButton,
              goal.achieved && styles.achievedCheckButton
            ]}
            onPress={() => handleToggleAchieved(goal._id, !goal.achieved)}
          >
            {goal.achieved ? (
              <CheckCircle 
                size={28} 
                color="#4CAF50"
                fill="transparent"
                strokeWidth={2.5}
              />
            ) : (
              <CheckCircle 
                size={28} 
                color={deadlinePassed ? "#FF6B6B" : "#CCC"}
                fill="transparent"
                strokeWidth={1.5}
              />
            )}
          </TouchableOpacity>
          
          <View style={styles.goalContent}>
            <View style={styles.goalHeader}>
              <Text style={[
                styles.goalName,
                goal.achieved && styles.achievedText
              ]}>{goal.name}</Text>
              <TouchableOpacity onPress={showOptions}>
                <Text style={styles.goalOptionsButton}>•••</Text>
              </TouchableOpacity>
            </View>
            
            {/* Completed date for achieved goals */}
            {goal.achieved && goal.completedAt && (
              <View style={styles.completedDateContainer}>
                <Trophy size={14} color="#4CAF50" />
                <Text style={styles.completedDateText}>
                  Completed: {formatDate(typeof goal.completedAt === 'string' ? goal.completedAt : goal.completedAt?.toISOString())}
                </Text>
              </View>
            )}
            
            <View style={styles.goalDetails}>
              <View style={styles.categoryContainer}>
                {getCategoryIcon(goal.category, goal.achieved)}
                <Text style={[
                  styles.categoryText,
                  goal.achieved && styles.achievedText
                ]}>
                  {goal.category.charAt(0).toUpperCase() + goal.category.slice(1)}
                </Text>
              </View>
              
              <Text style={[
                styles.goalTarget,
                goal.achieved && styles.achievedText
              ]}>
                Target: {goal.targetValue}
                {goal.category === 'handicap' && ' HCP'}
                {goal.category === 'scoring' && ' strokes'}
                {goal.category === 'fairways' && ' FIRs'}
                {goal.category === 'greens' && ' GIRs'}
                {goal.category === 'putts' && ' putts'}
              </Text>
              
              {/* Always show current value for all goals */}
              {goal.currentValue !== undefined && (
                <>
                  <Text style={[
                    styles.goalCurrent,
                    goal.achieved && styles.achievedText
                  ]}>
                    {goal.achieved ? "Best: " : "Current: "}{goal.currentValue}
                    {goal.category === 'handicap' && ' HCP'}
                    {goal.category === 'scoring' && ' strokes'}
                    {goal.category === 'fairways' && ' FIRs'}
                    {goal.category === 'greens' && ' GIRs'}
                    {goal.category === 'putts' && ' putts'}
                  </Text>
                  {/* Logging happens outside of JSX */}
                  {goal.category === 'putts' ? (
                    (() => {
                      console.log(`[Goal Display] Putts goal: ${goal.name}, ID: ${goal._id}, Value: ${goal.currentValue}, Achieved: ${goal.achieved}`);
                      return null;
                    })()
                  ) : null}
                </>
              )}
              
              {/* Progress bar - only show for active goals */}
              {!goal.achieved && (
                <View style={styles.progressBarContainer}>
                  <View 
                    style={[
                      styles.progressBar, 
                      { width: `${progressPercent}%` },
                      deadlinePassed && styles.progressBarExpired
                    ]} 
                  />
                </View>
              )}
            </View>
            
            {goal.description && (
              <Text style={styles.goalDescription}>{goal.description}</Text>
            )}
            
            {goal.targetDate && !goal.achieved && (
              <View style={styles.dateContainer}>
                <Calendar size={16} color={deadlinePassed ? "#FF6B6B" : "#2f95dc"} />
                <Text style={[
                  styles.targetDate,
                  deadlinePassed && styles.expiredDate
                ]}>
                  {deadlinePassed ? "Deadline passed: " : "Target date: "}
                  {formatDate(typeof goal.targetDate === 'string' ? goal.targetDate : goal.targetDate?.toISOString())}
                </Text>
              </View>
            )}
            
            {goal.achieved && (
              <View style={styles.achievedBadge}>
                <Text style={styles.achievedBadgeText}>Completed</Text>
              </View>
            )}
          </View>
        </View>
      </TouchableOpacity>
    );
  };

  const renderAddGoalModal = () => (
    <Modal
      visible={showAddModal}
      transparent={true}
      animationType="slide"
      onRequestClose={() => setShowAddModal(false)}
    >
      <View style={styles.modalOverlay}>
        <View style={styles.modalContent}>
          <View style={styles.modalHeader}>
            <Text style={styles.modalTitle}>Add New Goal</Text>
            <TouchableOpacity 
              style={styles.closeButton} 
              onPress={() => setShowAddModal(false)}
            >
              <Text style={styles.closeButtonText}>Cancel</Text>
            </TouchableOpacity>
          </View>
          
          <ScrollView style={styles.formContainer}>
            <FormInput 
              label="Goal Name"
              value={newGoal.name}
              onChangeText={(text) => setNewGoal({...newGoal, name: text})}
              placeholder="e.g., Break 80, Improve fairway accuracy"
            />

            <FormInput 
              label="Target Value"
              value={newGoal.targetValue}
              onChangeText={(text) => setNewGoal({...newGoal, targetValue: text})}
              placeholder="e.g., 80, 65, 12.5"
              keyboardType="numeric"
            />

            <View style={styles.formGroup}>
              <Text style={styles.label}>Category</Text>
              <View style={styles.categoryOptions}>
                {['handicap', 'scoring', 'fairways', 'greens', 'putts'].map(category => (
                  <TouchableOpacity 
                    key={category}
                    style={[
                      styles.categoryOption,
                      newGoal.category === category && styles.selectedCategory
                    ]}
                    onPress={() => setNewGoal({
                      ...newGoal, 
                      category: category as any
                    })}
                  >
                    {getCategoryIcon(category)}
                    <Text style={[
                      styles.categoryOptionText,
                      newGoal.category === category && styles.selectedCategoryText
                    ]}>
                      {category.charAt(0).toUpperCase() + category.slice(1)}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>
            </View>

            <FormInput 
              label="Description (Optional)"
              value={newGoal.description}
              onChangeText={(text) => setNewGoal({...newGoal, description: text})}
              placeholder="Add details about your goal"
              multiline
            />

            <View style={styles.formGroup}>
              <View style={styles.toggleRow}>
                <Text style={styles.label}>Set Target Date</Text>
                <Switch
                  value={newGoal.hasTargetDate}
                  onValueChange={(value) => setNewGoal({...newGoal, hasTargetDate: value})}
                  trackColor={{ false: "#767577", true: "#81b0ff" }}
                  thumbColor={newGoal.hasTargetDate ? "#2f95dc" : "#f4f3f4"}
                />
              </View>
              
              {/* Custom DatePicker component */}
              {newGoal.hasTargetDate && (
                <CustomDatePicker 
                  value={newGoal.targetDate}
                  onChange={handleDateChange}
                  minimumDate={new Date()}
                />
              )}
            </View>

            <FormButton 
              title="Add Goal"
              onPress={handleAddGoal}
              style={styles.addButton}
            />
          </ScrollView>
        </View>
      </View>
    </Modal>
  );

  if (loading && goals.length === 0) {
    return <LoadingScreen />;
  }

  if (error) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.header}>
          <BackButton onPress={() => navigation.goBack()} />
          <Text style={styles.screenTitle}>My Goals</Text>
          <View style={{ width: 40 }} />
        </View>

        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>{error}</Text>
          <TouchableOpacity
            style={styles.retryButton}
            onPress={fetchGoals}
          >
            <Text style={styles.retryButtonText}>Retry</Text>
          </TouchableOpacity>
        </View>
      </SafeAreaView>
    );
  }

  // Filter goals based on active tab
  const activeGoals = goals.filter(goal => !goal.achieved);
  const completedGoals = goals.filter(goal => goal.achieved);
  
  // Sort goals for display
  const sortedActiveGoals = [...activeGoals].sort((a, b) => 
    new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
  );
  
  const sortedCompletedGoals = [...completedGoals].sort((a, b) => {
    // Sort by completedAt date if available, otherwise by updated date
    const aDate = a.completedAt ? new Date(a.completedAt) : new Date(a.updatedAt);
    const bDate = b.completedAt ? new Date(b.completedAt) : new Date(b.updatedAt);
    return bDate.getTime() - aDate.getTime();
  });
  
  // Get goals for current tab
  const currentGoals = activeTab === 'active' ? sortedActiveGoals : sortedCompletedGoals;
  
  return (
    <SafeAreaView style={styles.container}>
      <BackButton onPress={() => navigation.goBack()} />
      <View style={styles.header}>
        <Text style={styles.screenTitle}>My Goals</Text>
      </View>
      
      {/* Tab selector */}
      <View style={styles.tabContainer}>
        <TouchableOpacity
          style={[
            styles.tabButton,
            activeTab === 'active' && styles.activeTabButton
          ]}
          onPress={() => setActiveTab('active')}
        >
          <Text style={[
            styles.tabButtonText,
            activeTab === 'active' && styles.activeTabText
          ]}>
            Active ({activeGoals.length})
          </Text>
        </TouchableOpacity>
        
        <TouchableOpacity
          style={[
            styles.tabButton,
            activeTab === 'completed' && styles.activeTabButton
          ]}
          onPress={() => setActiveTab('completed')}
        >
          <Text style={[
            styles.tabButtonText,
            activeTab === 'completed' && styles.activeTabText
          ]}>
            Completed ({completedGoals.length})
          </Text>
        </TouchableOpacity>
      </View>
      
      <ScrollView style={styles.content}>
        {loading && (
          <View style={styles.loadingIndicator}>
            <ActivityIndicator size="small" color="#2f95dc" />
          </View>
        )}
        
        <View style={styles.goalsContainer}>
          {currentGoals.length === 0 ? (
            <View style={styles.emptyState}>
              <Trophy size={60} color="#ccc" />
              <Text style={styles.emptyStateText}>
                {activeTab === 'active' 
                  ? "You don't have any active goals" 
                  : "You haven't completed any goals yet"}
              </Text>
              <Text style={styles.emptyStateSubtext}>
                {activeTab === 'active'
                  ? "Track your progress by setting golf performance goals"
                  : "Complete your active goals to see them here"}
              </Text>
            </View>
          ) : (
            currentGoals.map(renderGoalItem)
          )}
        </View>
      </ScrollView>
      
      <TouchableOpacity 
        style={styles.floatingButton}
        onPress={() => setShowAddModal(true)}
      >
        <Text style={styles.floatingButtonText}>+ New Goal</Text>
      </TouchableOpacity>
      
      {renderAddGoalModal()}
      <Modal
        visible={showCelebration}
        transparent={true}
        animationType="fade"
      >
        <View style={styles.celebrationOverlay}>
          <Animated.View 
            style={[
              styles.celebrationContent,
              { transform: [{ scale: celebrationScale }] }
            ]}
          >
            <Award size={60} color="#4CAF50" />
            <Text style={styles.celebrationTitle}>Goal Achieved!</Text>
            <Text style={styles.celebrationText}>
              Congratulations on achieving: {completedGoalName}!
            </Text>
          </Animated.View>
        </View>
      </Modal>
    </SafeAreaView>
  );
}</document_content>
</document>
<document index="17">
<source>golf-tracker/src/screens/Goals/styles.ts</source>
<document_content>
// src/screens/Goals/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  tabContainer: {
    marginTop: 10,
    flexDirection: 'row',
    marginHorizontal: 16,
    marginBottom: 12,
    borderRadius: 8,
    backgroundColor: '#f2f2f2',
    overflow: 'hidden',
  },
  tabButton: {
    flex: 1,
    paddingVertical: 10,
    alignItems: 'center',
    justifyContent: 'center',
  },
  activeTabButton: {
    backgroundColor: '#2f95dc',
  },
  tabButtonText: {
    fontSize: 14,
    fontWeight: '500',
    color: '#555',
  },
  activeTabText: {
    color: 'white',
    fontWeight: 'bold',
  },
  completedDateContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 6,
  },
  completedDateText: {
    fontSize: 12,
    color: '#4CAF50',
    marginLeft: 4,
    fontStyle: 'italic',
  },
  goalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  goalOptionsButton: {
    fontSize: 18,
    color: '#999',
    paddingHorizontal: 8,
  },
  // Custom date picker styles
  dateInputContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingHorizontal: 10,
    paddingVertical: 20,
  },
  datePickerColumn: {
    width: '30%',
    height: 200,
  },
  datePickerLabel: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#555',
    textAlign: 'center',
    marginBottom: 10,
  },
  datePickerScrollView: {
    height: 170,
    borderRadius: 5,
    backgroundColor: '#f9f9f9',
  },
  datePickerItem: {
    padding: 12,
    alignItems: 'center',
    justifyContent: 'center',
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  datePickerItemSelected: {
    backgroundColor: '#e6f7ff',
  },
  datePickerItemText: {
    fontSize: 16,
    color: '#333',
  },
  datePickerItemTextSelected: {
    color: '#2f95dc',
    fontWeight: 'bold',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  errorText: {
    fontSize: 16,
    color: '#ff6b6b',
    marginBottom: 16,
    textAlign: 'center',
  },
  retryButton: {
    backgroundColor: '#2f95dc',
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 6,
  },
  retryButtonText: {
    color: '#fff',
    fontWeight: '600',
  },
  loadingIndicator: {
    paddingVertical: 20,
    alignItems: 'center',
  },
  container: {
    flex: 1,
    backgroundColor: '#f8f9fa',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 12,
    backgroundColor: 'transparent',
    borderBottomWidth: 1,
    borderBottomColor: '#eaeaea',
    zIndex: 1,
  },
  screenTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
  },
  content: {
    flex: 1,
  },
  goalsContainer: {
    padding: 16,
  },
  goalCard: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    flexDirection: 'row',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  achievedGoal: {
    backgroundColor: '#f0f8f0',
    borderLeftColor: '#4CAF50',
    borderLeftWidth: 4,
  },
  achievedCheckButton: {
    backgroundColor: '#e8f5e9',
    borderRadius: 20,
  },
  expiredGoal: {
    backgroundColor: '#fff5f5',
    borderLeftColor: '#FF6B6B',
    borderLeftWidth: 4,
  },
  achievedText: {
    color: '#4CAF50',
    fontWeight: '600',
  },
  progressBarContainer: {
    height: 6,
    backgroundColor: '#f0f0f0',
    borderRadius: 3,
    marginTop: 8,
    marginBottom: 4,
    width: '100%',
  },
  progressBar: {
    height: 6,
    backgroundColor: '#2f95dc',
    borderRadius: 3,
  },
  progressBarCompleted: {
    backgroundColor: '#4CAF50',
  },
  progressBarExpired: {
    backgroundColor: '#FF6B6B',
  },
  expiredDate: {
    color: '#FF6B6B',
  },
  achievedBadge: {
    position: 'absolute',
    right: -5,
    top: '50%',
    backgroundColor: '#4CAF50',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  achievedBadgeText: {
    color: 'white',
    fontSize: 10,
    fontWeight: 'bold',
  },
  achieveButton: {
    marginRight: 12,
    alignSelf: 'center',
    padding: 6, // Add some padding to increase tap area
  },
  goalContent: {
    flex: 1,
  },
  goalName: {
    fontSize: 18,
    fontWeight: '600',
    marginBottom: 8,
    color: '#333',
  },
  goalDetails: {
    marginBottom: 8,
  },
  categoryContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 4,
  },
  categoryText: {
    fontSize: 14,
    color: '#777',
    marginLeft: 4,
  },
  goalTarget: {
    fontSize: 14,
    color: '#555',
    marginBottom: 2,
  },
  goalCurrent: {
    fontSize: 14,
    color: '#555',
    marginBottom: 2,
  },
  goalDescription: {
    fontSize: 14,
    color: '#666',
    marginBottom: 8,
    fontStyle: 'italic',
  },
  dateContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  targetDate: {
    fontSize: 12,
    color: '#888',
    marginLeft: 4,
  },
  floatingButton: {
    position: 'absolute',
    right: 20,
    bottom: 20,
    backgroundColor: '#2f95dc',
    borderRadius: 30,
    paddingVertical: 12,
    paddingHorizontal: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 3,
    elevation: 5,
  },
  floatingButtonText: {
    color: '#fff',
    fontWeight: '600',
    fontSize: 16,
  },
  emptyState: {
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 40,
  },
  emptyStateText: {
    fontSize: 18,
    fontWeight: '600',
    color: '#777',
    marginTop: 16,
    marginBottom: 8,
  },
  emptyStateSubtext: {
    fontSize: 14,
    color: '#999',
    textAlign: 'center',
    paddingHorizontal: 40,
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'flex-end',
  },
  modalContent: {
    backgroundColor: '#fff',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    paddingBottom: 30,
    maxHeight: '80%',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingVertical: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eaeaea',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: '600',
  },
  closeButton: {
    padding: 8,
  },
  closeButtonText: {
    color: '#2f95dc',
    fontSize: 16,
  },
  formContainer: {
    padding: 20,
  },
  formGroup: {
    marginBottom: 16,
  },
  label: {
    fontSize: 16,
    fontWeight: '500',
    marginBottom: 8,
    color: '#444',
  },
  categoryOptions: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 8,
  },
  categoryOption: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f2f2f2',
    borderRadius: 20,
    paddingVertical: 8,
    paddingHorizontal: 12,
    marginRight: 8,
    marginBottom: 8,
  },
  selectedCategory: {
    backgroundColor: '#e1f0ff',
    borderColor: '#2f95dc',
    borderWidth: 1,
  },
  categoryOptionText: {
    fontSize: 14,
    color: '#555',
    marginLeft: 4,
  },
  selectedCategoryText: {
    color: '#2f95dc',
    fontWeight: '500',
  },
  toggleRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  datePickerPlaceholder: {
    fontSize: 14,
    color: '#777',
    fontStyle: 'italic',
    textAlign: 'center',
    paddingVertical: 16,
    backgroundColor: '#f8f8f8',
    borderRadius: 8,
  },
  addButton: {
    marginTop: 16,
  },
  dateButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f8f8f8',
    borderRadius: 8,
    padding: 12,
    marginTop: 8,
  },
  dateButtonText: {
    marginLeft: 8,
    fontSize: 14,
    color: '#555',
  },
  celebrationOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  celebrationContent: {
    backgroundColor: '#fff',
    borderRadius: 16,
    padding: 24,
    alignItems: 'center',
    width: '80%',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    elevation: 5,
  },
  celebrationTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#4CAF50',
    marginVertical: 12,
  },
  celebrationText: {
    fontSize: 16,
    textAlign: 'center',
    color: '#555',
    marginBottom: 8,
  },
  datePickerModalOverlay: {
    flex: 1,
    justifyContent: 'flex-end',
    backgroundColor: 'rgba(0,0,0,0.5)',
  },
  datePickerModalContent: {
    backgroundColor: 'white',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    paddingBottom: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: -2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  datePickerModalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eaeaea',
  },
  datePickerModalTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
  },
  datePickerHeaderButton: {
    padding: 8,
  },
  datePickerCancelText: {
    color: '#999',
    fontSize: 16,
  },
  datePickerDoneText: {
    color: '#2f95dc',
    fontSize: 16,
    fontWeight: '600',
  },
  datePickerIOS: {
    height: 216,
    width: '100%',
  },
});</document_content>
</document>
<document index="18">
<source>golf-tracker/src/screens/auth/Landing/index.tsx</source>
<document_content>
// src/screens/auth/Landing/index.tsx
import React from 'react';
import { View, Text, useWindowDimensions } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import { AuthStackParamList } from '../../../config/navigation';
import { FormButton } from '../../../components/forms/FormButton';
import { styles } from './styles';

type Props = NativeStackScreenProps<AuthStackParamList, 'Landing'>;

function FeaturePoint({ text }: { text: string }) {
  return (
    <View style={styles.featurePoint}>
      <Text style={styles.featureIcon}>✓</Text>
      <Text style={styles.featureText}>{text}</Text>
    </View>
  );
}

export function LandingScreen({ navigation }: Props) {
  const { height } = useWindowDimensions();

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.content}>
        {/* Top Section with Logo/Branding */}
        <View style={[styles.topSection, { height: height * 0.5 }]}>
          <View style={styles.logoContainer}>
            <Text style={styles.emoji}>⛳️</Text>
            <Text style={styles.appName}>HandiMan</Text>
          </View>
          <Text style={styles.tagline}>Track your scores.</Text>
          <Text style={styles.taglineSecondary}>Improve your game.</Text>
        </View>

        {/* Bottom Section with Feature Points and Buttons */}
        <View style={styles.bottomSection}>
          <View style={styles.features}>
            <FeaturePoint text="Track your rounds and progress" />
            <FeaturePoint text="Calculate your handicap" />
            <FeaturePoint text="Connect with other golfers" />
          </View>

          <View style={styles.buttonContainer}>
            <FormButton
              title="Get Started"
              onPress={() => navigation.navigate('Signup')}
            />
            <FormButton
              title="I already have an account"
              onPress={() => navigation.navigate('Login')}
              variant="secondary"
            />
          </View>
        </View>
      </View>
    </SafeAreaView>
  );
}</document_content>
</document>
<document index="19">
<source>golf-tracker/src/screens/auth/Landing/styles.ts</source>
<document_content>
// src/screens/auth/Landing/styles.ts
import { StyleSheet, Platform } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  content: {
    flex: 1,
  },
  topSection: {
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 20,
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 24,
  },
  emoji: {
    fontSize: 64,
    marginBottom: 16,
  },
  appName: {
    fontSize: 42,
    fontWeight: 'bold',
    color: '#2f95dc',
    letterSpacing: -1,
  },
  tagline: {
    fontSize: 28,
    fontWeight: '600',
    textAlign: 'center',
    marginBottom: 8,
  },
  taglineSecondary: {
    fontSize: 28,
    fontWeight: '600',
    textAlign: 'center',
    color: '#2f95dc',
  },
  bottomSection: {
    flex: 1,
    paddingHorizontal: 20,
    justifyContent: 'space-between',
    paddingBottom: Platform.OS === 'ios' ? 20 : 40,
  },
  features: {
    gap: 16,
    marginBottom: 32,
  },
  featurePoint: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  featureIcon: {
    color: '#2f95dc',
    fontSize: 20,
    fontWeight: 'bold',
  },
  featureText: {
    fontSize: 16,
    color: '#333',
  },
  buttonContainer: {
    gap: 12,
  },
});</document_content>
</document>
<document index="20">
<source>golf-tracker/src/screens/auth/Signup/index.tsx</source>
<document_content>
// src/screens/auth/Signup/index.tsx
import React from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import { AuthStackParamList } from '../../../config/navigation';
import { FormInput } from '../../../components/forms/FormInput';
import { FormButton } from '../../../components/forms/FormButton';
import { useAuth } from '../../../hooks/useAuth';
import { useForm } from '../../../hooks/useForm';
import { styles } from './styles';
import { 
  email,
  required, 
  minLength,
  matches,
  matchesField 
} from '../../../utils/validation';
import { BackButton } from '../../../components/common/BackButton';


type Props = NativeStackScreenProps<AuthStackParamList, 'Signup'>;

interface SignupForm {
  name: string;
  email: string;
  password: string;
  confirmPassword: string;
}

const initialValues: SignupForm = {
  name: '',
  email: '',
  password: '',
  confirmPassword: ''
};

const validationRules = {
  name: [required<SignupForm>('Name is required')],
  email: [
    required<SignupForm>('Email is required'), 
    email<SignupForm>()
  ],
  password: [
    required<SignupForm>('Password is required'),
    minLength<SignupForm>(8, 'Password must be at least 8 characters'),
    matches<SignupForm>(
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/,
      'Password must contain at least one uppercase letter, one lowercase letter, and one number'
    )
  ],
  confirmPassword: [
    required<SignupForm>('Please confirm your password'),
    matchesField<SignupForm>('password', 'Passwords do not match')
  ]
};

export function SignupScreen({ navigation }: Props) {
  const { signup } = useAuth();
  const {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleBlur,
    handleSubmit,
    setErrors
  } = useForm<SignupForm>({
    initialValues,
    validationRules,
    onSubmit: async (formValues) => {
      try {
        await signup({
          name: formValues.name,
          email: formValues.email,
          password: formValues.password
        });
        
        Alert.alert(
          'Success',
          'Your account has been created successfully!',
          [{ text: 'OK' }]
        );
      } catch (error) {
        if (error instanceof Error) {
          // Handle specific error cases
          if (error.message.toLowerCase().includes('email already registered')) {
            setErrors({ email: 'This email is already registered' });
          } else if (error.message.toLowerCase().includes('network')) {
            Alert.alert(
              'Connection Error',
              'Please check your internet connection and try again.'
            );
          } else {
            Alert.alert('Error', error.message);
          }
        } else {
          Alert.alert(
            'Error',
            'An unexpected error occurred. Please try again later.'
          );
        }
      }
    }
  });

  return (
    <SafeAreaView style={styles.container}>
      <BackButton />
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardView}
      >
        
        <ScrollView contentContainerStyle={styles.scrollContent}>
          
          <View style={styles.header}>
            <Text style={styles.title}>Create Account</Text>
            <Text style={styles.subtitle}>Track your golf progress</Text>
          </View>

          <View style={styles.form}>
            <FormInput
              label="Name"
              value={values.name}
              onChangeText={handleChange('name')}
              onBlur={handleBlur('name')}
              placeholder="Enter your name"
              autoComplete="name"
              error={touched.name ? errors.name : undefined}
              editable={!isSubmitting}
            />

            <FormInput
              label="Email"
              value={values.email}
              onChangeText={handleChange('email')}
              onBlur={handleBlur('email')}
              placeholder="Enter your email"
              autoCapitalize="none"
              autoComplete="email"
              keyboardType="email-address"
              error={touched.email ? errors.email : undefined}
              editable={!isSubmitting}
            />

            <FormInput
              label="Password"
              value={values.password}
              onChangeText={handleChange('password')}
              onBlur={handleBlur('password')}
              placeholder="Create a password"
              secureTextEntry
              autoComplete="new-password"
              error={touched.password ? errors.password : undefined}
              editable={!isSubmitting}
            />

            <FormInput
              label="Confirm Password"
              value={values.confirmPassword}
              onChangeText={handleChange('confirmPassword')}
              onBlur={handleBlur('confirmPassword')}
              placeholder="Confirm your password"
              secureTextEntry
              autoComplete="new-password"
              error={touched.confirmPassword ? errors.confirmPassword : undefined}
              editable={!isSubmitting}
            />

            <FormButton
              title="Create Account"
              onPress={() => handleSubmit()}
              loading={isSubmitting}
            />
          </View>

          <View style={styles.footer}>
            <Text style={styles.footerText}>Already have an account? </Text>
            <TouchableOpacity 
              onPress={() => navigation.navigate('Login')}
              disabled={isSubmitting}
            >
              <Text style={styles.footerLink}>Log In</Text>
            </TouchableOpacity>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}</document_content>
</document>
<document index="21">
<source>golf-tracker/src/screens/auth/Signup/styles.ts</source>
<document_content>
// src/screens/auth/Signup/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  keyboardView: {
    flex: 1,
  },
  scrollContent: {
    flexGrow: 1,
    padding: 20,
  },
  header: {
    marginTop: 40,
    marginBottom: 32,
    alignItems: 'center',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
  },
  form: {
    gap: 16,
    marginBottom: 24,
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginTop: 'auto',
    paddingVertical: 16,
  },
  footerText: {
    color: '#666',
  },
  footerLink: {
    color: '#2f95dc',
    fontWeight: '600',
  },
});</document_content>
</document>
<document index="22">
<source>golf-tracker/src/screens/auth/Login/index.tsx</source>
<document_content>
// src/screens/auth/Login/index.tsx
import React from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import { AuthStackParamList } from '../../../config/navigation';
import { FormInput } from '../../../components/forms/FormInput';
import { FormButton } from '../../../components/forms/FormButton';
import { useAuthContext } from '../../../components/providers/AuthProvider';
import { useForm } from '../../../hooks/useForm';
import { styles } from './styles';
import { email as emailValidator, required } from '../../../utils/validation';
import { BackButton } from '../../../components/common/BackButton';

type Props = NativeStackScreenProps<AuthStackParamList, 'Login'>;

interface LoginForm {
  email: string;
  password: string;
}

const initialValues: LoginForm = {
  email: '',
  password: ''
};

const validationRules = {
  email: [required('Email is required'), emailValidator()],
  password: [required('Password is required')]
};

export function LoginScreen({ navigation }: Props) {
  const { login } = useAuthContext();
  
  const {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleBlur,
    handleSubmit
  } = useForm<LoginForm>({
    initialValues,
    validationRules,
    onSubmit: async (formValues) => {
      console.log('Login form submitted:', formValues);
      try {
        await login(formValues.email, formValues.password);
        console.log('Login successful');
      } catch (error) {
        console.error('Login error in screen:', error);
        Alert.alert(
          'Login Error',
          error instanceof Error
            ? error.message
            : 'An error occurred during login'
        );
      }
    }
  });

  return (
    <SafeAreaView style={styles.container}>
      <BackButton />
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardView}
      >
        <ScrollView contentContainerStyle={styles.scrollContent}>
          <View style={styles.header}>
            <Text style={styles.title}>Welcome Back!</Text>
            <Text style={styles.subtitle}>Sign in to continue</Text>
          </View>
          <View style={styles.form}>
            <FormInput
              label="Email"
              value={values.email}
              onChangeText={handleChange('email')}
              onBlur={handleBlur('email')}
              placeholder="Enter your email"
              autoCapitalize="none"
              autoComplete="email"
              keyboardType="email-address"
              error={touched.email ? errors.email : undefined}
              editable={!isSubmitting}
            />

            <FormInput
              label="Password"
              value={values.password}
              onChangeText={handleChange('password')}
              onBlur={handleBlur('password')}
              placeholder="Enter your password"
              secureTextEntry
              autoComplete="password"
              error={touched.password ? errors.password : undefined}
              editable={!isSubmitting}
            />

            <FormButton
              title="Login"
              onPress={() => handleSubmit()}
              loading={isSubmitting}
            />
          </View>

          <View style={styles.footer}>
            <Text style={styles.footerText}>Don't have an account? </Text>
            <TouchableOpacity 
              onPress={() => navigation.navigate('Signup')}
              disabled={isSubmitting}
            >
              <Text style={styles.footerLink}>Sign Up</Text>
            </TouchableOpacity>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}</document_content>
</document>
<document index="23">
<source>golf-tracker/src/screens/auth/Login/styles.ts</source>
<document_content>
// src/screens/auth/Login/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  keyboardView: {
    flex: 1,
  },
  scrollContent: {
    flexGrow: 1,
    padding: 20,
  },
  header: {
    marginTop: 40,
    marginBottom: 32,
    alignItems: 'center',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
  },
  form: {
    gap: 16,
    marginBottom: 24,
  },
  generalError: {
    color: '#ff3b30',
    textAlign: 'center',
    marginBottom: 16,
    backgroundColor: '#ffebeb',
    padding: 10,
    borderRadius: 8,
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginTop: 'auto',
    paddingVertical: 16,
  },
  footerText: {
    color: '#666',
  },
  footerLink: {
    color: '#2f95dc',
    fontWeight: '600',
  },
});</document_content>
</document>
<document index="24">
<source>golf-tracker/src/screens/rounds/AllRounds/index.tsx</source>
<document_content>
// src/screens/rounds/AllRounds/index.tsx
import React, { useState, useCallback, useEffect } from 'react';
import {
  View,
  Text,
  FlatList,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  RefreshControl
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useFocusEffect } from '@react-navigation/native';
import { NativeStackScreenProps } from '@react-navigation/native-stack';
import { MainStackParamList } from '../../../config/navigation';
import { Round } from 'shared';
import { useRounds } from '../../../hooks/useRounds';
import { ChevronDown, Calendar, Flag, Target, Watch } from 'lucide-react-native';
import { styles } from './styles';
import { BackButton } from '../../../components/common/BackButton';

type Props = NativeStackScreenProps<MainStackParamList, 'AllRounds'>;

type SortOption = 'date' | 'score' | 'differential';
type SortDirection = 'asc' | 'desc';

interface RoundCardProps {
  round: Round;
  onPress?: () => void;
}

function RoundCard({ round, onPress }: RoundCardProps) {
  return (
    <TouchableOpacity style={styles.roundCard} onPress={onPress}>
      <View style={styles.roundHeader}>
        <View>
          <Text style={styles.courseName}>
            {typeof round.course === 'object' ? round.course.name : 'Unknown Course'}
          </Text>
          <Text style={styles.roundDate}>
            {new Date(round.date).toLocaleDateString()}
          </Text>
        </View>
        <Text style={styles.roundScore}>{round.score}</Text>
      </View>
      
      <View style={styles.roundStats}>
        <View style={styles.statsRow}>
          <View style={styles.statItem}>
            <Watch size={16} color="#666" />
            <Text style={styles.statText}>
              Differential: {round.differential.toFixed(1)}
            </Text>
          </View>
          <View style={styles.statItem}>
            <Target size={16} color="#666" />
            <Text style={styles.statText}>
              {`FIR: ${round.fairways}`}
            </Text>
          </View>
        </View>
        <View style={styles.statsRow}>
          <View style={styles.statItem}>
            <Flag size={16} color="#666" />
            <Text style={styles.statText}>
              {`GIR: ${round.greens}`}
            </Text>
          </View>
          <View style={styles.statItem}>
            <Calendar size={16} color="#666" />
            <Text style={styles.statText}>
              {`Putts: ${round.putts}`}
            </Text>
          </View>
        </View>
      </View>

      {round.notes && (
        <Text style={styles.notes} numberOfLines={2}>
          {round.notes}
        </Text>
      )}
    </TouchableOpacity>
  );
}

export function AllRoundsScreen({ navigation }: Props) {
  const { rounds, loading, error, getUserRounds, deleteRound } = useRounds();
  const [refreshing, setRefreshing] = useState(false);
  const [sortBy, setSortBy] = useState<SortOption>('date');
  const [sortDirection, setSortDirection] = useState<SortDirection>('desc');
  const [showSortOptions, setShowSortOptions] = useState(false);

  // Load rounds when screen comes into focus
  useFocusEffect(
    useCallback(() => {
      console.log('AllRounds screen in focus - loading rounds');
      getUserRounds();
    }, [getUserRounds])
  );

  // Initial load
  useEffect(() => {
    console.log('AllRounds initial mount - loading rounds');
    getUserRounds();
  }, [getUserRounds]);

  const onRefresh = useCallback(async () => {
    setRefreshing(true);
    try {
      console.log('AllRounds pull-to-refresh - loading rounds');
      await getUserRounds();
    } finally {
      setRefreshing(false);
    }
  }, [getUserRounds]);

  const sortedRounds = [...rounds].sort((a, b) => {
    let comparison = 0;
    switch (sortBy) {
      case 'date':
        comparison = new Date(b.date).getTime() - new Date(a.date).getTime();
        break;
      case 'score':
        comparison = a.score - b.score;
        break;
      case 'differential':
        comparison = a.differential - b.differential;
        break;
    }
    return sortDirection === 'desc' ? comparison : -comparison;
  });

  const toggleSort = (option: SortOption) => {
    if (sortBy === option) {
      setSortDirection(prev => prev === 'asc' ? 'desc' : 'asc');
    } else {
      setSortBy(option);
      setSortDirection('asc');
    }
    setShowSortOptions(false);
  };

  const handleDeleteRound = (roundId: string) => {
    Alert.alert(
      'Delete Round',
      'Are you sure you want to delete this round?',
      [
        {
          text: 'Cancel',
          style: 'cancel'
        },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: async () => {
            try {
              await deleteRound(roundId);
              Alert.alert('Success', 'Round deleted successfully');
            } catch (error) {
              Alert.alert('Error', 'Failed to delete round');
            }
          }
        }
      ]
    );
  };

  if (loading && !refreshing) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#2f95dc" />
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <BackButton /> 
      <View style={styles.header}>
        <Text style={styles.title}>Rounds History</Text>
        <TouchableOpacity 
          style={styles.sortButton}
          onPress={() => setShowSortOptions(!showSortOptions)}
        >
          <Text style={styles.sortButtonText}>
            Sort by {sortBy}
          </Text>
          <ChevronDown size={20} color="#2f95dc" />
        </TouchableOpacity>
      </View>

      {showSortOptions && (
        <View style={styles.sortOptions}>
          <TouchableOpacity 
            style={styles.sortOption} 
            onPress={() => toggleSort('date')}
          >
            <Text style={[
              styles.sortOptionText,
              sortBy === 'date' && styles.selectedSortOption
            ]}>Date</Text>
          </TouchableOpacity>
          <TouchableOpacity 
            style={styles.sortOption} 
            onPress={() => toggleSort('score')}
          >
            <Text style={[
              styles.sortOptionText,
              sortBy === 'score' && styles.selectedSortOption
            ]}>Score</Text>
          </TouchableOpacity>
          <TouchableOpacity 
            style={styles.sortOption} 
            onPress={() => toggleSort('differential')}
          >
            <Text style={[
              styles.sortOptionText,
              sortBy === 'differential' && styles.selectedSortOption
            ]}>Differential</Text>
          </TouchableOpacity>
        </View>
      )}

      <FlatList
        data={sortedRounds}
        renderItem={({ item }) => (
          <RoundCard 
            round={item}
            onPress={() => handleDeleteRound(item._id)}
          />
        )}
        keyExtractor={item => item._id}
        contentContainerStyle={styles.listContent}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
        }
        ListEmptyComponent={() => (
          <View style={styles.emptyContainer}>
            <Text style={styles.emptyText}>
              No rounds recorded yet.
            </Text>
            <TouchableOpacity
              style={styles.addButton}
              onPress={() => navigation.navigate('AddRound')}
            >
              <Text style={styles.addButtonText}>Add Your First Round</Text>
            </TouchableOpacity>
          </View>
        )}
      />
    </SafeAreaView>
  );
}</document_content>
</document>
<document index="25">
<source>golf-tracker/src/screens/rounds/AllRounds/styles.ts</source>
<document_content>
// src/screens/rounds/AllRounds/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
  },
  sortButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
  },
  sortButtonText: {
    color: '#2f95dc',
    fontSize: 16,
  },
  sortOptions: {
    backgroundColor: '#fff',
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
    padding: 8,
  },
  sortOption: {
    padding: 12,
  },
  sortOptionText: {
    fontSize: 16,
    color: '#666',
  },
  selectedSortOption: {
    color: '#2f95dc',
    fontWeight: '600',
  },
  listContent: {
    padding: 16,
    gap: 16,
  },
  roundCard: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  roundHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 12,
  },
  courseName: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 4,
  },
  roundDate: {
    fontSize: 14,
    color: '#666',
  },
  roundScore: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
  },
  statsRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 8,
  },
  statItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    minWidth: '45%',
  },
  statText: {
    fontSize: 14,
    color: '#666',
  },
  notes: {
    fontSize: 14,
    color: '#666',
    fontStyle: 'italic',
    borderTopWidth: 1,
    borderTopColor: '#eee',
    paddingTop: 12,
  },
  emptyContainer: {
    padding: 24,
    alignItems: 'center',
  },
  emptyText: {
    fontSize: 16,
    color: '#666',
    marginBottom: 16,
    textAlign: 'center',
  },
  addButton: {
    backgroundColor: '#2f95dc',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 8,
  },
  addButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
});</document_content>
</document>
<document index="26">
<source>golf-tracker/src/screens/rounds/AddRound/index.tsx</source>
<document_content>
// src/screens/rounds/AddRound/index.tsx
import React, { useState, useEffect, useContext } from 'react';
import { ScrollView, Alert, Modal, View, Text, Animated } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { NativeStackScreenProps } from '@react-navigation/native-stack';
import { MainStackParamList } from '../../../config/navigation';
import { useAuth } from '../../../hooks/useAuth';
import { useRounds } from '../../../hooks/useRounds';
import { useGoals } from '../../../hooks/useGoals';
import { GoalsContext } from '../../../components/providers/GoalsProvider';
import { Course } from 'shared';
import { CourseSearch } from '../../../components/course/CourseSearch';
import { RoundDetails } from '../../../components/round/RoundDetails';
import { styles } from './styles';
import { BackButton } from '../../../components/common/BackButton';
import { Award } from 'lucide-react-native';

type Props = NativeStackScreenProps<MainStackParamList, 'AddRound'>;

export function AddRoundScreen({ navigation }: Props) {
  const { user } = useAuth();
  const { createRound } = useRounds();
  const goalsContext = useContext(GoalsContext);
  const { newlyAchievedGoals, setNewlyAchievedGoals } = goalsContext || useGoals();
  
  // Course selection state
  const [selectedCourse, setSelectedCourse] = useState<Course | null>(null);
  const [selectedTee, setSelectedTee] = useState('');
  
  // Round details state
  const [date, setDate] = useState(new Date());
  const [score, setScore] = useState('');
  const [putts, setPutts] = useState('');
  const [fairways, setFairways] = useState('');
  const [greens, setGreens] = useState('');
  const [notes, setNotes] = useState('');
  
  // Form state
  const [loading, setLoading] = useState(false);
  const [errors, setErrors] = useState<{[key: string]: string}>({});
  
  // Celebration modal state
  const [showCelebration, setShowCelebration] = useState(false);
  const [celebrationScale] = useState(new Animated.Value(0));

  const validateForm = () => {
    const newErrors: {[key: string]: string} = {};
    
    if (!selectedCourse) {
      newErrors.course = 'Please select a course';
    }
    if (!selectedTee) {
      newErrors.tee = 'Please select tee';
    }
    if (!score) {
      newErrors.score = 'Score is required';
    } else if (isNaN(Number(score)) || Number(score) < 1) {
      newErrors.score = 'Please enter a valid score';
    }
    if (!putts) {
      newErrors.putts = 'Number of putts is required';
    } else if (isNaN(Number(putts)) || Number(putts) < 0) {
      newErrors.putts = 'Please enter a valid number of putts';
    }
    if (!fairways) {
      newErrors.fairways = 'Fairways hit is required';
    } else if (isNaN(Number(fairways)) || Number(fairways) < 0) {
      newErrors.fairways = 'Please enter a valid number of fairways';
    }
    if (!greens) {
      newErrors.greens = 'Greens hit is required';
    } else if (isNaN(Number(greens)) || Number(greens) < 0) {
      newErrors.greens = 'Please enter a valid number of greens';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Show achievement celebration
  const showAchievementCelebration = () => {
    setShowCelebration(true);
    Animated.sequence([
      Animated.timing(celebrationScale, {
        toValue: 1.2,
        duration: 300,
        useNativeDriver: true
      }),
      Animated.timing(celebrationScale, {
        toValue: 1,
        duration: 200,
        useNativeDriver: true
      })
    ]).start(() => {
      setTimeout(() => {
        setShowCelebration(false);
        celebrationScale.setValue(0);
        // Clear achievements after showing them
        setNewlyAchievedGoals([]);
        // Navigate back
        navigation.goBack();
      }, 3000);
    });
  };
  
  // Check for newly achieved goals after round submission
  useEffect(() => {
    if (newlyAchievedGoals && newlyAchievedGoals.length > 0) {
      console.log(`Found ${newlyAchievedGoals.length} newly achieved goals, showing celebration!`);
      showAchievementCelebration();
    }
  }, [newlyAchievedGoals]);

  const handleSubmit = async () => {
    if (!validateForm() || !user || !selectedCourse) return;

    setLoading(true);
    try {
      await createRound({
        course: selectedCourse,
        date: date.toISOString(),
        tees: selectedTee,
        score: Number(score),
        putts: Number(putts),
        fairways: Number(fairways),
        greens: Number(greens),
        notes: notes.trim() || undefined
      });

      // Check if we have newly achieved goals after adding round
      // We need to manually check since the goals may have been updated by the round
      if (goalsContext?.checkAndFindAchievedGoals) {
        const achievedGoals = goalsContext.checkAndFindAchievedGoals();
        console.log(`Checking goals after round submission, found ${achievedGoals.length} newly achieved goals`);
        
        if (achievedGoals.length > 0) {
          // Let the useEffect handle showing the celebration  
        } else {
          // No achievements, show regular success and navigate back
          Alert.alert(
            'Success',
            'Round added successfully',
            [{
              text: 'OK',
              onPress: () => navigation.goBack()
            }]
          );
        }
      } else {
        // Fallback if context is not available
        Alert.alert(
          'Success',
          'Round added successfully',
          [{
            text: 'OK',
            onPress: () => navigation.goBack()
          }]
        );
      }
    } catch (error) {
      console.error('Error submitting round:', error);
      Alert.alert(
        'Error',
        error instanceof Error 
          ? error.message 
          : 'Failed to add round. Please try again.'
      );
      setLoading(false);
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <BackButton/>
      <ScrollView contentContainerStyle={styles.content}>
        {!selectedCourse ? (
          <CourseSearch onSelect={setSelectedCourse} />
        ) : (
          <RoundDetails
            course={selectedCourse}
            selectedTee={selectedTee}
            onTeeSelect={setSelectedTee}
            date={date}
            onDateChange={setDate}
            score={score}
            onScoreChange={setScore}
            putts={putts}
            onPuttsChange={setPutts}
            fairways={fairways}
            onFairwaysChange={setFairways}
            greens={greens}
            onGreensChange={setGreens}
            notes={notes}
            onNotesChange={setNotes}
            errors={errors}
            loading={loading}
            onSubmit={handleSubmit}
            onChangeCourse={() => setSelectedCourse(null)}
          />
        )}
      </ScrollView>
      
      {/* Goal achievement celebration modal */}
      <Modal
        visible={showCelebration}
        transparent={true}
        animationType="fade"
      >
        <View style={styles.celebrationOverlay}>
          <Animated.View 
            style={[
              styles.celebrationContent,
              { transform: [{ scale: celebrationScale }] }
            ]}
          >
            <Award size={60} color="#4CAF50" />
            <Text style={styles.celebrationTitle}>Goal Achieved!</Text>
            
            {newlyAchievedGoals.length === 1 ? (
              <Text style={styles.celebrationText}>
                Congratulations! You've achieved your goal:
              </Text>
            ) : (
              <Text style={styles.celebrationText}>
                Congratulations! You've achieved multiple goals:
              </Text>
            )}
            
            <View style={styles.goalsList}>
              {newlyAchievedGoals.map(goal => (
                <View key={goal._id} style={styles.goalItem}>
                  <Award size={16} color="#4CAF50" />
                  <Text style={styles.goalItemText}>{goal.name}</Text>
                </View>
              ))}
            </View>
          </Animated.View>
        </View>
      </Modal>
    </SafeAreaView>
  );
}</document_content>
</document>
<document index="27">
<source>golf-tracker/src/screens/rounds/AddRound/styles.ts</source>
<document_content>
// src/screens/rounds/AddRound/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  content: {
    flexGrow: 1,
  },
  celebrationOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  celebrationContent: {
    backgroundColor: '#fff',
    borderRadius: 16,
    padding: 24,
    alignItems: 'center',
    width: '80%',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    elevation: 5,
  },
  celebrationTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#4CAF50',
    marginVertical: 12,
  },
  celebrationText: {
    fontSize: 16,
    textAlign: 'center',
    color: '#555',
    marginBottom: 8,
  },
  goalsList: {
    width: '100%',
    marginTop: 12,
  },
  goalItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f0f8f0',
    borderRadius: 8,
    padding: 12,
    marginBottom: 8,
  },
  goalItemText: {
    flex: 1,
    fontSize: 14,
    fontWeight: '500',
    color: '#4CAF50',
    marginLeft: 8,
  }
});</document_content>
</document>
<document index="28">
<source>golf-tracker/src/components/course/CourseSearch/index.tsx</source>
<document_content>
// src/components/course/CourseSearch/index.tsx
import React, { useState, useCallback } from 'react';
import { 
  View, 
  Text, 
  TouchableOpacity, 
  TextInput, 
  ActivityIndicator 
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { Search as SearchIcon, PlusCircle as PlusCircleIcon } from 'lucide-react-native';
import { Course } from 'shared';
import { useCourses } from '../../../hooks/useCourses';
import { debounce } from 'lodash';
import { styles } from './styles';
import { MainStackParamList } from '../../../config/navigation';

interface CourseSearchProps {
  onSelect: (course: Course) => void;
}

type NavigationProp = NativeStackNavigationProp<MainStackParamList>;

function NoResults() {
  const navigation = useNavigation<NavigationProp>();
  return (
    <View style={styles.noResultsContainer}>
      <Text style={styles.noResultsText}>No courses found</Text>
      <TouchableOpacity 
        style={styles.addButton} 
        onPress={() => navigation.navigate('AddCourse')}
      >
        <PlusCircleIcon size={20} color="#2f95dc" />
        <Text style={styles.addButtonText}>Add New Course</Text>
      </TouchableOpacity>
    </View>
  );
}

function CourseList({ courses, onSelect }: { courses: Course[], onSelect: (course: Course) => void }) {
  return (
    <View style={styles.resultsContainer}>
      {courses.map((course) => (
        <TouchableOpacity
          key={course._id}
          style={styles.courseItem}
          onPress={() => onSelect(course)}
        >
          <Text style={styles.courseName}>{course.name}</Text>
          {course.location.city && (
            <Text style={styles.courseLocation}>
              {[course.location.city, course.location.state]
                .filter(Boolean)
                .join(', ')}
            </Text>
          )}
        </TouchableOpacity>
      ))}
    </View>
  );
}

export function CourseSearch({ onSelect }: CourseSearchProps) {
  const { courses, loading, error, searchCourses } = useCourses();
  const [query, setQuery] = useState('');
  
  const debouncedSearch = useCallback(
    debounce(async (searchQuery: string) => {
      if (searchQuery.trim().length < 2) {
        return;
      }
      await searchCourses(searchQuery);
    }, 300),
    []
  );

  const handleQueryChange = (text: string) => {
    setQuery(text);
    debouncedSearch(text);
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Find a Course</Text>

      <View style={styles.searchContainer}>
        <SearchIcon size={20} color="#666" />
        <TextInput
          style={styles.searchInput}
          value={query}
          onChangeText={handleQueryChange}
          placeholder="Search for a course"
          placeholderTextColor="#999"
          autoCapitalize="words"
        />
      </View>

      {loading && (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#2f95dc" />
        </View>
      )}

      {!loading && courses.length > 0 && (
        <CourseList courses={courses} onSelect={onSelect} />
      )}

      {!loading && query.length >= 2 && courses.length === 0 && (
        <NoResults />
      )}

      {error && (
        <Text style={styles.errorText}>
          Error searching courses. Please try again.
        </Text>
      )}
    </View>
  );
}</document_content>
</document>
<document index="29">
<source>golf-tracker/src/components/course/CourseSearch/styles.ts</source>
<document_content>
// src/components/course/CourseSearch/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    padding: 16,
    gap: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    paddingHorizontal: 12,
    height: 48,
    gap: 8,
  },
  searchInput: {
    flex: 1,
    fontSize: 16,
    color: '#333',
  },
  loadingContainer: {
    padding: 20,
    alignItems: 'center',
  },
  resultsContainer: {
    gap: 8,
  },
  courseItem: {
    backgroundColor: '#fff',
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#eee',
  },
  courseName: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 4,
  },
  courseLocation: {
    fontSize: 14,
    color: '#666',
  },
  noResultsContainer: {
    padding: 20,
    alignItems: 'center',
    backgroundColor: '#fff',
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#eee',
  },
  noResultsText: {
    fontSize: 16,
    color: '#666',
    marginBottom: 12,
  },
  addButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    padding: 8,
  },
  addButtonText: {
    color: '#2f95dc',
    fontSize: 16,
    fontWeight: '500',
  },
  errorText: {
    color: '#dc3545',
    textAlign: 'center',
    padding: 12,
  },
});</document_content>
</document>
<document index="30">
<source>golf-tracker/src/components/course/TeeSelector/index.tsx</source>
<document_content>
// src/components/course/TeeSelector/index.tsx
import React, { useState } from 'react';
import { 
  View, 
  Text, 
  TouchableOpacity, 
  Modal, 
  Alert 
} from 'react-native';
import { ChevronDown, Plus } from 'lucide-react-native';
import { Course } from 'shared';
import { FormInput } from '../../forms/FormInput';
import { FormButton } from '../../forms/FormButton';
import { useCourses } from '../../../hooks/useCourses';
import { styles } from './styles';

interface TeeSelectorProps {
  course: Course;
  selectedTee: string;
  onTeeSelect: (tee: string) => void;
  error?: string;
}

interface AddTeeFormData {
  name: string;
  rating: string;
  slope: string;
  numberOfFairways: string;
}

export function TeeSelector({
  course,
  selectedTee,
  onTeeSelect,
  error
}: TeeSelectorProps) {
  const { addTeeToCourse } = useCourses();
  const [isOpen, setIsOpen] = useState(false);
  const [showAddModal, setShowAddModal] = useState(false);
  const [loading, setLoading] = useState(false);
  const [formData, setFormData] = useState<AddTeeFormData>({
    name: '',
    rating: '',
    slope: '',
    numberOfFairways: ''
  });
  const [formErrors, setFormErrors] = useState<Partial<AddTeeFormData>>({});

  const handleOpenDropdown = () => {
    if (course.tees.length === 0) {
      setShowAddModal(true);
    } else {
      setIsOpen(!isOpen);
    }
  };

  const validateTeeForm = (): boolean => {
    const errors: Partial<AddTeeFormData> = {};
    
    if (!formData.name.trim()) {
      errors.name = 'Tee name is required';
    }
    
    if (!formData.rating) {
      errors.rating = 'Course rating is required';
    } else if (isNaN(Number(formData.rating)) || Number(formData.rating) < 60 || Number(formData.rating) > 80) {
      errors.rating = 'Rating must be between 60 and 80';
    }
    
    if (!formData.slope) {
      errors.slope = 'Slope rating is required';
    } else if (isNaN(Number(formData.slope)) || Number(formData.slope) < 55 || Number(formData.slope) > 155) {
      errors.slope = 'Slope must be between 55 and 155';
    }
    
    if (!formData.numberOfFairways) {
      errors.numberOfFairways = 'Number of fairways is required';
    } else if (isNaN(Number(formData.numberOfFairways)) || Number(formData.numberOfFairways) < 0 || Number(formData.numberOfFairways) > 18) {
      errors.numberOfFairways = 'Must be between 0 and 18';
    }

    setFormErrors(errors);
    return Object.keys(errors).length === 0;
  };

  const handleAddTee = async () => {
    if (!validateTeeForm()) return;
    
    setLoading(true);
    try {
      await addTeeToCourse(course._id, {
        name: formData.name.trim(),
        rating: Number(formData.rating),
        slope: Number(formData.slope),
        numberOfFairways: Number(formData.numberOfFairways)
      });
      
      setShowAddModal(false);
      onTeeSelect(formData.name.trim());
      
      // Reset form
      setFormData({
        name: '',
        rating: '',
        slope: '',
        numberOfFairways: ''
      });
      setFormErrors({});
    } catch (error) {
      Alert.alert(
        'Error',
        error instanceof Error ? error.message : 'Failed to add tee'
      );
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.label}>Select Tee</Text>

      <TouchableOpacity
        style={[styles.dropdown, error && styles.dropdownError]}
        onPress={handleOpenDropdown}
      >
        <Text style={[
          styles.dropdownText,
          !selectedTee && styles.placeholderText
        ]}>
          {selectedTee || "Select a tee"}
        </Text>
        <ChevronDown size={20} color="#666" />
      </TouchableOpacity>

      {error && <Text style={styles.errorText}>{error}</Text>}

      {isOpen && (
        <View style={styles.dropdownMenu}>
          {course.tees.map((tee) => (
            <TouchableOpacity
              key={tee.name}
              style={styles.dropdownItem}
              onPress={() => {
                onTeeSelect(tee.name);
                setIsOpen(false);
              }}
            >
              <Text style={[
                styles.dropdownItemText,
                selectedTee === tee.name && styles.selectedItemText
              ]}>
                {tee.name}
              </Text>
              <Text style={styles.teeDetails}>
                {`${tee.rating} / ${tee.slope}`}
              </Text>
            </TouchableOpacity>
          ))}

          <TouchableOpacity
            style={styles.addButton}
            onPress={() => {
              setIsOpen(false);
              setShowAddModal(true);
            }}
          >
            <Plus size={20} color="#2f95dc" />
            <Text style={styles.addButtonText}>Add New Tee</Text>
          </TouchableOpacity>
        </View>
      )}

      <Modal
        visible={showAddModal}
        animationType="slide"
        transparent
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Add New Tee</Text>

            <FormInput
              label="Tee Color/Name"
              value={formData.name}
              onChangeText={(text) => setFormData(prev => ({ ...prev, name: text }))}
              placeholder="e.g., Blue"
              error={formErrors.name}
              editable={!loading}
            />

            <FormInput
              label="Course Rating"
              value={formData.rating}
              onChangeText={(text) => setFormData(prev => ({ ...prev, rating: text }))}
              placeholder="e.g., 72.1"
              keyboardType="decimal-pad"
              error={formErrors.rating}
              editable={!loading}
            />

            <FormInput
              label="Slope Rating"
              value={formData.slope}
              onChangeText={(text) => setFormData(prev => ({ ...prev, slope: text }))}
              placeholder="e.g., 125"
              keyboardType="numeric"
              error={formErrors.slope}
              editable={!loading}
            />

            <FormInput
              label="Number of Fairways"
              value={formData.numberOfFairways}
              onChangeText={(text) => setFormData(prev => ({ ...prev, numberOfFairways: text }))}
              placeholder="e.g., 14"
              keyboardType="numeric"
              error={formErrors.numberOfFairways}
              editable={!loading}
            />

            <View style={styles.modalButtons}>
              <FormButton
                title="Cancel"
                onPress={() => setShowAddModal(false)}
                variant="secondary"
                loading={loading}
                style={styles.modalButton}
              />
              <FormButton
                title="Add Tee"
                onPress={handleAddTee}
                loading={loading}
                style={styles.modalButton}
              />
            </View>
          </View>
        </View>
      </Modal>
    </View>
  );
}</document_content>
</document>
<document index="31">
<source>golf-tracker/src/components/course/TeeSelector/styles.ts</source>
<document_content>
// src/components/course/TeeSelector/styles.ts
import { StyleSheet, Platform } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    marginBottom: 24,
  },
  label: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
  },
  dropdown: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    height: 48,
    paddingHorizontal: 16,
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    backgroundColor: '#fff',
  },
  dropdownError: {
    borderColor: '#dc3545',
  },
  dropdownText: {
    fontSize: 16,
    color: '#333',
  },
  placeholderText: {
    color: '#999',
  },
  errorText: {
    color: '#dc3545',
    fontSize: 14,
    marginTop: 4,
  },
  dropdownMenu: {
    marginTop: 4,
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    backgroundColor: '#fff',
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
      },
      android: {
        elevation: 3,
      },
    }),
  },
  dropdownItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  dropdownItemText: {
    fontSize: 16,
    color: '#333',
  },
  selectedItemText: {
    color: '#2f95dc',
    fontWeight: '600',
  },
  teeDetails: {
    fontSize: 14,
    color: '#666',
  },
  addButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 12,
    gap: 8,
  },
  addButtonText: {
    color: '#2f95dc',
    fontSize: 16,
    fontWeight: '500',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 20,
    width: '90%',
    maxWidth: 400,
    gap: 16,
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    gap: 12,
  },
  modalButton: {
    flex: 1,
  },
});</document_content>
</document>
<document index="32">
<source>golf-tracker/src/components/forms/FormInput/index.tsx</source>
<document_content>
// src/components/forms/FormInput/index.tsx
import React, { useState } from 'react';
import { 
  View, 
  Text, 
  TextInput, 
  TextInputProps,
  TouchableOpacity,
  ViewStyle,
} from 'react-native';
import { Eye, EyeOff } from 'lucide-react-native';
import { styles } from './styles';

interface FormInputProps extends TextInputProps {
  label?: string;
  error?: string;
  helper?: string;
  containerStyle?: ViewStyle;
  required?: boolean;
  showPasswordToggle?: boolean;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
}

export function FormInput({
  label,
  error,
  helper,
  containerStyle,
  required = false,
  showPasswordToggle = false,
  leftIcon,
  rightIcon,
  secureTextEntry,
  style,
  ...props
}: FormInputProps) {
  const [isPasswordVisible, setIsPasswordVisible] = useState(false);

  const togglePasswordVisibility = () => {
    setIsPasswordVisible(!isPasswordVisible);
  };

  const renderLeftIcon = () => {
    if (!leftIcon) return null;
    return <View style={styles.leftIcon}>{leftIcon}</View>;
  };

  const renderRightIcon = () => {
    if (showPasswordToggle) {
      return (
        <TouchableOpacity 
          style={styles.rightIcon}
          onPress={togglePasswordVisibility}
        >
          {isPasswordVisible ? (
            <EyeOff size={20} color="#666" />
          ) : (
            <Eye size={20} color="#666" />
          )}
        </TouchableOpacity>
      );
    }
    if (!rightIcon) return null;
    return <View style={styles.rightIcon}>{rightIcon}</View>;
  };

  return (
    <View style={[styles.container, containerStyle]}>
      {label && (
        <View style={styles.labelContainer}>
          <Text style={styles.label}>{label}</Text>
          {required && <Text style={styles.required}>*</Text>}
        </View>
      )}
      
      <View style={styles.inputWrapper}>
        {renderLeftIcon()}
        <TextInput
          style={[
            styles.input,
            leftIcon && styles.inputWithLeftIcon,
            (rightIcon || showPasswordToggle) && styles.inputWithRightIcon,
            error && styles.inputError,
            style,
          ]}
          placeholderTextColor="#999"
          secureTextEntry={showPasswordToggle ? !isPasswordVisible : secureTextEntry}
          {...props}
        />
        {renderRightIcon()}
      </View>

      {(error || helper) && (
        <Text style={[styles.helperText, error && styles.errorText]}>
          {error || helper}
        </Text>
      )}
    </View>
  );
}</document_content>
</document>
<document index="33">
<source>golf-tracker/src/components/forms/FormInput/styles.ts</source>
<document_content>
// src/components/forms/FormInput/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    marginBottom: 16,
  },
  labelContainer: {
    flexDirection: 'row',
    marginBottom: 8,
  },
  label: {
    fontSize: 16,
    color: '#333',
    fontWeight: '600',
  },
  required: {
    color: '#ff3b30',
    marginLeft: 4,
  },
  inputWrapper: {
    position: 'relative',
    flexDirection: 'row',
    alignItems: 'center',
  },
  input: {
    flex: 1,
    height: 48,
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    paddingHorizontal: 16,
    fontSize: 16,
    backgroundColor: '#fff',
    color: '#333',
  },
  inputWithLeftIcon: {
    paddingLeft: 48,
  },
  inputWithRightIcon: {
    paddingRight: 48,
  },
  inputError: {
    borderColor: '#ff3b30',
  },
  leftIcon: {
    position: 'absolute',
    left: 16,
    zIndex: 1,
  },
  rightIcon: {
    position: 'absolute',
    right: 16,
    zIndex: 1,
  },
  helperText: {
    fontSize: 14,
    color: '#666',
    marginTop: 4,
  },
  errorText: {
    color: '#ff3b30',
  },
});</document_content>
</document>
<document index="34">
<source>golf-tracker/src/components/forms/FormButton/index.tsx</source>
<document_content>
// src/components/forms/FormButton/index.tsx
import React from 'react';
import { 
  TouchableOpacity, 
  Text, 
  ActivityIndicator,
  ViewStyle,
  TextStyle,
  View,
} from 'react-native';
import { styles } from './styles';

export type ButtonVariant = 'primary' | 'secondary' | 'outline' | 'danger';
export type ButtonSize = 'small' | 'medium' | 'large';

interface FormButtonProps {
  title: string;
  onPress: () => void;
  variant?: ButtonVariant;
  size?: ButtonSize;
  loading?: boolean;
  disabled?: boolean;
  fullWidth?: boolean;
  style?: ViewStyle;
  textStyle?: TextStyle;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
}

export function FormButton({ 
  title, 
  onPress, 
  variant = 'primary',
  size = 'medium',
  loading = false,
  disabled = false,
  fullWidth = false,
  style,
  textStyle,
  leftIcon,
  rightIcon,
}: FormButtonProps) {
  const getButtonStyle = () => {
    const buttonStyles = [
      styles.button,
      styles[`button${size.charAt(0).toUpperCase()}${size.slice(1)}`],
      styles[`button${variant.charAt(0).toUpperCase()}${variant.slice(1)}`],
      fullWidth && styles.buttonFullWidth,
      (disabled || loading) && styles.buttonDisabled,
      style,
    ];
    
    return buttonStyles;
  };

  const getTextStyle = () => {
    const textStyles = [
      styles.buttonText,
      styles[`text${variant.charAt(0).toUpperCase()}${variant.slice(1)}`],
      styles[`text${size.charAt(0).toUpperCase()}${size.slice(1)}`],
      disabled && styles.textDisabled,
      textStyle,
    ];
    
    return textStyles;
  };

  return (
    <TouchableOpacity
      style={getButtonStyle()}
      onPress={onPress}
      disabled={disabled || loading}
      activeOpacity={0.7}
    >
      {loading ? (
        <ActivityIndicator 
          color={variant === 'primary' ? '#fff' : '#2f95dc'} 
          size={size === 'small' ? 'small' : 'small'}
        />
      ) : (
        <React.Fragment>
          {leftIcon && <View style={styles.iconLeft}>{leftIcon}</View>}
          <Text style={getTextStyle()}>{title}</Text>
          {rightIcon && <View style={styles.iconRight}>{rightIcon}</View>}
        </React.Fragment>
      )}
    </TouchableOpacity>
  );
}</document_content>
</document>
<document index="35">
<source>golf-tracker/src/components/forms/FormButton/styles.ts</source>
<document_content>
// src/components/forms/FormButton/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  button: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: 8,
  },
  buttonFullWidth: {
    width: '100%',
  },
  buttonDisabled: {
    opacity: 0.6,
  },

  // Size variations
  buttonSmall: {
    height: 36,
    paddingHorizontal: 16,
  },
  buttonMedium: {
    height: 48,
    paddingHorizontal: 24,
  },
  buttonLarge: {
    height: 56,
    paddingHorizontal: 32,
  },

  // Variant styles
  buttonPrimary: {
    backgroundColor: '#2f95dc',
  },
  buttonSecondary: {
    backgroundColor: '#f5f5f5',
  },
  buttonOutline: {
    backgroundColor: 'transparent',
    borderWidth: 2,
    borderColor: '#2f95dc',
  },
  buttonDanger: {
    backgroundColor: '#ff3b30',
  },

  // Text base style
  buttonText: {
    fontSize: 16,
    fontWeight: '600',
    textAlign: 'center',
  },

  // Text size variations
  textSmall: {
    fontSize: 14,
  },
  textMedium: {
    fontSize: 16,
  },
  textLarge: {
    fontSize: 18,
  },

  // Text variant styles
  textPrimary: {
    color: '#fff',
  },
  textSecondary: {
    color: '#333',
  },
  textOutline: {
    color: '#2f95dc',
  },
  textDanger: {
    color: '#fff',
  },
  textDisabled: {
    color: '#999',
  },

  // Icon styles
  iconLeft: {
    marginRight: 8,
  },
  iconRight: {
    marginLeft: 8,
  },
});</document_content>
</document>
<document index="36">
<source>golf-tracker/src/components/layout/AuthLayout/index.tsx</source>
<document_content>
// src/components/layout/AuthLayout/index.tsx
import React from 'react';
import {
  View,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  SafeAreaView,
  StatusBar,
  ViewStyle,
} from 'react-native';
import { ErrorBoundary } from '../../common/ErrorBoundary';
import { styles } from './styles';

interface AuthLayoutProps {
  children: React.ReactNode;
  contentContainerStyle?: ViewStyle;
  scrollEnabled?: boolean;
  showStatusBar?: boolean;
}

export function AuthLayout({
  children,
  contentContainerStyle,
  scrollEnabled = true,
  showStatusBar = true,
}: AuthLayoutProps) {
  return (
    <ErrorBoundary>
      <SafeAreaView style={styles.container}>
        {showStatusBar && (
          <StatusBar
            barStyle="dark-content"
            backgroundColor="#fff"
            animated={true}
          />
        )}
        
        <KeyboardAvoidingView
          style={styles.keyboardView}
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          keyboardVerticalOffset={Platform.OS === 'ios' ? 0 : 20}
        >
          {scrollEnabled ? (
            <ScrollView
              style={styles.scrollView}
              contentContainerStyle={[
                styles.scrollContent,
                contentContainerStyle,
              ]}
              keyboardShouldPersistTaps="handled"
              showsVerticalScrollIndicator={false}
            >
              {children}
            </ScrollView>
          ) : (
            <View style={[styles.content, contentContainerStyle]}>
              {children}
            </View>
          )}
        </KeyboardAvoidingView>
      </SafeAreaView>
    </ErrorBoundary>
  );
}
</document_content>
</document>
<document index="37">
<source>golf-tracker/src/components/layout/AuthLayout/styles.ts</source>
<document_content>
// src/components/layout/AuthLayout/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  keyboardView: {
    flex: 1,
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    flexGrow: 1,
    padding: 20,
  },
  content: {
    flex: 1,
    padding: 20,
  },
});</document_content>
</document>
<document index="38">
<source>golf-tracker/src/components/layout/MainLayout/index.tsx</source>
<document_content>
// src/components/layout/MainLayout/index.tsx
import React from 'react';
import {
  View,
  SafeAreaView,
  StatusBar,
  ViewStyle,
  ScrollView,
  RefreshControl,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { ErrorBoundary } from '../../common/ErrorBoundary';
import { BackButton } from '../../common/BackButton';
import { styles } from './styles';

interface MainLayoutProps {
  children: React.ReactNode;
  title?: string;
  showBack?: boolean;
  showHeader?: boolean;
  contentContainerStyle?: ViewStyle;
  headerRight?: React.ReactNode;
  scrollEnabled?: boolean;
  refreshing?: boolean;
  onRefresh?: () => void;
  headerStyle?: ViewStyle;
}

export function MainLayout({
  children,
  showBack = false,
  showHeader = true,
  contentContainerStyle,
  headerRight,
  scrollEnabled = true,
  refreshing = false,
  onRefresh,
  headerStyle,
}: MainLayoutProps) {
  const renderHeader = () => {
    if (!showHeader) return null;

    return (
      <View style={[styles.header, headerStyle]}>
        <View style={styles.headerLeft}>
          {showBack && <BackButton />}
        </View>
        <View style={styles.headerRight}>
          {headerRight}
        </View>
      </View>
    );
  };

  const renderContent = () => {
    if (!scrollEnabled) {
      return (
        <View style={[styles.content, contentContainerStyle]}>
          {children}
        </View>
      );
    }

    return (
      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={[styles.scrollContent, contentContainerStyle]}
        keyboardShouldPersistTaps="handled"
        showsVerticalScrollIndicator={false}
        refreshControl={
          onRefresh ? (
            <RefreshControl
              refreshing={refreshing}
              onRefresh={onRefresh}
              tintColor="#2f95dc"
              colors={['#2f95dc']}
            />
          ) : undefined
        }
      >
        {children}
      </ScrollView>
    );
  };

  return (
    <ErrorBoundary>
      <SafeAreaView style={styles.container}>
        <StatusBar
          barStyle="dark-content"
          backgroundColor="#fff"
          animated={true}
        />
        
        {renderHeader()}

        <KeyboardAvoidingView
          style={styles.keyboardView}
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          keyboardVerticalOffset={Platform.OS === 'ios' ? 0 : 20}
        >
          {renderContent()}
        </KeyboardAvoidingView>
      </SafeAreaView>
    </ErrorBoundary>
  );
}</document_content>
</document>
<document index="39">
<source>golf-tracker/src/components/layout/MainLayout/styles.ts</source>
<document_content>
// src/components/layout/MainLayout/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  keyboardView: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
    backgroundColor: '#fff',
    minHeight: 56,
  },
  headerLeft: {
    flex: 1,
  },
  headerRight: {
    flex: 1,
    alignItems: 'flex-end',
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    flexGrow: 1,
    padding: 16,
  },
  content: {
    flex: 1,
    padding: 16,
  },
});</document_content>
</document>
<document index="40">
<source>golf-tracker/src/components/providers/AuthProvider.tsx</source>
<document_content>
// src/components/providers/AuthProvider.tsx
import React, { createContext, useContext, useState, useEffect } from 'react';
import { User, CreateUserInput, Goal } from 'shared';
import { authService } from '../../services/api/auth';
import { secureStorage, STORAGE_KEYS } from '../../services/storage/secureStorage';

interface AuthContextType {
  user: User | null;
  loading: boolean;
  error: string | null;
  goals: Goal[]; // Add goals to the context
  activeGoals: Goal[]; // Filtered active goals
  completedGoals: Goal[]; // Filtered completed goals
  login: (email: string, password: string) => Promise<void>;
  signup: (userData: CreateUserInput) => Promise<void>;
  logout: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [goals, setGoals] = useState<Goal[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Computed properties for goals
  const activeGoals = goals.filter(goal => !goal.achieved);
  const completedGoals = goals.filter(goal => goal.achieved);

  useEffect(() => {
    checkAuthStatus();
  }, []);

  const checkAuthStatus = async () => {
    try {
      setLoading(true);
      const token = await secureStorage.retrieve<string>(STORAGE_KEYS.AUTH_TOKEN);
      
      if (!token) {
        setUser(null);
        setGoals([]);
        setLoading(false);
        return;
      }

      const validatedUser = await authService.validateToken(token);
      if (validatedUser) {
        console.log('Setting validated user:', validatedUser);
        setUser(validatedUser);
        
        // Set goals if they exist in the user object
        if (validatedUser.goals) {
          console.log('Setting goals from auth:', validatedUser.goals);
          setGoals(validatedUser.goals);
        }
      } else {
        await secureStorage.remove(STORAGE_KEYS.AUTH_TOKEN);
        setUser(null);
        setGoals([]);
      }
    } catch (error) {
      console.error('Error checking auth status:', error);
      setError('Failed to check authentication status');
      setUser(null);
      setGoals([]);
    } finally {
      setLoading(false);
    }
  };

  const login = async (email: string, password: string) => {
    try {
      setLoading(true);
      setError(null);
      
      const { user, token } = await authService.login(email, password);
      console.log('Login response:', { user, token });
      
      if (token) {
        await secureStorage.store(STORAGE_KEYS.AUTH_TOKEN, token);
      }
      
      if (user) {
        console.log('Setting user state:', user);
        setUser(user);
        
        // Set goals if they exist in the user object
        if (user.goals) {
          console.log('Setting goals from login:', user.goals);
          setGoals(user.goals);
        }
      }
    } catch (error) {
      console.error('Login error:', error);
      setError(error instanceof Error ? error.message : 'Failed to login');
      throw error;
    } finally {
      setLoading(false);
    }
  };

  const signup = async (userData: CreateUserInput) => {
    try {
      setLoading(true);
      setError(null);
      
      const { user, token } = await authService.signup(userData);
      
      if (token) {
        await secureStorage.store(STORAGE_KEYS.AUTH_TOKEN, token);
      }
      
      if (user) {
        setUser(user);
        
        // Initialize empty goals for new user
        setGoals(user.goals || []);
      }
    } catch (error) {
      console.error('Signup error:', error);
      setError(error instanceof Error ? error.message : 'Failed to create account');
      throw error;
    } finally {
      setLoading(false);
    }
  };

  const logout = async () => {
    try {
      setLoading(true);
      setError(null);
      
      await authService.logout();
      await secureStorage.remove(STORAGE_KEYS.AUTH_TOKEN);
      
      setUser(null);
      setGoals([]);
    } catch (error) {
      console.error('Logout error:', error);
      setError(error instanceof Error ? error.message : 'Failed to logout');
      throw error;
    } finally {
      setLoading(false);
    }
  };

  const value = {
    user,
    loading,
    error,
    goals,
    activeGoals,
    completedGoals,
    login,
    signup,
    logout
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuthContext() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuthContext must be used within an AuthProvider');
  }
  return context;
}</document_content>
</document>
<document index="41">
<source>golf-tracker/src/components/providers/GoalsProvider.tsx</source>
<document_content>
// src/components/providers/GoalsProvider.tsx
import React, { createContext, useState, useEffect, useCallback } from 'react';
import { Goal } from 'shared';
import { useGoals } from '../../hooks/useGoals';

interface GoalsContextType {
  activeGoals: Goal[];
  completedGoals: Goal[];
  newlyAchievedGoals: Goal[];
  setNewlyAchievedGoals: (goals: Goal[]) => void;
  checkAndFindAchievedGoals: () => Goal[];
}

export const GoalsContext = createContext<GoalsContextType | undefined>(undefined);

export function GoalsProvider({ children }: { children: React.ReactNode }) {
  // This acts as a wrapper around useGoals to make goal checking available globally
  // But prevents circular dependencies
  const {
    activeGoals,
    completedGoals,
    newlyAchievedGoals,
    setNewlyAchievedGoals,
    checkAndFindAchievedGoals,
  } = useGoals();

  // Make the goals checking and achievement available via context
  const value = {
    activeGoals,
    completedGoals,
    newlyAchievedGoals,
    setNewlyAchievedGoals,
    checkAndFindAchievedGoals,
  };

  return (
    <GoalsContext.Provider value={value}>
      {children}
    </GoalsContext.Provider>
  );
}</document_content>
</document>
<document index="42">
<source>golf-tracker/src/components/providers/CourseProvider.tsx</source>
<document_content>
// Optional: Create a context provider for app-wide course state
import React, { createContext, useContext } from 'react';
import { useCourses } from '../../hooks/useCourses';

const CoursesContext = createContext<ReturnType<typeof useCourses> | undefined>(undefined);

export function CoursesProvider({ children }: { children: React.ReactNode }) {
  const courses = useCourses();
  return <CoursesContext.Provider value={courses}>{children}</CoursesContext.Provider>;
}

export function useCoursesContext() {
  const context = useContext(CoursesContext);
  if (context === undefined) {
    throw new Error('useCoursesContext must be used within a CoursesProvider');
  }
  return context;
}</document_content>
</document>
<document index="43">
<source>golf-tracker/src/components/common/ErrorBoundary/index.tsx</source>
<document_content>
// src/components/common/ErrorBoundary/index.tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { View, Text, TouchableOpacity } from 'react-native';
import { styles } from './styles';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
  onReset?: () => void;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = {
      hasError: false,
      error: null
    };
  }

  static getDerivedStateFromError(error: Error): State {
    return {
      hasError: true,
      error
    };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // Log error to your error reporting service
    console.error('ErrorBoundary caught an error:', error, errorInfo);
  }

  handleReset = () => {
    this.setState({
      hasError: false,
      error: null
    });
    
    this.props.onReset?.();
  };

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <View style={styles.container}>
          <Text style={styles.title}>Oops! Something went wrong</Text>
          <Text style={styles.message}>
            {this.state.error?.message || 'An unexpected error occurred'}
          </Text>
          <TouchableOpacity 
            style={styles.button}
            onPress={this.handleReset}
          >
            <Text style={styles.buttonText}>Try Again</Text>
          </TouchableOpacity>
        </View>
      );
    }

    return this.props.children;
  }
}</document_content>
</document>
<document index="44">
<source>golf-tracker/src/components/common/ErrorBoundary/styles.ts</source>
<document_content>
// src/components/common/ErrorBoundary/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 12,
  },
  message: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginBottom: 24,
  },
  button: {
    backgroundColor: '#2f95dc',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 8,
  },
  buttonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
});</document_content>
</document>
<document index="45">
<source>golf-tracker/src/components/common/LoadingScreen/index.tsx</source>
<document_content>
// src/components/common/LoadingScreen/index.tsx
import React from 'react';
import { View, ActivityIndicator } from 'react-native';
import { styles } from './styles';

export function LoadingScreen() {
  return (
    <View style={styles.container}>
      <ActivityIndicator size="large" color="#2f95dc" />
    </View>
  );
}</document_content>
</document>
<document index="46">
<source>golf-tracker/src/components/common/LoadingScreen/styles.ts</source>
<document_content>
// src/components/common/LoadingScreen/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#fff',
  },
});</document_content>
</document>
<document index="47">
<source>golf-tracker/src/components/common/BackButton/index.tsx</source>
<document_content>
// src/components/common/BackButton/index.tsx
import React from 'react';
import { TouchableOpacity } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { ChevronLeft } from 'lucide-react-native';
import { styles } from './styles';
import { Text } from 'react-native';

interface BackButtonProps {
  onPress?: () => void;
  title?: string;
  color?: string;
}

export function BackButton({ 
  onPress, 
  title = 'Back',
  color = '#2f95dc' 
}: BackButtonProps) {
  const navigation = useNavigation();

  const handlePress = () => {
    if (onPress) {
      onPress();
    } else {
      navigation.goBack();
    }
  };

  return (
    <TouchableOpacity 
      style={styles.container}
      onPress={handlePress}
      hitSlop={{ top: 10, right: 10, bottom: 10, left: 10 }}
    >
      <ChevronLeft size={24} color={color} />
      <Text style={[styles.text, { color }]}>{title}</Text>
    </TouchableOpacity>
  );
}

</document_content>
</document>
<document index="48">
<source>golf-tracker/src/components/common/BackButton/styles.ts</source>
<document_content>
// src/components/common/BackButton/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    top: 45,
    left: 8,
    flexDirection: 'row',
    alignItems: 'center',
    zIndex: 10,
  },
  text: {
    fontSize: 16,
    fontWeight: '500',
    marginLeft: -4,
  },
});</document_content>
</document>
<document index="49">
<source>golf-tracker/src/components/round/RoundDetails/index.tsx</source>
<document_content>
// src/components/round/RoundDetails/index.tsx
import React from 'react';
import { View, Text, TouchableOpacity } from 'react-native';
import DateTimePicker from '@react-native-community/datetimepicker';
import { Course } from 'shared';
import { FormInput } from '../../forms/FormInput';
import { FormButton } from '../../forms/FormButton';
import { TeeSelector } from '../../course/TeeSelector';
import { styles } from './styles';

interface RoundDetailsProps {
  course: Course;
  selectedTee: string;
  onTeeSelect: (tee: string) => void;
  date: Date;
  onDateChange: (date: Date) => void;
  score: string;
  onScoreChange: (score: string) => void;
  putts: string;
  onPuttsChange: (putts: string) => void;
  fairways: string;
  onFairwaysChange: (fairways: string) => void;
  greens: string;
  onGreensChange: (greens: string) => void;
  notes: string;
  onNotesChange: (notes: string) => void;
  errors: {[key: string]: string};
  loading: boolean;
  onSubmit: () => void;
  onChangeCourse: () => void;
}

export function RoundDetails({
  course,
  selectedTee,
  onTeeSelect,
  date,
  onDateChange,
  score,
  onScoreChange,
  putts,
  onPuttsChange,
  fairways,
  onFairwaysChange,
  greens,
  onGreensChange,
  notes,
  onNotesChange,
  errors,
  loading,
  onSubmit,
  onChangeCourse,
}: RoundDetailsProps) {
  return (
    <View style={styles.container}>
      <View style={styles.courseHeader}>
        <View>
          <Text style={styles.courseName}>{course.name}</Text>
          {course.location.city && (
            <Text style={styles.courseLocation}>
              {[course.location.city, course.location.state]
                .filter(Boolean)
                .join(', ')}
            </Text>
          )}
        </View>
        <TouchableOpacity
          onPress={onChangeCourse}
          style={styles.changeButton}
        >
          <Text style={styles.changeButtonText}>Change</Text>
        </TouchableOpacity>
      </View>

      <TeeSelector
        course={course}
        selectedTee={selectedTee}
        onTeeSelect={onTeeSelect}
        error={errors.tee}
      />

      <View style={styles.dateContainer}>
        <Text style={styles.label}>Date Played</Text>
        <DateTimePicker
          value={date}
          mode="date"
          display="default"
          onChange={(event, selectedDate) => {
            if (selectedDate) {
              onDateChange(selectedDate);
            }
          }}
          maximumDate={new Date()}
          style={styles.datePicker}
        />
      </View>

      <View style={styles.statsContainer}>
        <FormInput
          label="Score"
          value={score}
          onChangeText={onScoreChange}
          keyboardType="numeric"
          placeholder="Enter total score"
          error={errors.score}
          editable={!loading}
          containerStyle={styles.halfInput}
        />

        <FormInput
          label="Putts"
          value={putts}
          onChangeText={onPuttsChange}
          keyboardType="numeric"
          placeholder="Total putts"
          error={errors.putts}
          editable={!loading}
          containerStyle={styles.halfInput}
        />

        <FormInput
          label="Fairways Hit"
          value={fairways}
          onChangeText={onFairwaysChange}
          keyboardType="numeric"
          placeholder="# of fairways"
          error={errors.fairways}
          editable={!loading}
          containerStyle={styles.halfInput}
        />

        <FormInput
          label="Greens in Regulation"
          value={greens}
          onChangeText={onGreensChange}
          keyboardType="numeric"
          placeholder="# of GIRs"
          error={errors.greens}
          editable={!loading}
          containerStyle={styles.halfInput}
        />
      </View>

      <FormInput
        label="Notes"
        value={notes}
        onChangeText={onNotesChange}
        placeholder="Add notes about your round"
        multiline
        numberOfLines={4}
        editable={!loading}
        containerStyle={styles.notesInput}
      />

      <FormButton
        title="Save Round"
        onPress={onSubmit}
        loading={loading}
        style={styles.submitButton}
      />
    </View>
  );
}</document_content>
</document>
<document index="50">
<source>golf-tracker/src/components/round/RoundDetails/styles.ts</source>
<document_content>
// src/components/round/RoundDetails/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    padding: 16,
  },
  courseHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 24,
  },
  courseName: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#333',
  },
  courseLocation: {
    fontSize: 14,
    color: '#666',
    marginTop: 4,
  },
  changeButton: {
    padding: 8,
  },
  changeButtonText: {
    color: '#2f95dc',
    fontSize: 16,
    fontWeight: '500',
  },
  dateContainer: {
    marginBottom: 24,
  },
  label: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
  },
  datePicker: {
    backgroundColor: '#fff',
    borderRadius: 8,
  },
  statsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    marginBottom: 24,
    gap: 16,
  },
  halfInput: {
    width: '48%',
  },
  notesInput: {
    marginBottom: 24,
  },
  submitButton: {
    marginTop: 'auto',
  },
});</document_content>
</document>
<document index="51">
<source>golf-tracker/src/hooks/useForm.ts</source>
<document_content>
// src/hooks/useForm.ts
import { useState, useCallback } from 'react';

type ValidationRule<T> = {
  validate: (value: any, formValues?: T) => boolean;
  message: string;
};

type ValidationRules<T> = {
  [K in keyof T]?: ValidationRule<T>[];
};

type FormErrors<T> = {
  [K in keyof T]?: string;
};

type TouchedFields<T> = {
  [K in keyof T]?: boolean;
};

interface UseFormConfig<T extends Record<string, any>> {
  initialValues: T;
  validationRules?: ValidationRules<T>;
  onSubmit: (values: T) => void | Promise<void>;
}

interface UseFormReturn<T> {
  values: T;
  errors: FormErrors<T>;
  touched: TouchedFields<T>;
  isSubmitting: boolean;
  handleChange: <K extends keyof T>(field: K) => (value: T[K]) => void;
  handleBlur: (field: keyof T) => () => void;
  setFieldValue: <K extends keyof T>(field: K, value: T[K]) => void;
  setFieldError: <K extends keyof T>(field: K, error: string) => void;
  setErrors: (errors: FormErrors<T>) => void;
  handleSubmit: () => Promise<void>;
  resetForm: () => void;
  setTouched: (touched: TouchedFields<T>) => void;
  validateField: (field: keyof T) => string | undefined;
  validateForm: () => FormErrors<T>;
}

export function useForm<T extends Record<string, any>>({
  initialValues,
  validationRules = {},
  onSubmit
}: UseFormConfig<T>): UseFormReturn<T> {
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<FormErrors<T>>({});
  const [touched, setTouched] = useState<TouchedFields<T>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Validate a single field
  const validateField = useCallback(
    (field: keyof T): string | undefined => {
      const fieldRules = validationRules[field];
      if (!fieldRules) return undefined;

      for (const rule of fieldRules) {
        if (!rule.validate(values[field], values)) {
          return rule.message;
        }
      }
      return undefined;
    },
    [values, validationRules]
  );

  // Validate all form fields
  const validateForm = useCallback((): FormErrors<T> => {
    const newErrors: FormErrors<T> = {};
    
    for (const field in validationRules) {
      const error = validateField(field as keyof T);
      if (error) {
        newErrors[field as keyof T] = error;
      }
    }
    
    return newErrors;
  }, [validateField, validationRules]);

  // Handle field change
  const handleChange = useCallback(<K extends keyof T>(field: K) => (value: T[K]) => {
    setValues(prev => ({ ...prev, [field]: value }));
    if (errors[field]) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors[field];
        return newErrors;
      });
    }
  }, [errors]);

  // Handle field blur
  const handleBlur = useCallback((field: keyof T) => () => {
    setTouched(prev => ({ ...prev, [field]: true }));

    const error = validateField(field);
    if (error) {
      setErrors(prev => ({ ...prev, [field]: error }));
    }
  }, [validateField]);

  // Set a specific field's value
  const setFieldValue = useCallback(<K extends keyof T>(field: K, value: T[K]) => {
    setValues(prev => ({ ...prev, [field]: value }));
  }, []);

  // Set a specific field's error
  const setFieldError = useCallback(<K extends keyof T>(field: K, error: string) => {
    setErrors(prev => ({ ...prev, [field]: error }));
  }, []);

  // Handle form submission
  const handleSubmit = async () => {
    try {
      setIsSubmitting(true);

      // Validate all fields
      const newErrors = validateForm();
      setErrors(newErrors);

      // Mark all fields as touched
      const allTouched: TouchedFields<T> = {};
      for (const field in values) {
        allTouched[field as keyof T] = true;
      }
      setTouched(allTouched);

      // If there are any errors, stop submission
      if (Object.keys(newErrors).length > 0) {
        return;
      }

      // Call the onSubmit handler
      await onSubmit(values);
    } catch (error) {
      // Let the error propagate to be handled by the form component
      throw error;
    } finally {
      setIsSubmitting(false);
    }
  };

  // Reset form to initial state
  const resetForm = useCallback(() => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
    setIsSubmitting(false);
  }, [initialValues]);

  return {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleBlur,
    setFieldValue,
    setFieldError,
    setErrors,
    handleSubmit,
    resetForm,
    setTouched,
    validateField,
    validateForm
  };
}

// Example Usage:
/*
const form = useForm({
  initialValues: {
    email: '',
    password: ''
  },
  validationRules: {
    email: [
      {
        validate: (value) => !!value,
        message: 'Email is required'
      }
    ],
    password: [
      {
        validate: (value) => !!value,
        message: 'Password is required'
      }
    ]
  },
  onSubmit: async (values) => {
    await submitFunction(values);
  }
});
*/</document_content>
</document>
<document index="52">
<source>golf-tracker/src/hooks/useRounds.ts</source>
<document_content>
// src/hooks/useRounds.ts
import { useState, useCallback, useContext } from 'react';
import { Round, CreateRoundInput } from 'shared';
import { roundService } from '../services/api/rounds';
import { useAuth } from './useAuth';
import { GoalsContext } from '../components/providers/GoalsProvider';

interface UseRounds {
  rounds: Round[];
  loading: boolean;
  error: string | null;
  getUserRounds: () => Promise<void>;
  createRound: (roundData: Omit<CreateRoundInput, 'addedBy'>) => Promise<Round>;
  deleteRound: (roundId: string) => Promise<void>;
}

export function useRounds(): UseRounds {
  const { user } = useAuth();
  const goalsContext = useContext(GoalsContext);
  const [rounds, setRounds] = useState<Round[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const getUserRounds = useCallback(async () => {
    if (!user?._id) return;

    try {
      setLoading(true);
      setError(null);
      
      const userRounds = await roundService.getUserRounds(user._id, {
        sortBy: 'date',
        sortOrder: 'desc'
      });
      setRounds(userRounds);
    } catch (error) {
      console.error('Error fetching rounds:', error);
      setError(error instanceof Error ? error.message : 'Failed to fetch rounds');
      setRounds([]);
    } finally {
      setLoading(false);
    }
  }, [user?._id]);

  const createRound = useCallback(async (roundData: Omit<CreateRoundInput, 'addedBy'>) => {
    if (!user?._id) throw new Error('User not authenticated');

    try {
      setLoading(true);
      setError(null);
      
      const newRound = await roundService.createRound({
        ...roundData,
        addedBy: user._id
      });

      setRounds(prev => [newRound, ...prev].sort((a, b) => 
        new Date(b.date).getTime() - new Date(a.date).getTime()
      ));
      
      // Check goals achievement after adding a new round
      if (goalsContext?.checkAndFindAchievedGoals) {
        console.log('Checking goals after adding new round...');
        setTimeout(() => {
          goalsContext.checkAndFindAchievedGoals();
        }, 500); // Small delay to ensure rounds state is updated
      }

      return newRound;
    } catch (error) {
      console.error('Error creating round:', error);
      setError(error instanceof Error ? error.message : 'Failed to create round');
      throw error;
    } finally {
      setLoading(false);
    }
  }, [user?._id]);

  const deleteRound = useCallback(async (roundId: string) => {
    try {
      setLoading(true);
      setError(null);
      
      await roundService.deleteRound(roundId);
      setRounds(prev => prev.filter(round => round._id !== roundId));
    } catch (error) {
      console.error('Error deleting round:', error);
      setError(error instanceof Error ? error.message : 'Failed to delete round');
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  return {
    rounds,
    loading,
    error,
    getUserRounds,
    createRound,
    deleteRound
  };
}</document_content>
</document>
<document index="53">
<source>golf-tracker/src/hooks/useCourses.ts</source>
<document_content>
// src/hooks/useCourses.ts
import { useState, useCallback } from 'react';
import { Course, CreateCourseInput } from 'shared';
import { courseService } from '../services/api/courses';

interface UseCourses {
  courses: Course[];
  loading: boolean;
  error: string | null;
  searchCourses: (query: string) => Promise<void>;
  createCourse: (courseData: CreateCourseInput) => Promise<Course>;
  addTeeToCourse: (
    courseId: string,
    teeData: {
      name: string;
      rating: number;
      slope: number;
      numberOfFairways: number;
    }
  ) => Promise<Course>;
}

export function useCourses(): UseCourses {
  const [courses, setCourses] = useState<Course[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const searchCourses = useCallback(async (query: string) => {
    try {
      setLoading(true);
      setError(null);
      
      const results = await courseService.searchCourses(query);
      setCourses(results);
    } catch (error) {
      console.error('Error searching courses:', error);
      setError(error instanceof Error ? error.message : 'Failed to search courses');
      setCourses([]);
    } finally {
      setLoading(false);
    }
  }, []);

  const createCourse = useCallback(async (courseData: CreateCourseInput) => {
    try {
      setLoading(true);
      setError(null);
      
      const newCourse = await courseService.createCourse(courseData);
      setCourses(prev => [...prev, newCourse]);
      return newCourse;
    } catch (error) {
      console.error('Error creating course:', error);
      setError(error instanceof Error ? error.message : 'Failed to create course');
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  const addTeeToCourse = useCallback(async (
    courseId: string,
    teeData: {
      name: string;
      rating: number;
      slope: number;
      numberOfFairways: number;
    }
  ) => {
    try {
      setLoading(true);
      setError(null);
      
      const updatedCourse = await courseService.addTeeToCourse(courseId, teeData);
      setCourses(prev => prev.map(course => 
        course._id === courseId ? updatedCourse : course
      ));
      return updatedCourse;
    } catch (error) {
      console.error('Error adding tee to course:', error);
      setError(error instanceof Error ? error.message : 'Failed to add tee');
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  return {
    courses,
    loading,
    error,
    searchCourses,
    createCourse,
    addTeeToCourse
  };
}</document_content>
</document>
<document index="54">
<source>golf-tracker/src/hooks/useAuth.ts</source>
<document_content>
// src/hooks/useAuth.ts
import { useState, useEffect, useCallback } from 'react';
import { User, CreateUserInput } from 'shared';
import { authService } from '../services/api/auth';
import { secureStorage, STORAGE_KEYS } from '../services/storage/secureStorage';

interface AuthState {
  user: User | null;
  loading: boolean;
  error: string | null;
}

interface UseAuth {
  user: User | null;
  loading: boolean;
  error: string | null;
  login: (email: string, password: string) => Promise<void>;
  signup: (userData: CreateUserInput) => Promise<void>;
  logout: () => Promise<void>;
}

export function useAuth(): UseAuth {
  const [state, setState] = useState<AuthState>({
    user: null,
    loading: true,
    error: null,
  });

  useEffect(() => {
    checkAuthStatus();
  }, []);

  const checkAuthStatus = async () => {
    try {
      setState(prev => ({ ...prev, loading: true }));
      const token = await secureStorage.retrieve<string>(STORAGE_KEYS.AUTH_TOKEN);
      
      if (!token) {
        setState({ user: null, loading: false, error: null });
        return;
      }

      const user = await authService.validateToken(token);
      if (user) {
        setState({ user, loading: false, error: null });
      } else {
        await authService.logout();
        setState({ user: null, loading: false, error: null });
      }
    } catch (error) {
      console.error('Error checking auth status:', error);
      setState({
        user: null,
        loading: false,
        error: 'Failed to check authentication status'
      });
    }
  };

  const login = useCallback(async (email: string, password: string) => {
    try {
      setState(prev => ({ ...prev, loading: true, error: null }));
      const { user, token } = await authService.login(email, password);
      
      // Store the token
      await secureStorage.store(STORAGE_KEYS.AUTH_TOKEN, token);
      
      // Update state with user
      setState({ user, loading: false, error: null });
      
      console.log('Login successful, user state updated:', user); // Debug log
    } catch (error) {
      console.error('Login error:', error);
      setState(prev => ({
        ...prev,
        loading: false,
        error: error instanceof Error ? error.message : 'Failed to login'
      }));
      throw error;
    }
  }, []);

  const signup = useCallback(async (userData: CreateUserInput) => {
    try {
      setState(prev => ({ ...prev, loading: true, error: null }));
      const { user, token } = await authService.signup(userData);
      
      // Store the token
      await secureStorage.store(STORAGE_KEYS.AUTH_TOKEN, token);
      
      setState({ user, loading: false, error: null });
    } catch (error) {
      console.error('Signup error:', error);
      setState(prev => ({
        ...prev,
        loading: false,
        error: error instanceof Error ? error.message : 'Failed to create account'
      }));
      throw error;
    }
  }, []);

  const logout = useCallback(async () => {
    try {
      setState(prev => ({ ...prev, loading: true, error: null }));
      await authService.logout();
      setState({ user: null, loading: false, error: null });
    } catch (error) {
      console.error('Logout error:', error);
      setState(prev => ({
        ...prev,
        loading: false,
        error: error instanceof Error ? error.message : 'Failed to logout'
      }));
      throw error;
    }
  }, []);

  return {
    user: state.user,
    loading: state.loading,
    error: state.error,
    login,
    signup,
    logout
  };
}</document_content>
</document>
<document index="55">
<source>golf-tracker/src/hooks/useGoals.ts</source>
<document_content>
// src/hooks/useGoals.ts
import { useState, useCallback, useEffect } from 'react';
import type { Goal, CreateGoalInput, Round } from 'shared';
import { goalService } from '../services/api/goals';
import { useRounds } from './useRounds';
import { calculateHandicap } from '../utils/handicap';
import { useAuthContext } from '../components/providers/AuthProvider';

export const useGoals = () => {
  const { goals: authGoals, activeGoals, completedGoals, user } = useAuthContext();
  const [goals, setGoals] = useState<Goal[]>(authGoals || []);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { rounds, getUserRounds } = useRounds();

  // Use goals from auth context when they change
  useEffect(() => {
    if (authGoals?.length) {
      console.log('Updating goals from auth context:', authGoals);
      setGoals(authGoals);
    }
  }, [authGoals]);

  // Fetch all goals for the user
  const fetchGoals = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      console.log('Fetching goals from hook...');
      const fetchedGoals = await goalService.getUserGoals();
      console.log('Successfully fetched goals:', fetchedGoals);
      setGoals(fetchedGoals);
      return fetchedGoals;
    } catch (err) {
      console.error('Error in fetchGoals hook:', err);
      setError('Failed to load goals. Please try again.');
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  // Add a new goal
  const addGoal = useCallback(async (goalData: CreateGoalInput) => {
    setError(null);
    
    // Get best values for initial current value based on category
    let initialCurrentValue = 0;
    
    // Pre-calculate the current value based on the goal category using BEST values not averages
    if (rounds.length > 0) {
      const currentHandicap = calculateHandicap(rounds);
      const bestScore = rounds.reduce((best, round) => 
        (round.score && round.score < best) ? round.score : best, 999
      );
      
      // For fairways and greens - highest values are best
      const bestFairways = rounds.reduce((best, round) => Math.max(best, round.fairways || 0), 0);
      const bestGreens = rounds.reduce((best, round) => Math.max(best, round.greens || 0), 0);
      
      // For putts - lowest value is best (not average)
      const puttsValues = rounds
        .filter(round => round.putts && round.putts > 0)
        .map(round => round.putts);
      
      const bestPutts = puttsValues.length > 0 ? Math.min(...puttsValues) : 0;
      
      // Log putts values for debugging
      if (goalData.category === 'putts' && puttsValues.length > 0) {
        console.log(`[addGoal] All putts values: ${puttsValues.join(', ')}`);
        console.log(`[addGoal] Best (lowest) putts value: ${bestPutts}`);
      }
      
      switch (goalData.category) {
        case 'handicap':
          initialCurrentValue = currentHandicap;
          break;
        case 'scoring':
          initialCurrentValue = bestScore !== 999 ? bestScore : 0;
          break;
        case 'fairways':
          initialCurrentValue = bestFairways;
          break;
        case 'greens':
          initialCurrentValue = bestGreens;
          break;
        case 'putts':
          initialCurrentValue = bestPutts || 0;
          break;
      }
    }
    
    // Create temporary optimistic goal with temporary ID
    const tempGoal: Goal = {
      _id: `temp_${Date.now()}`,
      addedBy: user?._id || 'current',
      ...goalData,
      achieved: false,
      currentValue: initialCurrentValue,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    // Check if goal is already achieved
    let shouldBeAchieved = false;
    if (initialCurrentValue > 0) {
      switch (goalData.category) {
        case 'handicap':
        case 'scoring':
        case 'putts':
          // Lower is better
          shouldBeAchieved = initialCurrentValue <= goalData.targetValue;
          break;
        case 'fairways':
        case 'greens':
          // Higher is better
          shouldBeAchieved = initialCurrentValue >= goalData.targetValue;
          break;
      }
    }
    
    // Update achieved status if needed
    if (shouldBeAchieved) {
      tempGoal.achieved = true;
      tempGoal.completedAt = new Date();
    }
    
    // Add to UI immediately at the beginning of the list (active goals first)
    setGoals(prev => [tempGoal, ...prev]);
    
    try {
      // Make API call in background with the correct current value
      const newGoal = await goalService.createGoal({
        ...goalData,
        currentValue: initialCurrentValue,
        achieved: shouldBeAchieved,
        completedAt: shouldBeAchieved ? new Date() : undefined
      });
      
      // Update with real goal data
      setGoals(prev => prev.map(goal => 
        goal._id === tempGoal._id ? newGoal : goal
      ));
      
      return newGoal;
    } catch (err) {
      // Remove temporary goal on error
      setGoals(prev => prev.filter(goal => goal._id !== tempGoal._id));
      console.error('Error in addGoal:', err);
      setError('Failed to create goal. Please try again.');
      throw err;
    }
  }, [rounds, user]);

  // Update an existing goal
  const updateGoal = useCallback(async (goalId: string, goalData: Partial<Goal>) => {
    setLoading(true);
    setError(null);
    try {
      const updatedGoal = await goalService.updateGoal(goalId, goalData);
      setGoals(prev => prev.map(goal => 
        goal._id === goalId ? updatedGoal : goal
      ));
      return updatedGoal;
    } catch (err) {
      console.error('Error in updateGoal:', err);
      setError('Failed to update goal. Please try again.');
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  // Remove a goal
  const removeGoal = useCallback(async (goalId: string) => {
    setLoading(true);
    setError(null);
    try {
      await goalService.deleteGoal(goalId);
      setGoals(prev => prev.filter(goal => goal._id !== goalId));
    } catch (err) {
      console.error('Error in removeGoal:', err);
      setError('Failed to delete goal. Please try again.');
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  // Toggle goal achievement status
  const toggleAchievement = useCallback(async (goalId: string, achieved: boolean) => {
    try {
      const now = new Date();
      
      // Find the goal to ensure we have the latest stats
      const targetGoal = goals.find(g => g._id === goalId);
      if (!targetGoal) {
        throw new Error('Goal not found');
      }
      
      // When marking as achieved, ensure we have the latest currentValue from stats
      if (rounds.length > 0) {
        // Calculate best values for each stat type - use same logic as checkAndFindAchievedGoals
        // For handicap
        const currentHandicap = calculateHandicap(rounds);
        
        // For scoring - lowest score is best
        const bestScore = rounds.reduce((best, round) => 
          (round.score && round.score < best) ? round.score : best, 999
        );
        
        // For fairways and greens - highest values are best
        const bestFairways = rounds.reduce((best, round) => Math.max(best, round.fairways || 0), 0);
        const bestGreens = rounds.reduce((best, round) => Math.max(best, round.greens || 0), 0);
        
        // For putts - lowest value is best
        const puttsValues = rounds
          .filter(round => round.putts && round.putts > 0)
          .map(round => round.putts);
        
        const bestPutts = puttsValues.length > 0 ? Math.min(...puttsValues) : 99;
        
        if (puttsValues.length > 0) {
          console.log(`[toggleAchievement] All putts values: ${puttsValues.join(', ')}`);
          console.log(`[toggleAchievement] Best (lowest) putts value: ${bestPutts}`);
        }
        
        // Update the current value based on category
        let currentValue = targetGoal.currentValue || 0;
        let automaticAchievement = false;

        switch (targetGoal.category) {
          case 'handicap':
            currentValue = currentHandicap;
            automaticAchievement = currentHandicap <= targetGoal.targetValue;
            break;
            
          case 'scoring':
            currentValue = bestScore !== 999 ? bestScore : (targetGoal.currentValue || 0);
            automaticAchievement = bestScore !== 999 && bestScore <= targetGoal.targetValue;
            break;
            
          case 'fairways':
            currentValue = bestFairways;
            automaticAchievement = bestFairways >= targetGoal.targetValue;
            break;
            
          case 'greens':
            currentValue = bestGreens;
            automaticAchievement = bestGreens >= targetGoal.targetValue;
            break;
            
          case 'putts':
            if (puttsValues.length > 0) {
              currentValue = bestPutts;
              automaticAchievement = bestPutts <= targetGoal.targetValue;
              console.log(`Toggling goal ${goalId} achievement to ${automaticAchievement} with currentValue: ${currentValue}`);
            }
            break;
        }
        
        // If manually marking as achieved or if stats indicate automatic achievement
        const shouldBeAchieved = achieved || automaticAchievement;
        
        // Optimistically update UI first with completed date and current value
        setGoals(prev => prev.map(goal => 
          goal._id === goalId ? {
            ...goal, 
            achieved: shouldBeAchieved,
            currentValue, // Use the latest value
            completedAt: shouldBeAchieved ? now : undefined
          } : goal
        ));
        
        // Then make API call with the current value
        const updatedGoal = await goalService.toggleGoalAchievement(
          goalId, 
          shouldBeAchieved, 
          shouldBeAchieved ? now.toISOString() : undefined,
          currentValue 
        );
        
        // Update with server response once complete
        setGoals(prev => prev.map(goal => 
          goal._id === goalId ? updatedGoal : goal
        ));
        
        return updatedGoal;
      } else {
        // For unmarking as achieved, just toggle the flag
        // Optimistically update UI first
        setGoals(prev => prev.map(goal => 
          goal._id === goalId ? {
            ...goal, 
            achieved,
            // Remove completedAt date when marking as not achieved
            completedAt: achieved ? now : undefined
          } : goal
        ));
        
        // Then make API call without blocking UI
        const updatedGoal = await goalService.toggleGoalAchievement(goalId, achieved, 
          achieved ? now.toISOString() : undefined);
        
        // Update with server response once complete
        setGoals(prev => prev.map(goal => 
          goal._id === goalId ? updatedGoal : goal
        ));
        
        return updatedGoal;
      }
    } catch (err) {
      console.error('Error in toggleAchievement:', err);
      // Revert to original state on error
      setGoals(prev => [...prev]);
      setError('Failed to update goal status. Please try again.');
      throw err;
    }
  }, [goals, rounds]);

  // Check if goals are achieved based on rounds data
  // Simplified version that doesn't trigger update loops
  const checkGoalAchievements = useCallback(() => {
    if (goals.length === 0 || rounds.length === 0) return;
    
    // Get current handicap
    const currentHandicap = calculateHandicap(rounds);
    
    // Calculate stats using raw values
    const recentRounds = rounds.slice(0, Math.min(5, rounds.length));
    // Raw values (not percentages)
    const avgFairways = recentRounds.reduce((sum, round) => sum + (round.fairways || 0), 0) / recentRounds.length;
    const avgGreens = recentRounds.reduce((sum, round) => sum + (round.greens || 0), 0) / recentRounds.length;
    const avgPutts = recentRounds.reduce((sum, round) => sum + (round.putts || 0), 0) / recentRounds.length;
    
    // Track highest (best) fairways and greens
    const bestFairways = rounds.reduce((best, round) => Math.max(best, round.fairways || 0), 0);
    const bestGreens = rounds.reduce((best, round) => Math.max(best, round.greens || 0), 0);
    
    // Calculate best putts (lowest number)
    const bestPutts = rounds.reduce((best, round) => 
      (round.putts && (best === 0 || round.putts < best)) ? round.putts : best, 
      0
    );
    
    // Find best score
    const bestScore = rounds.reduce((best, round) => 
      (round.score && round.score < best) ? round.score : best, 
      999
    );
    
    console.log('Checking goals with best score:', bestScore);
    
    // Update goals locally with current values without triggering API calls
    const updatedGoals = goals.map(goal => {
      let currentValue = goal.currentValue || 0;
      
      switch (goal.category) {
        case 'handicap':
          currentValue = currentHandicap;
          break;
        case 'scoring':
          currentValue = bestScore !== 999 ? bestScore : (goal.currentValue || 0);
          break;
        case 'fairways':
          // For fairways, use the best (highest) value
          currentValue = bestFairways > 0 ? bestFairways : (goal.currentValue || 0);
          break;
        case 'greens':
          // For greens, use the best (highest) value
          currentValue = bestGreens > 0 ? bestGreens : (goal.currentValue || 0);
          break;
        case 'putts':
          // For putts we want the best (lowest) value, not the average
          currentValue = bestPutts > 0 ? bestPutts : (goal.currentValue || 0);
          break;
      }
      
      return {
        ...goal,
        currentValue
      };
    });
    
    // Only update state if values have changed
    const hasChanges = updatedGoals.some((goal, index) => 
      goal.currentValue !== goals[index].currentValue
    );
    
    if (hasChanges) {
      setGoals(updatedGoals);
    }
  }, [goals, rounds]);
  
  // State to track newly achieved goals
  const [newlyAchievedGoals, setNewlyAchievedGoals] = useState<Goal[]>([]);
  
  // Check goals whenever rounds data changes
  // Check goals on initial load only, not on every achievement update
  useEffect(() => {
    let isMounted = true;
    if (rounds.length > 0 && goals.length > 0 && isMounted) {
      // Use a timeout to prevent update loops
      const timer = setTimeout(() => {
        if (isMounted) {
          // Find goals that were achieved with the latest round
          const achievedGoals = checkAndFindAchievedGoals();
          if (achievedGoals.length > 0) {
            setNewlyAchievedGoals(achievedGoals);
          }
        }
      }, 500);
      
      return () => {
        isMounted = false;
        clearTimeout(timer);
      };
    }
  }, [rounds.length]); // Explicit dependency on rounds.length only
  
  // Check and find goals that were just achieved with the latest round
  const checkAndFindAchievedGoals = useCallback(() => {
    if (goals.length === 0 || rounds.length === 0) return [];
    
    // Calculate best values for each stat type
    // For handicap
    const currentHandicap = calculateHandicap(rounds);
    
    // For scoring - lowest score is best
    const bestScore = rounds.reduce((best, round) => 
      (round.score && round.score < best) ? round.score : best, 999
    );
    
    // For fairways and greens - highest values are best
    const bestFairways = rounds.reduce((best, round) => Math.max(best, round.fairways || 0), 0);
    const bestGreens = rounds.reduce((best, round) => Math.max(best, round.greens || 0), 0);
    
    // For putts - lowest value is best
    const puttsValues = rounds
      .filter(round => round.putts && round.putts > 0)
      .map(round => round.putts);
    
    const bestPutts = puttsValues.length > 0 ? Math.min(...puttsValues) : 99;
    
    if (puttsValues.length > 0) {
      console.log(`All putts values: ${puttsValues.join(', ')}`);
      console.log(`Best (lowest) putts value: ${bestPutts}`);
    }
    
    // Update goals locally and check if any were achieved
    const updatedGoals: Goal[] = [];
    const achievedGoals: Goal[] = [];
    
    goals.forEach(goal => {
      if (goal.achieved) return; // Skip already achieved goals
      
      let currentValue = goal.currentValue || 0;
      let achieved = false;
      
      switch (goal.category) {
        case 'handicap':
          currentValue = currentHandicap;
          achieved = currentHandicap <= goal.targetValue;
          break;
          
        case 'scoring':
          currentValue = bestScore !== 999 ? bestScore : (goal.currentValue || 0);
          achieved = bestScore !== 999 && bestScore <= goal.targetValue;
          break;
          
        case 'fairways':
          currentValue = bestFairways;
          achieved = bestFairways >= goal.targetValue;
          break;
          
        case 'greens':
          currentValue = bestGreens;
          achieved = bestGreens >= goal.targetValue;
          break;
          
        case 'putts':
          // For putts, use the best (lowest) value
          if (puttsValues.length > 0) {
            currentValue = bestPutts;
            achieved = bestPutts <= goal.targetValue;
          }
          console.log(`Putts goal: target=${goal.targetValue}, best=${bestPutts}, current=${currentValue}, achieved=${achieved}`);
          break;
      }
      
      const updatedGoal = {
        ...goal,
        currentValue,
        achieved: achieved || goal.achieved
      };
      
      if (achieved && !goal.achieved) {
        achievedGoals.push(updatedGoal);
        
        // Mark the goal as achieved in the database with the current value
        goalService.toggleGoalAchievement(goal._id, true, undefined, currentValue)
          .catch(err => console.error('Error auto-marking goal as achieved:', err));
      }
      
      updatedGoals.push(updatedGoal);
    });
    
    // Update local state if changes were made
    if (updatedGoals.some((g, i) => g.currentValue !== goals[i].currentValue || g.achieved !== goals[i].achieved)) {
      setGoals(updatedGoals);
    }
    
    return achievedGoals;
  }, [goals, rounds]);
  
  // Fetch rounds when goals are loaded - only once
  useEffect(() => {
    if (goals.length > 0 && rounds.length === 0) {
      getUserRounds();
    }
  }, [goals.length, rounds.length, getUserRounds]);

  return {
    goals,
    loading,
    error,
    fetchGoals,
    addGoal,
    updateGoal,
    removeGoal,
    toggleAchievement,
    checkGoalAchievements,
    checkAndFindAchievedGoals,  // Export this function to be used by the context
    newlyAchievedGoals,
    setNewlyAchievedGoals,
    // Add easy access to filtered goals
    activeGoals: activeGoals || goals.filter(goal => !goal.achieved),
    completedGoals: completedGoals || goals.filter(goal => goal.achieved)
  };
};</document_content>
</document>
<document index="56">
<source>golf-tracker/src/services/storage/secureStorage.ts</source>
<document_content>
// src/services/storage/secureStorage.ts
import * as SecureStore from 'expo-secure-store';

// Storage keys
export const STORAGE_KEYS = {
  AUTH_TOKEN: 'auth_token',
  USER_DATA: 'user_data',
  SETTINGS: 'user_settings',
} as const;

type StorageKey = typeof STORAGE_KEYS[keyof typeof STORAGE_KEYS];

/**
 * Generic secure storage service with type safety
 */
class SecureStorageService {
  /**
   * Store a value securely
   */
  async store<T>(key: StorageKey, value: T): Promise<void> {
    try {
      const jsonValue = JSON.stringify(value);
      await SecureStore.setItemAsync(key, jsonValue);
    } catch (error) {
      console.error(`Error storing ${key}:`, error);
      throw new Error(`Failed to store ${key}`);
    }
  }

  /**
   * Retrieve a value from secure storage
   */
  async retrieve<T>(key: StorageKey): Promise<T | null> {
    try {
      const jsonValue = await SecureStore.getItemAsync(key);
      return jsonValue ? JSON.parse(jsonValue) : null;
    } catch (error) {
      console.error(`Error retrieving ${key}:`, error);
      throw new Error(`Failed to retrieve ${key}`);
    }
  }

  /**
   * Remove a value from secure storage
   */
  async remove(key: StorageKey): Promise<void> {
    try {
      await SecureStore.deleteItemAsync(key);
    } catch (error) {
      console.error(`Error removing ${key}:`, error);
      throw new Error(`Failed to remove ${key}`);
    }
  }

  /**
   * Clear all stored values
   */
  async clear(): Promise<void> {
    try {
      const keys = Object.values(STORAGE_KEYS);
      await Promise.all(keys.map(key => this.remove(key)));
    } catch (error) {
      console.error('Error clearing storage:', error);
      throw new Error('Failed to clear storage');
    }
  }
}

// Export singleton instance
export const secureStorage = new SecureStorageService();</document_content>
</document>
<document index="57">
<source>golf-tracker/src/services/api/courses.ts</source>
<document_content>
// src/services/api/courses.ts
import { Course, CreateCourseInput } from 'shared';
import { authService } from './auth';

const API_URL = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:3000/api';

export class CourseError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'CourseError';
  }
}

interface CourseResponse {
  success: boolean;
  data: Course | Course[];
  message?: string;
}

class CourseService {
  /**
   * Get auth headers
   */
  private async getHeaders(): Promise<Headers> {
    const token = await authService.getToken();
    if (!token) {
      throw new CourseError('No auth token found');
    }

    return new Headers({
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    });
  }

  /**
   * Handle API response
   */
  private async handleResponse(response: Response): Promise<CourseResponse> {
    const data = await response.json();
    if (!response.ok) {
      throw new CourseError(data.message || 'Course operation failed');
    }
    return data;
  }

  /**
   * Search courses
   */
  async searchCourses(query: string): Promise<Course[]> {
    const headers = await this.getHeaders();
    const response = await fetch(
      `${API_URL}/courses?search=${encodeURIComponent(query)}`,
      { method: 'GET', headers }
    );

    const data = await this.handleResponse(response);
    return Array.isArray(data.data) ? data.data : [];
  }

  /**
   * Create course
   */
  async createCourse(courseData: CreateCourseInput): Promise<Course> {
    const headers = await this.getHeaders();
    const response = await fetch(`${API_URL}/courses`, {
      method: 'POST',
      headers,
      body: JSON.stringify(courseData)
    });

    const data = await this.handleResponse(response);
    return data.data as Course;
  }

  /**
   * Add tee to course
   */
  async addTeeToCourse(
    courseId: string,
    teeData: {
      name: string;
      rating: number;
      slope: number;
      numberOfFairways: number;
    }
  ): Promise<Course> {
    const headers = await this.getHeaders();
    const response = await fetch(`${API_URL}/courses/${courseId}/tees`, {
      method: 'POST',
      headers,
      body: JSON.stringify(teeData)
    });

    const data = await this.handleResponse(response);
    return data.data as Course;
  }

  /**
   * Delete course
   */
  async deleteCourse(courseId: string): Promise<void> {
    const headers = await this.getHeaders();
    const response = await fetch(`${API_URL}/courses/${courseId}`, {
      method: 'DELETE',
      headers
    });

    if (!response.ok) {
      const data = await response.json();
      throw new CourseError(data.message || 'Failed to delete course');
    }
  }
}

// Export singleton instance
export const courseService = new CourseService();</document_content>
</document>
<document index="58">
<source>golf-tracker/src/services/api/goals.ts</source>
<document_content>
// src/services/api/goals.ts
import type { Goal, CreateGoalInput } from 'shared';
import { authService } from './auth';

// Make sure we use the same API URL as other services
import { API_URL } from '../../config/constants';

export class GoalError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'GoalError';
  }
}

interface GoalResponse {
  success: boolean;
  data: Goal | Goal[];
  message?: string;
}

class GoalService {
  /**
   * Get auth headers
   */
  private async getHeaders(): Promise<Headers> {
    const token = await authService.getToken();
    if (!token) {
      throw new GoalError('No auth token found');
    }

    return new Headers({
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    });
  }

  /**
   * Handle API response
   */
  private async handleResponse(response: Response): Promise<GoalResponse> {
    // Check content type to debug issues
    const contentType = response.headers.get('content-type');
    if (!contentType || !contentType.includes('application/json')) {
      // Not JSON - get the text to see what's being returned
      const text = await response.text();
      console.error('Non-JSON response received:', text);
      throw new GoalError('Server returned an invalid response format');
    }
    
    const data = await response.json();
    if (!response.ok) {
      throw new GoalError(data.message || 'Goal operation failed');
    }
    
    // Convert date strings to Date objects for proper typing
    if (Array.isArray(data.data)) {
      // Handle array of goals
      data.data = data.data.map(this.convertGoalDates);
    } else if (data.data) {
      // Handle single goal
      data.data = this.convertGoalDates(data.data);
    }
    
    return data;
  }
  
  // Helper to convert date strings to Date objects if needed
  // With our updated types, this is technically optional, but it helps
  // maintain consistency in the client-side objects
  private convertGoalDates(goal: any): Goal {
    // Only convert if needed - this preserves the client-created Date objects
    // and only converts server-provided string dates
    
    // Convert standard date fields
    if (goal.createdAt && typeof goal.createdAt === 'string') {
      goal.createdAt = new Date(goal.createdAt);
    }
    if (goal.updatedAt && typeof goal.updatedAt === 'string') {
      goal.updatedAt = new Date(goal.updatedAt);
    }
    // Convert goal-specific date fields
    if (goal.completedAt && typeof goal.completedAt === 'string') {
      goal.completedAt = new Date(goal.completedAt);
    }
    if (goal.targetDate && typeof goal.targetDate === 'string') {
      goal.targetDate = new Date(goal.targetDate);
    }
    return goal;
  }

  /**
   * Test API connectivity
   */
  async testConnection(): Promise<boolean> {
    try {
      console.log('Testing goals API connection...');
      const response = await fetch(`${API_URL}/goals/test`, {
        method: 'GET'
      });
      
      if (!response.ok) {
        const text = await response.text();
        console.error('Test connection failed:', text);
        return false;
      }
      
      const data = await response.json();
      console.log('Test connection successful:', data);
      return true;
    } catch (error) {
      console.error('Test connection error:', error);
      return false;
    }
  }

  /**
   * Get all goals for current user
   */
  async getUserGoals(): Promise<Goal[]> {
    try {
      // First test API connectivity
      const isConnected = await this.testConnection();
      if (!isConnected) {
        console.warn('API connection test failed, but trying to get goals anyway');
      }
      
      const headers = await this.getHeaders();
      console.log('Fetching goals from URL:', `${API_URL}/goals`);
      console.log('With headers:', JSON.stringify(Object.fromEntries([...headers.entries()])));
      
      const response = await fetch(`${API_URL}/goals`, {
        method: 'GET',
        headers
      });
      
      console.log('Response status:', response.status);
      console.log('Response headers:', JSON.stringify(Object.fromEntries([...response.headers])));
      
      const data = await this.handleResponse(response);
      const goals = Array.isArray(data.data) ? data.data : [];
      
      // Log any putts goals to help with debugging
      goals.forEach(goal => {
        if (goal.category === 'putts') {
          console.log(`[API] Received putts goal: ${goal.name}, ID: ${goal._id}, Value: ${goal.currentValue}, Achieved: ${goal.achieved}`);
        }
      });
      
      return goals;
    } catch (error) {
      console.error('Error fetching goals:', error);
      throw error;
    }
  }

  /**
   * Create a new goal
   */
  async createGoal(goalData: CreateGoalInput & { achieved?: boolean, completedAt?: Date }): Promise<Goal> {
    try {
      const headers = await this.getHeaders();
      
      // Log the request body for debugging
      if (goalData.category === 'putts') {
        console.log(`[API] Creating putts goal with initial value: ${goalData.currentValue}, achieved: ${goalData.achieved}`);
      }
      
      const response = await fetch(`${API_URL}/goals`, {
        method: 'POST',
        headers,
        body: JSON.stringify(goalData)
      });

      const data = await this.handleResponse(response);
      const updatedGoal = data.data as Goal;
      
      // Log if this is a putts goal
      if (updatedGoal.category === 'putts') {
        console.log(`[API] Goal created for putts goal: ID: ${updatedGoal._id}, Value: ${updatedGoal.currentValue}, Achieved: ${updatedGoal.achieved}`);
      }
      
      return updatedGoal;
    } catch (error) {
      console.error('Error creating goal:', error);
      throw error;
    }
  }

  /**
   * Update an existing goal
   */
  async updateGoal(goalId: string, goalData: Partial<Goal>): Promise<Goal> {
    try {
      const headers = await this.getHeaders();
      const response = await fetch(`${API_URL}/goals/${goalId}`, {
        method: 'PUT',
        headers,
        body: JSON.stringify(goalData)
      });

      const data = await this.handleResponse(response);
      const updatedGoal = data.data as Goal;
      
      // Log if this is a putts goal
      if (updatedGoal.category === 'putts') {
        console.log(`[API] Goal toggle response for putts goal: ID: ${updatedGoal._id}, Value: ${updatedGoal.currentValue}, Achieved: ${updatedGoal.achieved}`);
      }
      
      return updatedGoal;
    } catch (error) {
      console.error('Error updating goal:', error);
      throw error;
    }
  }

  /**
   * Toggle goal achievement status
   */
  async toggleGoalAchievement(
    goalId: string, 
    achieved: boolean, 
    completedAtStr?: string,
    currentValue?: number
  ): Promise<Goal> {
    try {
      const headers = await this.getHeaders();
      
      // Prepare request body
      const requestBody: any = { 
        achieved,
        completedAt: achieved ? completedAtStr || new Date().toISOString() : undefined
      };
      
      // Include currentValue if provided (important for preserving stats)
      if (currentValue !== undefined) {
        requestBody.currentValue = currentValue;
      }
      
      console.log(`Toggling goal ${goalId} achievement to ${achieved} with currentValue:`, currentValue);
      
      const response = await fetch(`${API_URL}/goals/${goalId}/achievement`, {
        method: 'PATCH',
        headers,
        body: JSON.stringify(requestBody)
      });

      const data = await this.handleResponse(response);
      const updatedGoal = data.data as Goal;
      
      // Log if this is a putts goal
      if (updatedGoal.category === 'putts') {
        console.log(`[API] Goal toggle response for putts goal: ID: ${updatedGoal._id}, Value: ${updatedGoal.currentValue}, Achieved: ${updatedGoal.achieved}`);
      }
      
      return updatedGoal;
    } catch (error) {
      console.error('Error toggling goal achievement:', error);
      throw error;
    }
  }

  /**
   * Delete a goal
   */
  async deleteGoal(goalId: string): Promise<void> {
    try {
      const headers = await this.getHeaders();
      const response = await fetch(`${API_URL}/goals/${goalId}`, {
        method: 'DELETE',
        headers
      });

      await this.handleResponse(response);
    } catch (error) {
      console.error('Error deleting goal:', error);
      throw error;
    }
  }
}

// Export singleton instance
export const goalService = new GoalService();</document_content>
</document>
<document index="59">
<source>golf-tracker/src/services/api/rounds.ts</source>
<document_content>
// src/services/api/rounds.ts
import { Round, CreateRoundInput } from 'shared';
import { authService } from './auth';

const API_URL = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:3000/api';

export class RoundError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'RoundError';
  }
}

interface RoundResponse {
  success: boolean;
  data: Round | Round[];
  message?: string;
}

class RoundService {
  /**
   * Get auth headers
   */
  private async getHeaders(): Promise<Headers> {
    const token = await authService.getToken();
    if (!token) {
      throw new RoundError('No auth token found');
    }

    return new Headers({
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    });
  }

  /**
   * Handle API response
   */
  private async handleResponse(response: Response): Promise<RoundResponse> {
    const data = await response.json();
    if (!response.ok) {
      throw new RoundError(data.message || 'Round operation failed');
    }
    return data;
  }

  /**
   * Format date for API
   */
  private formatDate(date: Date | string): string {
    return date instanceof Date ? date.toISOString() : date;
  }

  /**
   * Get user rounds
   */
  async getUserRounds(userId: string, options?: {
    limit?: number;
    offset?: number;
    sortBy?: 'date' | 'score';
    sortOrder?: 'asc' | 'desc';
  }): Promise<Round[]> {
    const headers = await this.getHeaders();
    const url = new URL(`${API_URL}/rounds`);
    
    // Note: We don't need to add userId as a query param since the server uses the JWT token
    // to identify the user. But we keep the parameter for API consistency.
    
    if (options?.limit) url.searchParams.append('limit', options.limit.toString());
    if (options?.offset) url.searchParams.append('offset', options.offset.toString());
    if (options?.sortBy) url.searchParams.append('sortBy', options.sortBy);
    if (options?.sortOrder) url.searchParams.append('sortOrder', options.sortOrder);

    try {
      console.log('Fetching rounds from API:', url.toString());
      const response = await fetch(url.toString(), { method: 'GET', headers });
      const data = await this.handleResponse(response);
      console.log('Received rounds data:', data.data ? 'count: ' + (Array.isArray(data.data) ? data.data.length : 0) : 'No data');
      
      // Process rounds data to check for putts values
      const rounds = Array.isArray(data.data) ? data.data : [];
      
      // Log the putts values from each round to help debug
      console.log('[ROUNDS DATA] Putts values in rounds:');
      const puttsValues = rounds.map(round => round.putts).filter(p => p !== undefined);
      const sortedPutts = [...puttsValues].sort((a, b) => a - b);
      console.log(`All putts values: ${puttsValues.join(', ')}`);
      console.log(`Best (lowest) putts value: ${sortedPutts[0] || 'None'}`);
      
      return rounds;
    } catch (error) {
      console.error('Error in getUserRounds:', error);
      throw error;
    }
  }

  /**
   * Create round
   */
  async createRound(roundData: CreateRoundInput): Promise<Round> {
    const headers = await this.getHeaders();
    const formattedData = {
      ...roundData,
      date: this.formatDate(roundData.date)
    };

    const response = await fetch(`${API_URL}/rounds`, {
      method: 'POST',
      headers,
      body: JSON.stringify(formattedData)
    });

    const data = await this.handleResponse(response);
    return data.data as Round;
  }

  /**
   * Delete round
   */
  async deleteRound(roundId: string): Promise<void> {
    const headers = await this.getHeaders();
    try {
      console.log(`Deleting round with ID: ${roundId}`);
      const response = await fetch(`${API_URL}/rounds/${roundId}`, {
        method: 'DELETE',
        headers
      });

      // Handle non-JSON responses
      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        console.error('Non-JSON response received:', await response.text());
        throw new RoundError('Server returned an invalid response format');
      }

      const data = await response.json();
      
      if (!response.ok) {
        throw new RoundError(data.message || 'Failed to delete round');
      }
      
      console.log('Round deleted successfully:', data);
      return;
    } catch (error) {
      console.error('Error in deleteRound:', error);
      if (error instanceof SyntaxError) {
        // JSON parse error
        throw new RoundError('Invalid response from server. Please try again later.');
      }
      throw error;
    }
  }
}

// Export singleton instance
export const roundService = new RoundService();</document_content>
</document>
<document index="60">
<source>golf-tracker/src/services/api/auth.ts</source>
<document_content>
// src/services/api/auth.ts
import { User, CreateUserInput } from 'shared';
import { secureStorage, STORAGE_KEYS } from '../storage/secureStorage';

const API_URL = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:3000/api';

export class AuthError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'AuthError';
  }
}

interface AuthResponse {
  success: boolean;
  data: {
    user: User;
    token: string;
  };
  message?: string;
}

interface AuthResult {
  user: User;
  token: string;
}

class AuthService {
  private async handleAuthResponse(response: Response): Promise<AuthResponse> {
    const data = await response.json();
    if (!response.ok) {
      throw new AuthError(data.message || 'Authentication failed');
    }
    return data as AuthResponse;
  }

  async login(email: string, password: string): Promise<AuthResult> {
    try {
      const response = await fetch(`${API_URL}/auth/login`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password }),
      });

      const data = await this.handleAuthResponse(response);
      if (!data.data?.token || !data.data?.user) {
        throw new AuthError('Invalid server response');
      }

      return {
        user: data.data.user,
        token: data.data.token
      };
    } catch (error) {
      if (error instanceof AuthError) throw error;
      throw new AuthError('Failed to log in');
    }
  }

  async signup(userData: CreateUserInput): Promise<AuthResult> {
    try {
      const response = await fetch(`${API_URL}/auth/signup`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(userData),
      });

      const data = await this.handleAuthResponse(response);
      if (!data.data?.token || !data.data?.user) {
        throw new AuthError('Invalid server response');
      }

      return {
        user: data.data.user,
        token: data.data.token
      };
    } catch (error) {
      if (error instanceof AuthError) throw error;
      throw new AuthError('Failed to create account');
    }
  }

  async validateToken(token: string): Promise<User | null> {
    try {
      const response = await fetch(`${API_URL}/auth/validate`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });

      if (!response.ok) return null;

      const data = await response.json();
      const user = data.data?.user || null;
      
      // Log the returned user data to help with debugging
      console.log('validateToken response data:', data);
      
      return user;
    } catch (error) {
      console.error('Error validating token:', error);
      return null;
    }
  }

  async logout(): Promise<void> {
    await secureStorage.remove(STORAGE_KEYS.AUTH_TOKEN);
  }

  async getToken(): Promise<string | null> {
    return secureStorage.retrieve<string>(STORAGE_KEYS.AUTH_TOKEN);
  }
}

export const authService = new AuthService();</document_content>
</document>
<document index="2">
<source>server/middleware/auth.ts</source>
<document_content>
// server/middleware/auth.ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { User } from 'shared';
import UserModel, { IUser } from '../models/User';

interface JwtPayload {
  userId: string;
  email: string;
}

// Helper function to convert MongoDB document to User type
export function mapUserToResponse(user: IUser): User {
  const userObj = user.toObject();
  return {
    _id: userObj._id.toString(),
    email: userObj.email,
    name: userObj.name,
    createdAt: userObj.createdAt,
    updatedAt: userObj.updatedAt,
    savedCourses: (userObj.savedCourses || []).map((course: any) => ({
      ...course,
      _id: course._id.toString(),
      addedBy: course.addedBy.toString()
    })),
    rounds: (userObj.rounds || []).map((round: any) => ({
      ...round,
      _id: round._id.toString(),
      addedBy: round.addedBy.toString(),
      course: {
        ...round.course,
        _id: round.course._id.toString(),
        addedBy: round.course.addedBy.toString()
      }
    }))
  };
}

export const authenticateToken = async (
  req: Request & { user?: User },
  res: Response,
  next: NextFunction
) => {
  console.log('Authenticating token...');

  try {
    const authHeader = req.headers.authorization;
    if (!authHeader?.startsWith('Bearer ')) {
      return res.status(401).json({
        success: false,
        message: 'No token provided'
      });
    }

    const token = authHeader.split(' ')[1];
    
    if (!process.env.JWT_SECRET) {
      console.error('JWT_SECRET not configured');
      return res.status(500).json({
        success: false,
        message: 'Server configuration error'
      });
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET) as JwtPayload;
    console.log('Token decoded:', decoded);

    const user = await UserModel.findById(decoded.userId)
      .select('-password')
      .populate({
        path: 'rounds',
        populate: {
          path: 'course'
        }
      })
      .populate('savedCourses');

    if (!user) {
      console.log('User not found for token');
      return res.status(401).json({
        success: false,
        message: 'User not found'
      });
    }

    console.log('User found:', user.email);
    req.user = mapUserToResponse(user);
    next();
  } catch (error) {
    console.error('Auth middleware error:', error);
    if (error instanceof jwt.JsonWebTokenError) {
      return res.status(401).json({
        success: false,
        message: 'Invalid token'
      });
    }

    return res.status(500).json({
      success: false,
      message: 'Internal server error'
    });
  }
};</document_content>
</document>
<document index="3">
<source>server/simulate-courses.ts</source>
<document_content>
// server/simulate-courses.ts
import mongoose from 'mongoose';
import dotenv from 'dotenv';
import { CreateCourseInput } from 'shared';
import CourseModel from './models/Course';
import UserModel from './models/User';

dotenv.config();

const MONGODB_URI = process.env.MONGODB_URI;

if (!MONGODB_URI) {
  console.error('MONGODB_URI must be defined in environment variables');
  process.exit(1);
}

// Connect to MongoDB
mongoose.connect(MONGODB_URI)
  .then(() => console.log('Connected to MongoDB'))
  .catch(err => {
    console.error('MongoDB connection error:', err);
    process.exit(1);
  });

// Pre-defined course data
const courses = [
  {
    name: 'Pebble Beach Golf Links',
    location: { city: 'Pebble Beach', state: 'CA', country: 'USA' },
    tees: [
      { name: 'Black', rating: 74.7, slope: 143, numberOfFairways: 14 },
      { name: 'Blue', rating: 72.6, slope: 138, numberOfFairways: 14 },
      { name: 'White', rating: 70.8, slope: 135, numberOfFairways: 14 }
    ]
  },
  {
    name: 'Augusta National Golf Club',
    location: { city: 'Augusta', state: 'GA', country: 'USA' },
    tees: [
      { name: 'Championship', rating: 76.2, slope: 148, numberOfFairways: 14 },
      { name: 'Member', rating: 73.5, slope: 140, numberOfFairways: 14 }
    ]
  },
  {
    name: 'St Andrews Old Course',
    location: { city: 'St Andrews', state: null, country: 'Scotland' },
    tees: [
      { name: 'Championship', rating: 73.1, slope: 132, numberOfFairways: 14 },
      { name: 'White', rating: 71.8, slope: 130, numberOfFairways: 14 }
    ]
  },
  {
    name: 'Torrey Pines South Course',
    location: { city: 'La Jolla', state: 'CA', country: 'USA' },
    tees: [
      { name: 'Black', rating: 75.3, slope: 144, numberOfFairways: 14 },
      { name: 'Blue', rating: 73.2, slope: 140, numberOfFairways: 14 },
      { name: 'White', rating: 71.5, slope: 135, numberOfFairways: 14 }
    ]
  },
  {
    name: 'Bethpage Black',
    location: { city: 'Farmingdale', state: 'NY', country: 'USA' },
    tees: [
      { name: 'Black', rating: 77.5, slope: 152, numberOfFairways: 14 },
      { name: 'Blue', rating: 74.3, slope: 144, numberOfFairways: 14 },
      { name: 'White', rating: 72.1, slope: 139, numberOfFairways: 14 }
    ]
  },
  {
    name: 'TPC Sawgrass',
    location: { city: 'Ponte Vedra Beach', state: 'FL', country: 'USA' },
    tees: [
      { name: 'Championship', rating: 75.8, slope: 146, numberOfFairways: 14 },
      { name: 'Blue', rating: 73.6, slope: 140, numberOfFairways: 14 },
      { name: 'White', rating: 71.4, slope: 136, numberOfFairways: 14 }
    ]
  },
  {
    name: 'Pinehurst No. 2',
    location: { city: 'Pinehurst', state: 'NC', country: 'USA' },
    tees: [
      { name: 'Championship', rating: 74.9, slope: 138, numberOfFairways: 14 },
      { name: 'Blue', rating: 72.7, slope: 134, numberOfFairways: 14 },
      { name: 'White', rating: 70.6, slope: 132, numberOfFairways: 14 }
    ]
  },
  {
    name: 'Oakland Hills South Course',
    location: { city: 'Bloomfield Hills', state: 'MI', country: 'USA' },
    tees: [
      { name: 'Championship', rating: 75.6, slope: 143, numberOfFairways: 14 },
      { name: 'Blue', rating: 73.8, slope: 139, numberOfFairways: 14 },
      { name: 'White', rating: 71.7, slope: 135, numberOfFairways: 14 }
    ]
  },
  {
    name: 'Royal County Down',
    location: { city: 'Newcastle', state: null, country: 'Northern Ireland' },
    tees: [
      { name: 'Championship', rating: 74.8, slope: 142, numberOfFairways: 14 },
      { name: 'White', rating: 72.5, slope: 137, numberOfFairways: 14 }
    ]
  },
  {
    name: 'Winged Foot West Course',
    location: { city: 'Mamaroneck', state: 'NY', country: 'USA' },
    tees: [
      { name: 'Championship', rating: 76.4, slope: 145, numberOfFairways: 14 },
      { name: 'Blue', rating: 74.2, slope: 140, numberOfFairways: 14 },
      { name: 'White', rating: 72.1, slope: 136, numberOfFairways: 14 }
    ]
  }
];

// Main function to create courses
async function createCourses() {
  try {
    // Get user email from command line arg, or use default
    const args = process.argv.slice(2);
    const userEmail = args[0] || 'test@example.com';
    
    console.log(`Creating courses for user: ${userEmail}`);
    
    // Find the user
    const user = await UserModel.findOne({ email: userEmail });
    if (!user) {
      console.error(`User with email ${userEmail} not found`);
      process.exit(1);
    }
    
    console.log(`Found user: ${user.email} with ID: ${user._id}`);
    
    // Check if courses already exist
    const existingCourseCount = await CourseModel.countDocuments();
    if (existingCourseCount > 0) {
      console.log(`There are already ${existingCourseCount} courses in the database.`);
      const shouldProceed = args[1] === 'force';
      
      if (!shouldProceed) {
        console.log('Skipping course creation. Pass "force" as the second argument to override.');
        process.exit(0);
      }
    }
    
    // Create courses
    const createdCourses = [];
    for (const courseData of courses) {
      // Check if course already exists
      const existingCourse = await CourseModel.findOne({
        name: courseData.name,
        'location.city': courseData.location.city,
        'location.state': courseData.location.state,
        'location.country': courseData.location.country
      });
      
      if (existingCourse) {
        console.log(`Course "${courseData.name}" already exists, skipping...`);
        createdCourses.push(existingCourse);
        continue;
      }
      
      // Create course with user as creator
      const course = new CourseModel({
        ...courseData,
        addedBy: user._id
      });
      
      await course.save();
      createdCourses.push(course);
      console.log(`Created course: ${course.name}`);
    }
    
    console.log(`Successfully created ${createdCourses.length} courses`);
    return createdCourses;
  } catch (error) {
    console.error('Error creating courses:', error);
    process.exit(1);
  } finally {
    // Close the database connection
    await mongoose.disconnect();
    console.log('Disconnected from MongoDB');
  }
}

// Execute the course creation
createCourses().then(() => {
  console.log('Course creation completed successfully');
  process.exit(0);
}).catch(err => {
  console.error('Course creation failed:', err);
  process.exit(1);
});</document_content>
</document>
<document index="4">
<source>server/models/Goal.ts</source>
<document_content>
// server/models/Goal.ts
import mongoose from 'mongoose';

export interface IGoal {
  _id: mongoose.Types.ObjectId;
  name: string;
  targetValue: number;
  currentValue?: number;
  targetDate?: Date;
  category: 'handicap' | 'scoring' | 'fairways' | 'greens' | 'putts' | 'custom';
  achieved: boolean;
  completedAt?: Date;
  description?: string;
  addedBy: mongoose.Types.ObjectId;
  createdAt: Date;
  updatedAt: Date;
}

const goalSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  targetValue: {
    type: Number,
    required: true
  },
  currentValue: {
    type: Number
  },
  targetDate: {
    type: Date
  },
  category: {
    type: String,
    enum: ['handicap', 'scoring', 'fairways', 'greens', 'putts', 'custom'],
    required: true
  },
  achieved: {
    type: Boolean,
    default: false
  },
  completedAt: {
    type: Date
  },
  description: {
    type: String,
    trim: true
  },
  addedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  }
}, {
  timestamps: true
});

const Goal = mongoose.model<IGoal>('Goal', goalSchema);

export default Goal;</document_content>
</document>
<document index="5">
<source>server/models/Round.ts</source>
<document_content>
// server/models/Round.ts
import mongoose, { Schema } from 'mongoose';
import { Round } from 'shared';
import CourseModel from './Course';

export interface IRound extends Omit<Round, '_id' | 'course' | 'addedBy'> {
  _id: mongoose.Types.ObjectId;
  course: mongoose.Types.ObjectId;
  addedBy: mongoose.Types.ObjectId;
}

const roundSchema = new Schema({
  course: {
    type: Schema.Types.ObjectId,
    ref: 'Course',
    required: true
  },
  date: {
    type: Date,
    required: true,
    default: Date.now
  },
  tees: {
    type: String,
    required: true
  },
  score: {
    type: Number,
    required: true
  },
  putts: {
    type: Number,
    required: true
  },
  fairways: {
    type: Number,
    required: true
  },
  greens: {
    type: Number,
    required: true
  },
  notes: {
    type: String
  },
  differential: {
    type: Number,
    required: true
  },
  addedBy: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
  }
}, {
  timestamps: true
});

// Add indexes for common queries
roundSchema.index({ addedBy: 1, date: -1 });
roundSchema.index({ course: 1, addedBy: 1 });

// Pre-save middleware to calculate differential
roundSchema.pre('save', async function(next) {
  if (this.isModified('score') || this.isModified('course') || this.isModified('tees')) {
    try {
      const course = await CourseModel.findById(this.course);
      if (!course) {
        throw new Error('Course not found');
      }

      const tee = course.tees.find(t => t.name === this.tees);
      if (!tee) {
        throw new Error('Tee not found');
      }

      // Calculate differential using USGA formula
      this.differential = ((this.score - tee.rating) * 113) / tee.slope;
      // Round to one decimal place
      this.differential = Math.round(this.differential * 10) / 10;
    } catch (error) {
      next(error as Error);
      return;
    }
  }
  next();
});

const Round = mongoose.model<IRound>('Round', roundSchema);
export default Round;</document_content>
</document>
<document index="6">
<source>server/models/Course.ts</source>
<document_content>
// server/models/Course.ts
import mongoose from 'mongoose';
import { Course } from 'shared';

export interface ICourse extends Omit<Course, '_id' | 'addedBy'> {
  _id: mongoose.Types.ObjectId;
  addedBy: mongoose.Types.ObjectId;
}

const teeSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true
  },
  rating: {
    type: Number,
    required: true
  },
  slope: {
    type: Number,
    required: true
  },
  numberOfFairways: {
    type: Number,
    required: true,
    min: 0,
    max: 18,
    validate: {
      validator: Number.isInteger,
      message: 'Number of fairways must be a whole number'
    }
  }
});

const courseSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  location: {
    city: {
      type: String,
      trim: true
    },
    state: {
      type: String,
      trim: true
    },
    country: {
      type: String,
      trim: true
    }
  },
  tees: [teeSchema],
  addedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  }
}, {
  timestamps: true
});

// Make courses unique by name + location
courseSchema.index({ 
  name: 1, 
  'location.city': 1, 
  'location.state': 1,
  'location.country': 1
}, { 
  unique: true,
  collation: { locale: 'en', strength: 2 } // Case-insensitive uniqueness
});

const Course = mongoose.model<ICourse>('Course', courseSchema);
export default Course;</document_content>
</document>
<document index="7">
<source>server/models/User.ts</source>
<document_content>
// server/models/User.ts
import mongoose from 'mongoose';
import bcrypt from 'bcryptjs';
import { ICourse } from './Course';
import { IRound } from './Round';

export interface IUser {
  _id: mongoose.Types.ObjectId;
  email: string;
  password: string;
  name?: string;
  savedCourses: mongoose.Types.ObjectId[] | ICourse[];
  rounds: mongoose.Types.ObjectId[] | IRound[];
  createdAt: Date;
  updatedAt: Date;
  comparePassword(candidatePassword: string): Promise<boolean>;
  toObject(): any;
}

const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: true,
    unique: true,
  },
  password: {
    type: String,
    required: true,
  },
  name: String,
  savedCourses: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Course'
  }],
  rounds: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Round'
  }]
}, {
  timestamps: true
});

// Hash password before saving
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();

  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error as Error);
  }
});

// Method to compare passwords
userSchema.methods.comparePassword = async function(candidatePassword: string): Promise<boolean> {
  try {
    return await bcrypt.compare(candidatePassword, this.password);
  } catch (error) {
    throw error;
  }
};

const User = mongoose.model<IUser>('User', userSchema);

export default User;</document_content>
</document>
<document index="8">
<source>server/simulate-rounds.ts</source>
<document_content>
// server/simulate-rounds.ts
import mongoose from 'mongoose';
import dotenv from 'dotenv';
import { Course, CreateRoundInput } from 'shared';
import RoundModel from './models/Round';
import CourseModel from './models/Course';
import UserModel from './models/User';

dotenv.config();

const MONGODB_URI = process.env.MONGODB_URI;

if (!MONGODB_URI) {
  console.error('MONGODB_URI must be defined in environment variables');
  process.exit(1);
}

// Connect to MongoDB
mongoose.connect(MONGODB_URI)
  .then(() => console.log('Connected to MongoDB'))
  .catch(err => {
    console.error('MongoDB connection error:', err);
    process.exit(1);
  });

// Generate a random score between min and max
function randomScore(min: number, max: number): number {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

// Generate a random date within a specified range
function randomDate(start: Date, end: Date): Date {
  return new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime()));
}

// Calculate differential using course rating and slope
function calculateDifferential(score: number, rating: number, slope: number): number {
  const differential = ((score - rating) * 113) / slope;
  return Math.round(differential * 10) / 10;
}

// Generate a single round
function generateRound(userId: string, course: Course, startDate: Date, endDate: Date): CreateRoundInput {
  // Select a random tee
  const teeIndex = Math.floor(Math.random() * course.tees.length);
  const selectedTee = course.tees[teeIndex];
  
  // Generate random stats
  const score = randomScore(70, 100);  // Score range
  const putts = randomScore(28, 36);   // Putts range
  const fairways = randomScore(5, selectedTee.numberOfFairways);  // Fairways hit range
  const greens = randomScore(6, 18);   // Greens in regulation range
  
  // Generate random date
  const date = randomDate(startDate, endDate);
  
  // Generate notes
  const notes = Math.random() > 0.7 ? `Practice round. Score: ${score}` : undefined;
  
  return {
    course,
    date,
    tees: selectedTee.name,
    score,
    putts,
    fairways,
    greens,
    notes,
    addedBy: userId,
  };
}

// Generate random notes for a given score
function generateNotes(score: number): string | undefined {
  const noteTemplates = [
    `Played well despite the ${score}. Driver was solid.`,
    `Struggled with putting. Need practice.`,
    `Good iron play today. Score: ${score}`,
    `Windy conditions affected my game.`,
    `Hit ${Math.floor(score / 5)} fairways. Consistent day.`,
    `Cold weather round. Proud of this ${score}.`,
    `Tournament round. Nervous at first.`,
    `Practice round focusing on course management.`
  ];
  
  // 30% chance of having notes
  if (Math.random() > 0.7) {
    const noteIndex = Math.floor(Math.random() * noteTemplates.length);
    return noteTemplates[noteIndex];
  }
  
  return undefined;
}

// Main function to simulate rounds
async function simulateRounds() {
  try {
    // Get command line arguments
    const args = process.argv.slice(2);
    const userEmail = args[0] || 'test@example.com';
    const roundCount = parseInt(args[1]) || 20;
    
    console.log(`Simulating ${roundCount} rounds for user: ${userEmail}`);
    
    // Find the user
    const user = await UserModel.findOne({ email: userEmail });
    if (!user) {
      console.error(`User with email ${userEmail} not found`);
      process.exit(1);
    }
    
    // Find available courses
    const courses = await CourseModel.find({});
    if (courses.length === 0) {
      console.error('No courses found. Please add courses first.');
      process.exit(1);
    }
    
    console.log(`Found ${courses.length} courses and user ID: ${user._id}`);
    
    // Date range for rounds (last 6 months)
    const endDate = new Date();
    const startDate = new Date();
    startDate.setMonth(startDate.getMonth() - 6);
    
    // Generate and save rounds
    const rounds = [];
    for (let i = 0; i < roundCount; i++) {
      // Select a random course
      const courseIndex = Math.floor(Math.random() * courses.length);
      const course = courses[courseIndex];
      
      // Convert course Mongoose document to Course type with proper string IDs
      const courseObj = {
        ...course.toObject(),
        _id: course._id.toString(),
        addedBy: course.addedBy.toString()
      };
      
      // Generate round data
      const roundData = generateRound(user._id.toString(), courseObj, startDate, endDate);
      
      // Create round instance
      const round = new RoundModel({
        ...roundData,
        course: course._id
      });
      
      // Calculate differential
      const selectedTee = course.tees.find(t => t.name === roundData.tees);
      if (selectedTee) {
        round.differential = calculateDifferential(
          roundData.score, 
          selectedTee.rating, 
          selectedTee.slope
        );
      }
      
      // Save round
      await round.save();
      rounds.push(round);
      
      console.log(`Created round #${i + 1}: ${roundData.score} at ${course.name}`);
    }
    
    console.log(`Successfully created ${rounds.length} rounds for user ${userEmail}`);
    return rounds;
  } catch (error) {
    console.error('Error simulating rounds:', error);
    process.exit(1);
  } finally {
    // Close the database connection
    await mongoose.disconnect();
    console.log('Disconnected from MongoDB');
  }
}

// Execute the simulation
simulateRounds().then(() => {
  console.log('Simulation completed successfully');
  process.exit(0);
}).catch(err => {
  console.error('Simulation failed:', err);
  process.exit(1);
});</document_content>
</document>
<document index="9">
<source>server/index.ts</source>
<document_content>
// server/index.ts
import express from 'express';
import mongoose from 'mongoose';
import cors from 'cors';
import dotenv from 'dotenv';
import authRoutes from './routes/auth';
import courseRoutes from './routes/courses';
import roundRoutes from './routes/rounds';
import goalRoutes from './routes/goals';

dotenv.config();

const app = express();
const PORT = process.env.PORT ? parseInt(process.env.PORT, 10) : 3000;
const MONGODB_URI = process.env.MONGODB_URI;

if (!MONGODB_URI) {
  throw new Error('MONGODB_URI must be defined in environment variables');
}

// Configure CORS - allow connections from any origin while developing
app.use(cors({
  origin: [
    'http://localhost:19006', 
    'http://localhost:19000', 
    'exp://localhost:19000',
    'http://localhost:8081',
    'exp://192.168.1.1:19000',
    'exp://192.168.1.1:19001',
    'http://192.168.1.80:19000',
    'http://192.168.1.80:19006',
    'exp://192.168.1.80:19000',
    'exp://192.168.1.80:19001',
    /^exp:\/\/.*$/,       // All Expo URLs
    /^http:\/\/localhost:.*/, // All localhost URLs
    /^http:\/\/192\.168\.1\..*/ // All local network IPs
  ],
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],
  allowedHeaders: ['Content-Type', 'Authorization', 'Accept'],
  credentials: true
}));

// Parse JSON bodies
app.use(express.json());

// Connect to MongoDB
mongoose.connect(MONGODB_URI)
  .then(() => console.log('Connected to MongoDB'))
  .catch(err => {
    console.error('MongoDB connection error:', err);
    process.exit(1);
  });

// Mount routes
app.use('/api/auth', authRoutes);
app.use('/api/courses', courseRoutes);
app.use('/api/rounds', roundRoutes);
app.use('/api/goals', goalRoutes);

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ 
    status: 'healthy',
    timestamp: new Date().toISOString()
  });
});

// API debug endpoint
app.get('/api/debug', (req, res) => {
  console.log('Debug route accessed');
  console.log('Headers:', req.headers);
  
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    routes: [
      { path: '/api/auth', methods: ['GET', 'POST'] },
      { path: '/api/courses', methods: ['GET', 'POST'] },
      { path: '/api/rounds', methods: ['GET', 'POST', 'DELETE'] },
      { path: '/api/goals', methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'] },
      { path: '/api/goals/test', methods: ['GET'] }
    ]
  });
});

// Error handling middleware
app.use((err: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {
  console.error('Server error:', err);
  res.status(500).json({
    success: false,
    message: 'Internal server error'
  });
});

// Start server - Listen on all interfaces to make it accessible over the network
const server = app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
  console.log(`Server accessible at http://localhost:${PORT} or http://192.168.1.80:${PORT}`);
});</document_content>
</document>
<document index="10">
<source>server/routes/courses.ts</source>
<document_content>
// server/routes/courses.ts
import express, { Request } from 'express';
import { Course, CreateCourseInput } from 'shared';
import CourseModel, { ICourse } from '../models/Course';
import { authenticateToken } from '../middleware/auth';

const router = express.Router();

function mapCourseToResponse(course: ICourse): Course {
  return {
    _id: course._id.toString(),
    name: course.name,
    location: course.location,
    tees: course.tees,
    addedBy: course.addedBy.toString(),
    createdAt: course.createdAt,
    updatedAt: course.updatedAt
  };
}

router.get('/', authenticateToken, async (req, res) => {
  try {
    const { search } = req.query;
    const query = search ? {
      $or: [
        { name: new RegExp(search as string, 'i') },
        { 'location.city': new RegExp(search as string, 'i') }
      ]
    } : {};

    const courses = await CourseModel.find(query).sort({ name: 1 }).limit(50);
    res.json({
      success: true,
      data: courses.map(mapCourseToResponse)
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching courses'
    });
  }
});

router.post('/', authenticateToken, async (req: Request & { user?: { _id: string } }, res) => {
  try {
    const userId = req.user?._id;
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'Unauthorized'
      });
    }

    const courseData: CreateCourseInput = {
      ...req.body,
      addedBy: userId
    };

    const course = new CourseModel(courseData);
    await course.save();

    res.status(201).json({
      success: true,
      data: mapCourseToResponse(course)
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error creating course'
    });
  }
});

router.post('/:courseId/tees', authenticateToken, async (req: Request & { user?: { _id: string } }, res) => {
  try {
    const { courseId } = req.params;
    const userId = req.user?._id;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'Unauthorized'
      });
    }

    // Find the course and verify ownership
    const course = await CourseModel.findById(courseId);
    if (!course) {
      return res.status(404).json({
        success: false,
        message: 'Course not found'
      });
    }

    if (course.addedBy.toString() !== userId) {
      return res.status(403).json({
        success: false,
        message: 'Not authorized to modify this course'
      });
    }

    // Validate tee data
    const teeData = req.body;
    if (!teeData.name || !teeData.rating || !teeData.slope || !teeData.numberOfFairways) {
      return res.status(400).json({
        success: false,
        message: 'Missing required tee information'
      });
    }

    // Validate tee data values
    if (typeof teeData.rating !== 'number' || teeData.rating < 0 || teeData.rating > 100) {
      return res.status(400).json({
        success: false,
        message: 'Invalid course rating. Must be between 0 and 100'
      });
    }

    if (typeof teeData.slope !== 'number' || teeData.slope < 55 || teeData.slope > 155) {
      return res.status(400).json({
        success: false,
        message: 'Invalid slope rating. Must be between 55 and 155'
      });
    }

    if (typeof teeData.numberOfFairways !== 'number' || 
        !Number.isInteger(teeData.numberOfFairways) || 
        teeData.numberOfFairways < 0 || 
        teeData.numberOfFairways > 18) {
      return res.status(400).json({
        success: false,
        message: 'Invalid number of fairways. Must be an integer between 0 and 18'
      });
    }

    // Check if tee color already exists
    const teeExists = course.tees.some(tee => 
      tee.name.toLowerCase() === teeData.name.toLowerCase()
    );

    if (teeExists) {
      return res.status(400).json({
        success: false,
        message: 'Tee color already exists'
      });
    }

    // Add the new tee
    course.tees.push({
      name: teeData.name.trim(),
      rating: Number(teeData.rating),
      slope: Number(teeData.slope),
      numberOfFairways: Number(teeData.numberOfFairways)
    });

    await course.save();

    res.json({
      success: true,
      data: mapCourseToResponse(course)
    });
  } catch (error) {
    console.error('Error adding tee to course:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while adding tee'
    });
  }
});

export default router;</document_content>
</document>
<document index="11">
<source>server/routes/goals.ts</source>
<document_content>
// server/routes/goals.ts
import express, { Request } from 'express';
import mongoose from 'mongoose';
import type { Goal, CreateGoalInput } from 'shared';

// Inline Goal model (since we don't have a separate file yet)
export interface IGoal {
  _id: mongoose.Types.ObjectId;
  name: string;
  targetValue: number;
  currentValue?: number;
  targetDate?: Date;
  category: 'handicap' | 'scoring' | 'fairways' | 'greens' | 'putts' | 'custom';
  achieved: boolean;
  completedAt?: Date;
  description?: string;
  addedBy: mongoose.Types.ObjectId;
  createdAt: Date;
  updatedAt: Date;
}

const goalSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  targetValue: {
    type: Number,
    required: true
  },
  currentValue: {
    type: Number
  },
  targetDate: {
    type: Date
  },
  category: {
    type: String,
    enum: ['handicap', 'scoring', 'fairways', 'greens', 'putts', 'custom'],
    required: true
  },
  achieved: {
    type: Boolean,
    default: false
  },
  description: {
    type: String,
    trim: true
  },
  addedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  }
}, {
  timestamps: true
});

// Create the model directly in this file
// Use mongoose.models to check if the model is already defined
const GoalModel = mongoose.models.Goal || mongoose.model<IGoal>('Goal', goalSchema);

import { authenticateToken } from '../middleware/auth';

interface AuthRequest extends Request {
  user?: {
    _id: string;
    email: string;
  };
}

const router = express.Router();

function mapGoalToResponse(goal: IGoal): Goal {
  const mappedGoal = {
    _id: goal._id.toString(),
    name: goal.name,
    targetValue: goal.targetValue,
    currentValue: goal.currentValue,
    targetDate: goal.targetDate,
    category: goal.category,
    achieved: goal.achieved,
    completedAt: goal.completedAt ? goal.completedAt.toISOString() : undefined,
    description: goal.description,
    addedBy: goal.addedBy.toString(),
    createdAt: goal.createdAt,
    updatedAt: goal.updatedAt
  };
  
  // Log putts goals to track issues
  if (goal.category === 'putts') {
    console.log(`[SERVER] Mapping putts goal to response: ID: ${mappedGoal._id}, Name: ${mappedGoal.name}, ` +
                `Value: ${mappedGoal.currentValue}, Raw Value: ${goal.currentValue}, ` +
                `Achieved: ${mappedGoal.achieved}`);
  }
  
  return mappedGoal;
}

// Debug middleware for goals routes
router.use((req: Request & { user?: any }, res, next) => {
  console.log(`Goals route requested: ${req.method} ${req.url}`);
  console.log('Headers:', req.headers);
  console.log('User:', req.user || 'No user on request yet');
  next();
});

// Test route - no authentication required
router.get('/test', (req, res) => {
  console.log('Test route hit');
  res.json({
    success: true,
    message: 'Goals API is working',
    timestamp: new Date().toISOString()
  });
});

// Get all goals for authenticated user
router.get('/', authenticateToken, async (req: AuthRequest, res) => {
  try {
    console.log('GET /goals handler called');
    const userId = req.user?._id;
    if (!userId) {
      console.log('User not authenticated');
      return res.status(401).json({
        success: false,
        message: 'User not authenticated'
      });
    }

    console.log(`Finding goals for user: ${userId}`);
    const goals = await GoalModel.find({ addedBy: userId }).sort({ createdAt: -1 });
    console.log(`Found ${goals.length} goals`);
    
    const mappedGoals = goals.map(goal => mapGoalToResponse(goal));

    console.log('Sending goals response');
    res.json({
      success: true,
      data: mappedGoals
    });
  } catch (error) {
    console.error('Error fetching goals:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching goals'
    });
  }
});

// Create a new goal
router.post('/', authenticateToken, async (req: AuthRequest, res) => {
  try {
    const userId = req.user?._id;
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User not authenticated'
      });
    }

    // Log request body for debugging
    console.log(`[SERVER] Creating goal: category=${req.body.category}, currentValue=${req.body.currentValue}, achieved=${req.body.achieved}`);
    
    // Allow achieved and completedAt to be set on creation
    const goal = new GoalModel({
      ...req.body,
      addedBy: userId,
      // Only override achieved if not provided
      achieved: req.body.achieved !== undefined ? req.body.achieved : false
    });

    await goal.save();
    
    console.log(`[SERVER] Created goal: ID=${goal._id}, currentValue=${goal.currentValue}, achieved=${goal.achieved}`);

    res.status(201).json({
      success: true,
      data: mapGoalToResponse(goal)
    });
  } catch (error) {
    console.error('Error creating goal:', error);
    res.status(400).json({
      success: false,
      message: 'Error creating goal'
    });
  }
});

// Update a goal
router.put('/:id', authenticateToken, async (req: AuthRequest, res) => {
  try {
    const userId = req.user?._id;
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User not authenticated'
      });
    }

    const goalId = req.params.id;
    const goal = await GoalModel.findOneAndUpdate(
      { _id: goalId, addedBy: userId },
      { ...req.body },
      { new: true, runValidators: true }
    );

    if (!goal) {
      return res.status(404).json({
        success: false,
        message: 'Goal not found or you do not have permission to update it'
      });
    }

    res.json({
      success: true,
      data: mapGoalToResponse(goal)
    });
  } catch (error) {
    console.error('Error updating goal:', error);
    res.status(400).json({
      success: false,
      message: 'Error updating goal'
    });
  }
});

// Toggle goal achievement status
router.patch('/:id/achievement', authenticateToken, async (req: AuthRequest, res) => {
  try {
    const userId = req.user?._id;
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User not authenticated'
      });
    }

    const { achieved } = req.body;
    if (typeof achieved !== 'boolean') {
      return res.status(400).json({
        success: false,
        message: 'The achieved property must be a boolean'
      });
    }

    const goalId = req.params.id;
    
    // Update object based on whether goal is being achieved or unmarked
    let updateObj: any = {};
    
    if (achieved) {
      updateObj = { 
        achieved, 
        completedAt: req.body.completedAt || new Date()
      };
      
      // If currentValue is provided, store it
      if (req.body.currentValue !== undefined) {
        updateObj.currentValue = req.body.currentValue;
        console.log(`Saving currentValue ${req.body.currentValue} for goal ${goalId}`);
      } else {
        // Find the current goal to ensure we don't lose the value
        const currentGoal = await GoalModel.findById(goalId);
        if (currentGoal && currentGoal.currentValue !== undefined) {
          updateObj.currentValue = currentGoal.currentValue;
          console.log(`PRESERVING existing currentValue ${currentGoal.currentValue} for goal ${goalId}`);
        } else {
          console.log(`WARNING: No currentValue provided for goal ${goalId} when marking as achieved`);
        }
      }
    } else {
      updateObj = { 
        achieved, 
        $unset: { completedAt: "" } 
      };
    }
    
    // If this is a putts goal, log the update operation
    const existingGoal = await GoalModel.findOne({ _id: goalId, addedBy: userId });
    if (existingGoal && existingGoal.category === 'putts') {
      console.log(`[SERVER] Before update putts goal ${goalId}: currentValue=${existingGoal.currentValue}, achieved=${existingGoal.achieved}`);
      console.log(`[SERVER] Update object for putts goal: ${JSON.stringify(updateObj)}`);
    }
    
    const goal = await GoalModel.findOneAndUpdate(
      { _id: goalId, addedBy: userId },
      updateObj,
      { new: true }
    );
    
    // Log the result for putts goals
    if (goal && goal.category === 'putts') {
      console.log(`[SERVER] After update putts goal ${goalId}: currentValue=${goal.currentValue}, achieved=${goal.achieved}`);
    }

    if (!goal) {
      return res.status(404).json({
        success: false,
        message: 'Goal not found or you do not have permission to update it'
      });
    }

    res.json({
      success: true,
      data: mapGoalToResponse(goal)
    });
  } catch (error) {
    console.error('Error toggling goal achievement:', error);
    res.status(400).json({
      success: false,
      message: 'Error toggling goal achievement'
    });
  }
});

// Delete a goal
router.delete('/:id', authenticateToken, async (req: AuthRequest, res) => {
  try {
    const userId = req.user?._id;
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User not authenticated'
      });
    }

    const goalId = req.params.id;
    const goal = await GoalModel.findOneAndDelete({ _id: goalId, addedBy: userId });

    if (!goal) {
      return res.status(404).json({
        success: false,
        message: 'Goal not found or you do not have permission to delete it'
      });
    }

    res.json({
      success: true,
      message: 'Goal deleted successfully'
    });
  } catch (error) {
    console.error('Error deleting goal:', error);
    res.status(500).json({
      success: false,
      message: 'Error deleting goal'
    });
  }
});

export default router;</document_content>
</document>
<document index="12">
<source>server/routes/rounds.ts</source>
<document_content>
// server/routes/rounds.ts
import express, { Request } from 'express';
import { Round, Course } from 'shared';
import RoundModel, { IRound } from '../models/Round';
import { ICourse } from '../models/Course';
import { authenticateToken } from '../middleware/auth';
import { Document, PopulatedDoc } from 'mongoose';

interface AuthRequest extends Request {
  user?: {
    _id: string;
    email: string;
  };
}

// Define an interface for a populated round document
interface PopulatedRound extends Omit<IRound, 'course'> {
  course: ICourse;
}

const router = express.Router();

function calculateDifferential(round: PopulatedRound): number {
  const tee = round.course.tees.find(t => t.name === round.tees);
  if (!tee) {
    throw new Error('Selected tee not found on course');
  }

  const differential = ((round.score - tee.rating) * 113) / tee.slope;
  return Math.round(differential * 10) / 10;
}

function mapCourseToResponse(course: any) {
  return {
    _id: course._id.toString(),
    name: course.name,
    location: course.location,
    tees: course.tees,
    addedBy: course.addedBy.toString(),
    createdAt: course.createdAt,
    updatedAt: course.updatedAt
  };
}

function mapRoundToResponse(round: PopulatedRound): Round {
  return {
    _id: round._id.toString(),
    course: mapCourseToResponse(round.course),
    date: round.date,
    tees: round.tees,
    score: round.score,
    putts: round.putts,
    fairways: round.fairways,
    greens: round.greens,
    notes: round.notes,
    differential: round.differential,
    addedBy: round.addedBy.toString(),
    createdAt: round.createdAt,
    updatedAt: round.updatedAt
  };
}

router.post('/', authenticateToken, async (req: AuthRequest, res) => {
  try {
    const userId = req.user?._id;
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User not authenticated'
      });
    }

    // Create round instance but don't save yet
    const round = new RoundModel({
      ...req.body,
      addedBy: userId
    });

    // Populate course data for differential calculation
    await round.populate<{ course: ICourse }>('course');

    // Now we can safely access the populated course data
    const populatedRound = round as unknown as PopulatedRound;
    
    // Calculate and set differential
    const differential = calculateDifferential(populatedRound);
    round.differential = differential;

    // Save the round with the calculated differential
    await round.save();

    res.status(201).json({
      success: true,
      data: mapRoundToResponse(populatedRound)
    });
  } catch (error) {
    console.error('Error creating round:', {
      error,
      roundData: req.body,
      userId: req.user?._id
    });
    
    if (error instanceof Error) {
      const errorMessage = error.message || 'Error creating round';
      res.status(400).json({
        success: false,
        message: errorMessage
      });
    } else {
      res.status(500).json({
        success: false,
        message: 'Internal server error creating round'
      });
    }
  }
});

interface PopulatedRound extends Omit<IRound, 'course'> {
  course: ICourse;
}

router.get('/', authenticateToken, async (req: AuthRequest, res) => {
  try {
    const userId = req.user?._id;
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User not authenticated'
      });
    }

    const rounds = await RoundModel.find({ addedBy: userId })
      .populate<{ course: ICourse }>('course')
      .sort({ date: -1 });

    const mappedRounds = rounds.map(round => {
      const roundObj = round.toObject();
      return {
        ...roundObj,
        _id: roundObj._id.toString(),
        course: {
          ...roundObj.course,
          _id: roundObj.course._id.toString(),
          addedBy: roundObj.course.addedBy.toString()
        },
        addedBy: roundObj.addedBy.toString()
      };
    });

    res.json({
      success: true,
      data: mappedRounds
    });
  } catch (error) {
    console.error('Error fetching rounds:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching rounds'
    });
  }
});

// DELETE a round
router.delete('/:id', authenticateToken, async (req: AuthRequest, res) => {
  try {
    const userId = req.user?._id;
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User not authenticated'
      });
    }

    const roundId = req.params.id;
    
    // Find the round and make sure it belongs to the user
    const round = await RoundModel.findOne({ 
      _id: roundId,
      addedBy: userId 
    });
    
    if (!round) {
      return res.status(404).json({
        success: false,
        message: 'Round not found or you do not have permission to delete it'
      });
    }
    
    // Delete the round
    await RoundModel.deleteOne({ _id: roundId });
    
    res.json({
      success: true,
      message: 'Round deleted successfully'
    });
  } catch (error) {
    console.error('Error deleting round:', error);
    res.status(500).json({
      success: false,
      message: 'Error deleting round'
    });
  }
});

export default router;</document_content>
</document>
<document index="13">
<source>server/routes/auth.ts</source>
<document_content>
// server/routes/auth.ts
import express from 'express';
import jwt from 'jsonwebtoken';
import { z } from 'zod';
import { User } from 'shared';
import UserModel, { IUser } from '../models/User';
import GoalModel from '../models/Goal';
import { authenticateToken, mapUserToResponse } from '../middleware/auth';
import { Request } from 'express';

const router = express.Router();

async function getPopulatedUser(userId: string) {
  return await UserModel.findById(userId)
    .select('-password')
    .populate({
      path: 'rounds',
      populate: {
        path: 'course'
      }
    })
    .populate('savedCourses');
}

router.use((req, res, next) => {
  console.log('Auth Route:', req.method, req.path);
  console.log('Headers:', req.headers);
  next();
});

const signupSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
  name: z.string().min(1)
});

const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8)
});

function generateToken(user: IUser): string {
  if (!process.env.JWT_SECRET) {
    throw new Error('JWT_SECRET is not defined');
  }
  
  return jwt.sign(
    { userId: user._id.toString(), email: user.email },
    process.env.JWT_SECRET,
    { expiresIn: '30d' } // Extended token expiration to 30 days
  );
}

router.get('/validate', authenticateToken, async (req: Request & { user?: IUser }, res) => {
  try {
    if (!req.user?._id) {
      return res.status(401).json({
        success: false,
        message: 'User not found'
      });
    }

    // Get user with populated data including rounds and courses
    const user = await getPopulatedUser(req.user._id.toString());
    if (!user) {
      return res.status(401).json({
        success: false,
        message: 'User not found'
      });
    }
    
    // Also fetch the user's goals
    const goals = await GoalModel.find({ addedBy: req.user._id });

    res.json({
      success: true,
      data: {
        user: {
          ...user.toObject({
            transform: (doc, ret) => {
              ret._id = ret._id.toString();
              ret.rounds = ret.rounds.map((round: any) => ({
                ...round,
                _id: round._id.toString(),
                addedBy: round.addedBy.toString(),
                course: {
                  ...round.course,
                  _id: round.course._id.toString(),
                  addedBy: round.course.addedBy.toString()
                }
              }));
              ret.savedCourses = ret.savedCourses.map((course: any) => ({
                ...course,
                _id: course._id.toString(),
                addedBy: course.addedBy.toString()
              }));
              return ret;
            }
          }),
          goals: goals.map((goal: any) => ({
            ...goal.toObject(),
            _id: goal._id.toString(),
            addedBy: goal.addedBy.toString()
          }))
        },
        token: req.headers.authorization?.split(' ')[1]
      }
    });
  } catch (error) {
    console.error('Token validation error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

router.post('/signup', async (req, res) => {
  try {
    const validatedData = signupSchema.parse(req.body);
    const existingUser = await UserModel.findOne({
      email: { $regex: new RegExp(`^${validatedData.email}$`, 'i') }
    });

    if (existingUser) {
      return res.status(400).json({
        success: false,
        message: 'Email already registered'
      });
    }

    const user = new UserModel(validatedData);
    await user.save();

    const token = generateToken(user);

    res.status(201).json({
      success: true,
      data: {
        user: mapUserToResponse(user),
        token
      }
    });
  } catch (error) {
    console.error('Signup error:', error);
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        success: false,
        message: 'Validation error',
        errors: error.errors
      });
    }
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

router.post('/login', async (req, res) => {
  try {
    const validatedData = loginSchema.parse(req.body);
    const user = await UserModel.findOne({
      email: { $regex: new RegExp(`^${validatedData.email}$`, 'i') }
    });

    if (!user) {
      return res.status(401).json({
        success: false,
        message: 'Invalid credentials'
      });
    }

    const isValidPassword = await user.comparePassword(validatedData.password);
    if (!isValidPassword) {
      return res.status(401).json({
        success: false,
        message: 'Invalid credentials'
      });
    }

    const token = generateToken(user);

    res.json({
      success: true,
      data: {
        user: mapUserToResponse(user),
        token
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        success: false,
        message: 'Validation error',
        errors: error.errors
      });
    }
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

export default router;</document_content>
</document>
<document index="2">
<source>shared/dist/types/goal.d.ts</source>
<document_content>
import { BaseDocument } from './base';
export interface Goal extends BaseDocument {
    name: string;
    targetValue: number;
    currentValue?: number;
    targetDate?: Date | string;
    category: 'handicap' | 'scoring' | 'fairways' | 'greens' | 'putts' | 'custom';
    achieved: boolean;
    completedAt?: Date | string;
    description?: string;
    addedBy: string;
}
export interface CreateGoalInput {
    name: string;
    targetValue: number;
    targetDate?: Date | string;
    currentValue?: number;
    category: 'handicap' | 'scoring' | 'fairways' | 'greens' | 'putts' | 'custom';
    description?: string;
}
</document_content>
</document>
<document index="3">
<source>shared/dist/types/course.d.ts</source>
<document_content>
import { BaseDocument } from './base';
export interface Course extends BaseDocument {
    name: string;
    location: {
        city?: string;
        state?: string;
        country?: string;
    };
    tees: Array<{
        name: string;
        rating: number;
        slope: number;
        numberOfFairways: number;
    }>;
    addedBy: string;
}
export interface CreateCourseInput {
    name: string;
    location: {
        city?: string;
        state?: string;
        country?: string;
    };
    addedBy: string;
}
</document_content>
</document>
<document index="4">
<source>shared/dist/types/user.d.ts</source>
<document_content>
import { BaseDocument } from './base';
import { Round } from './round';
import { Course } from './course';
import { Goal } from './goal';
export interface User extends BaseDocument {
    email: string;
    name?: string;
    savedCourses: Course[];
    rounds: Round[];
    goals?: Goal[];
}
export interface CreateUserInput {
    email: string;
    password: string;
    name?: string;
}
</document_content>
</document>
<document index="5">
<source>shared/dist/types/base.d.ts</source>
<document_content>
export interface BaseDocument {
    _id: string;
    createdAt: Date | string;
    updatedAt: Date | string;
}
</document_content>
</document>
<document index="6">
<source>shared/dist/types/round.d.ts</source>
<document_content>
import { BaseDocument } from './base';
import { Course } from './course';
export interface Round extends BaseDocument {
    course: Course;
    date: Date | string;
    tees: string;
    score: number;
    putts: number;
    fairways: number;
    greens: number;
    notes?: string;
    differential: number;
    addedBy: string;
}
export interface CreateRoundInput {
    course: Course;
    date: Date | string;
    tees: string;
    score: number;
    putts: number;
    fairways: number;
    greens: number;
    notes?: string;
    addedBy: string;
}
</document_content>
</document>
<document index="7">
<source>shared/dist/index.d.ts</source>
<document_content>
export * from './types/user';
export * from './types/course';
export * from './types/round';
export * from './types/goal';
</document_content>
</document>
<document index="8">
<source>shared/src/types/base.ts</source>
<document_content>
// shared/src/types/base.ts
export interface BaseDocument {
  _id: string;
  createdAt: Date | string; // Allow both types for flexibility between server and client
  updatedAt: Date | string; // Allow both types for flexibility between server and client
}
</document_content>
</document>
<document index="9">
<source>shared/src/types/goal.ts</source>
<document_content>
// shared/src/types/goal.ts
import { BaseDocument } from './base';

export interface Goal extends BaseDocument {
  name: string;
  targetValue: number;
  currentValue?: number;
  targetDate?: Date | string; // Allow both types for flexibility
  category: 'handicap' | 'scoring' | 'fairways' | 'greens' | 'putts' | 'custom';
  achieved: boolean;
  completedAt?: Date | string; // Allow both types for flexibility
  description?: string;
  addedBy: string;
}

export interface CreateGoalInput {
  name: string;
  targetValue: number;
  targetDate?: Date | string; // Allow both types for flexibility
  currentValue?: number;
  category: 'handicap' | 'scoring' | 'fairways' | 'greens' | 'putts' | 'custom';
  description?: string;
}</document_content>
</document>
<document index="10">
<source>shared/src/types/round.ts</source>
<document_content>
import { BaseDocument } from './base';
import { Course } from './course';
export interface Round extends BaseDocument {
  course: Course;
  date: Date | string;
  tees: string;
  score: number;
  putts: number;
  fairways: number;
  greens: number;
  notes?: string;
  differential: number;
  addedBy: string;
}

export interface CreateRoundInput {
  course: Course;
  date: Date | string;
  tees: string;
  score: number;
  putts: number;
  fairways: number;
  greens: number;
  notes?: string;
  addedBy: string;
}</document_content>
</document>
<document index="11">
<source>shared/src/types/course.ts</source>
<document_content>
// shared/src/types/course.ts
import { BaseDocument } from './base';

export interface Course extends BaseDocument {
  name: string;
  location: {
    city?: string;
    state?: string;
    country?: string;
  };
  tees: Array<{
    name: string;
    rating: number;
    slope: number;
    numberOfFairways: number;
  }>;
  addedBy: string;
}

export interface CreateCourseInput {
  name: string;
  location: {
    city?: string;
    state?: string;
    country?: string;
  };
  addedBy: string;
}</document_content>
</document>
<document index="12">
<source>shared/src/types/user.ts</source>
<document_content>
// shared/src/types/user.ts
import { BaseDocument } from './base';
import { Round } from './round';
import { Course } from './course';
import { Goal } from './goal';

export interface User extends BaseDocument {
  email: string;
  name?: string;
  savedCourses: Course[];
  rounds: Round[];
  goals?: Goal[];
}

export interface CreateUserInput {
  email: string;
  password: string;
  name?: string;
}</document_content>
</document>
<document index="13">
<source>shared/src/index.ts</source>
<document_content>
// shared/src/index.ts
export * from './types/user';
export * from './types/course';
export * from './types/round';
export * from './types/goal';</document_content>
</document>
</documents>
