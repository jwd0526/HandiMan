<documents>
<document index="1">
<source>directory-structure.txt</source>
<document_content>
.
├── golf-tracker
│   ├── src
│   │   ├── components
│   │   │   ├── common
│   │   │   │   ├── BackButton
│   │   │   │   │   ├── index.tsx
│   │   │   │   │   └── styles.ts
│   │   │   │   ├── ErrorBoundary
│   │   │   │   │   ├── index.tsx
│   │   │   │   │   └── styles.ts
│   │   │   │   └── LoadingScreen
│   │   │   │       ├── index.tsx
│   │   │   │       └── styles.ts
│   │   │   ├── course
│   │   │   │   ├── CourseSearch
│   │   │   │   │   ├── index.tsx
│   │   │   │   │   └── styles.ts
│   │   │   │   └── TeeSelector
│   │   │   │       ├── index.tsx
│   │   │   │       └── styles.ts
│   │   │   ├── forms
│   │   │   │   ├── FormButton
│   │   │   │   │   ├── index.tsx
│   │   │   │   │   └── styles.ts
│   │   │   │   └── FormInput
│   │   │   │       ├── index.tsx
│   │   │   │       └── styles.ts
│   │   │   ├── layout
│   │   │   │   ├── AuthLayout
│   │   │   │   │   ├── index.tsx
│   │   │   │   │   └── styles.ts
│   │   │   │   └── MainLayout
│   │   │   │       ├── index.tsx
│   │   │   │       └── styles.ts
│   │   │   ├── providers
│   │   │   │   ├── AuthProvider.tsx
│   │   │   │   └── CourseProvider.tsx
│   │   │   └── round
│   │   │       └── RoundDetails
│   │   │           ├── index.tsx
│   │   │           └── styles.ts
│   │   ├── config
│   │   │   ├── constants.ts
│   │   │   ├── navigation.ts
│   │   │   └── theme.ts
│   │   ├── hooks
│   │   │   ├── useAuth.ts
│   │   │   ├── useCourses.ts
│   │   │   ├── useForm.ts
│   │   │   └── useRounds.ts
│   │   ├── screens
│   │   │   ├── Home
│   │   │   │   ├── index.tsx
│   │   │   │   └── styles.ts
│   │   │   ├── auth
│   │   │   │   ├── Landing
│   │   │   │   │   ├── index.tsx
│   │   │   │   │   └── styles.ts
│   │   │   │   ├── Login
│   │   │   │   │   ├── index.tsx
│   │   │   │   │   └── styles.ts
│   │   │   │   └── Signup
│   │   │   │       ├── index.tsx
│   │   │   │       └── styles.ts
│   │   │   └── rounds
│   │   │       ├── AddRound
│   │   │       │   ├── index.tsx
│   │   │       │   └── styles.ts
│   │   │       └── AllRounds
│   │   │           ├── index.tsx
│   │   │           └── styles.ts
│   │   ├── services
│   │   │   ├── api
│   │   │   │   ├── auth.ts
│   │   │   │   ├── courses.ts
│   │   │   │   └── rounds.ts
│   │   │   └── storage
│   │   │       └── secureStorage.ts
│   │   ├── types
│   │   │   └── navigation.ts
│   │   └── utils
│   │       ├── date.ts
│   │       ├── handicap.ts
│   │       └── validation.ts
│   ├── .DS_Store
│   ├── .gitignore
│   ├── App.tsx
│   ├── app.json
│   ├── index.js
│   ├── package-lock.json
│   ├── package.json
│   └── tsconfig.json
├── server
│   ├── middleware
│   │   └── auth.ts
│   ├── models
│   │   ├── Course.ts
│   │   ├── Round.ts
│   │   └── User.ts
│   ├── routes
│   │   ├── auth.ts
│   │   ├── courses.ts
│   │   └── rounds.ts
│   ├── .DS_Store
│   ├── .env
│   ├── index.ts
│   ├── package-lock.json
│   ├── package.json
│   └── tsconfig.json
├── shared
│   ├── src
│   │   ├── types
│   │   │   ├── base.ts
│   │   │   ├── course.ts
│   │   │   ├── round.ts
│   │   │   └── user.ts
│   │   └── index.ts
│   ├── package-lock.json
│   ├── package.json
│   └── tsconfig.json
├── .DS_Store
├── .gitignore
├── app_doc.txt
├── dev.sh
├── document-app.sh
└── package-lock.json

43 directories, 84 files
</document_content>
</document>
<document index="2">
<source>golf-tracker/App.tsx</source>
<document_content>
// App.tsx
import React, { useMemo } from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { StatusBar } from 'expo-status-bar';
import { SafeAreaProvider } from 'react-native-safe-area-context';

// Screens
import { LandingScreen } from './src/screens/auth/Landing';
import { LoginScreen } from './src/screens/auth/Login';
import { SignupScreen } from './src/screens/auth/Signup';
import { HomeScreen } from './src/screens/Home';
import { AddRoundScreen } from './src/screens/rounds/AddRound';
import { AllRoundsScreen } from './src/screens/rounds/AllRounds';

// Types
import { AuthStackParamList, MainStackParamList } from './src/config/navigation';

// Auth Context
import { AuthProvider, useAuthContext } from './src/components/providers/AuthProvider';

const AuthStack = createNativeStackNavigator<AuthStackParamList>();
const MainStack = createNativeStackNavigator<MainStackParamList>();

const AuthNavigator = React.memo(() => {
  return (
    <AuthStack.Navigator
      id={null}
      screenOptions={{
        headerShown: false,
        contentStyle: { backgroundColor: '#fff' }
      }}
    >
      <AuthStack.Screen name="Landing" component={LandingScreen} />
      <AuthStack.Screen name="Login" component={LoginScreen} />
      <AuthStack.Screen name="Signup" component={SignupScreen} />
    </AuthStack.Navigator>
  );
});

const MainNavigator = React.memo(() => {
  return (
    <MainStack.Navigator
      id={null}
      screenOptions={{
        headerShown: false,
        contentStyle: { backgroundColor: '#fff' }
      }}
    >
      <MainStack.Screen name="Home" component={HomeScreen} />
      <MainStack.Screen name="AddRound" component={AddRoundScreen} />
      <MainStack.Screen name="AllRounds" component={AllRoundsScreen} />
    </MainStack.Navigator>
  );
});

const Navigation = React.memo(() => {
  const { user, loading } = useAuthContext();

  const navigator = useMemo(() => {
    if (loading) return null;
    return user ? <MainNavigator /> : <AuthNavigator />;
  }, [user, loading]);
  
  return (
    <NavigationContainer>
      {navigator}
    </NavigationContainer>
  );
});

export default function App() {
  return (
    <SafeAreaProvider>
      <AuthProvider>
        <StatusBar style="auto" />
        <Navigation />
      </AuthProvider>
    </SafeAreaProvider>
  );
}</document_content>
</document>
<document index="3">
<source>golf-tracker/src/types/navigation.ts</source>
<document_content>
// src/types/navigation.ts
export type AuthStackParamList = {
  Landing: undefined;
  Login: undefined;
  Signup: undefined;
};

export type MainStackParamList = {
  Home: undefined;
  AddRound: undefined;
  AddCourse: undefined;
  AllRounds: undefined;
};</document_content>
</document>
<document index="4">
<source>golf-tracker/src/config/navigation.ts</source>
<document_content>
// src/config/navigation.ts
import { NavigatorScreenParams } from '@react-navigation/native';

// Auth Stack
export type AuthStackParamList = {
  Landing: undefined;
  Login: undefined;
  Signup: undefined;
};

// Main Stack
export type MainStackParamList = {
  Home: undefined;
  AddRound: undefined;
  AllRounds: undefined;
  CourseDetails: { courseId: string };
  Profile: undefined;
  Settings: undefined;
};

// Root Stack
export type RootStackParamList = {
  Auth: NavigatorScreenParams<AuthStackParamList>;
  Main: NavigatorScreenParams<MainStackParamList>;
};

// Type helpers for useNavigation hook
declare global {
  namespace ReactNavigation {
    interface RootParamList extends RootStackParamList {}
  }
}</document_content>
</document>
<document index="5">
<source>golf-tracker/src/config/constants.ts</source>
<document_content>
// src/config/constants.ts
export const API_URL = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:3000/api';

// Animation durations
export const ANIMATION = {
  DURATION: {
    FAST: 200,
    NORMAL: 300,
    SLOW: 500
  }
};

// Form validation limits
export const VALIDATION = {
  PASSWORD_MIN_LENGTH: 8,
  NAME_MAX_LENGTH: 50,
  EMAIL_MAX_LENGTH: 100,
  NOTES_MAX_LENGTH: 500
};

// Storage keys
export const STORAGE = {
  AUTH_TOKEN: 'auth_token',
  USER_DATA: 'user_data',
  SETTINGS: 'user_settings',
  RECENT_COURSES: 'recent_courses'
} as const;

// Limits and thresholds
export const LIMITS = {
  MAX_RECENT_COURSES: 5,
  MAX_ROUNDS_PER_PAGE: 20,
  MAX_SEARCH_RESULTS: 50,
  MIN_SEARCH_CHARS: 2
};

// Date formats
export const DATE_FORMATS = {
  DISPLAY: 'MMM D, YYYY',
  API: 'YYYY-MM-DD',
  MONTH_YEAR: 'MMMM YYYY'
};

// Golf specific constants
export const GOLF = {
  MAX_HOLE_SCORE: 15,
  MIN_COURSE_RATING: 55,
  MAX_COURSE_RATING: 155,
  MAX_FAIRWAYS: 18,
  MAX_GREENS: 18,
  MAX_PUTTS_PER_HOLE: 6,
  HANDICAP_ROUNDS_REQUIRED: 3
};

// Error messages
export const ERROR_MESSAGES = {
  NETWORK: 'Please check your internet connection and try again.',
  SERVER: 'Something went wrong on our end. Please try again later.',
  AUTH: {
    INVALID_CREDENTIALS: 'Invalid email or password',
    EMAIL_IN_USE: 'This email is already registered',
    WEAK_PASSWORD: 'Password must be at least 8 characters and include uppercase, lowercase, and numbers'
  },
  VALIDATION: {
    REQUIRED: 'This field is required',
    INVALID_EMAIL: 'Please enter a valid email address',
    PASSWORD_MISMATCH: 'Passwords do not match',
    INVALID_SCORE: 'Please enter a valid score'
  }
};

// App info
export const APP_INFO = {
  NAME: 'HandiMan',
  VERSION: '1.0.0',
  DESCRIPTION: 'Your personal golf handicap tracker',
  SUPPORT_EMAIL: 'support@handiman.app',
  PRIVACY_POLICY_URL: 'https://handiman.app/privacy',
  TERMS_URL: 'https://handiman.app/terms'
};</document_content>
</document>
<document index="6">
<source>golf-tracker/src/config/theme.ts</source>
<document_content>
// src/config/theme.ts
import { Platform } from 'react-native';

export const colors = {
  // Primary colors
  primary: '#2f95dc',
  primaryLight: '#5fb4e8',
  primaryDark: '#1c7ab8',

  // Secondary colors
  secondary: '#32cd32',
  secondaryLight: '#66d966',
  secondaryDark: '#28a428',

  // Neutral colors
  background: '#ffffff',
  surface: '#f5f5f5',
  text: '#333333',
  textSecondary: '#666666',
  border: '#dddddd',

  // State colors
  success: '#28a745',
  error: '#dc3545',
  warning: '#ffc107',
  info: '#17a2b8',

  // Specific UI colors
  divider: '#eeeeee',
  placeholder: '#999999',
  disabled: '#cccccc',
  overlay: 'rgba(0, 0, 0, 0.5)'
};

export const spacing = {
  xs: 4,
  sm: 8,
  md: 16,
  lg: 24,
  xl: 32,
  xxl: 48
};

export const typography = {
  sizes: {
    xs: 12,
    sm: 14,
    md: 16,
    lg: 20,
    xl: 24,
    xxl: 32
  },
  weights: {
    regular: '400',
    medium: '500',
    semibold: '600',
    bold: '700'
  },
  families: {
    regular: Platform.select({ ios: 'System', android: 'Roboto' }),
    medium: Platform.select({ ios: 'System', android: 'Roboto' }),
    bold: Platform.select({ ios: 'System', android: 'Roboto' }),
  }
};

export const borderRadius = {
  sm: 4,
  md: 8,
  lg: 12,
  xl: 16,
  round: 9999
};

export const shadows = {
  sm: Platform.select({
    ios: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 1 },
      shadowOpacity: 0.18,
      shadowRadius: 1.0
    },
    android: {
      elevation: 1
    }
  }),
  md: Platform.select({
    ios: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.22,
      shadowRadius: 2.22
    },
    android: {
      elevation: 3
    }
  }),
  lg: Platform.select({
    ios: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: 0.25,
      shadowRadius: 3.84
    },
    android: {
      elevation: 5
    }
  })
};

// Common style mixins
export const mixins = {
  row: {
    flexDirection: 'row' as const,
    alignItems: 'center' as const
  },
  center: {
    justifyContent: 'center' as const,
    alignItems: 'center' as const
  },
  shadow: shadows.md,
  card: {
    backgroundColor: colors.background,
    borderRadius: borderRadius.md,
    padding: spacing.md,
    ...shadows.md
  }
};</document_content>
</document>
<document index="7">
<source>golf-tracker/src/utils/validation.ts</source>
<document_content>
// src/utils/validation.ts
type ValidationRule<T> = {
    validate: (value: any, formValues: T) => boolean;
    message: string;
  };
  
  export const required = <T extends Record<string, any>>(message = 'This field is required'): ValidationRule<T> => ({
    validate: (value: any) => {
      if (typeof value === 'string') return value.trim().length > 0;
      if (typeof value === 'number') return true;
      if (Array.isArray(value)) return value.length > 0;
      return value !== null && value !== undefined;
    },
    message
  });
  
  export const email = <T extends Record<string, any>>(message = 'Please enter a valid email'): ValidationRule<T> => ({
    validate: (value: any) => {
      if (typeof value !== 'string') return false;
      return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value);
    },
    message
  });
  
  export const minLength = <T extends Record<string, any>>(
    length: number,
    message = `Must be at least ${length} characters`
  ): ValidationRule<T> => ({
    validate: (value: any) => {
      if (typeof value !== 'string') return false;
      return value.length >= length;
    },
    message
  });
  
  export const matches = <T extends Record<string, any>>(
    pattern: RegExp,
    message: string
  ): ValidationRule<T> => ({
    validate: (value: any) => {
      if (typeof value !== 'string') return false;
      return pattern.test(value);
    },
    message
  });
  
  export const matchesField = <T extends Record<string, any>>(
    fieldToMatch: keyof T,
    message: string
  ): ValidationRule<T> => ({
    validate: (value: any, formValues: T) => value === formValues[fieldToMatch],
    message
  });</document_content>
</document>
<document index="8">
<source>golf-tracker/src/utils/date.ts</source>
<document_content>
</document_content>
</document>
<document index="9">
<source>golf-tracker/src/utils/handicap.ts</source>
<document_content>
import { Round } from "shared";

export const calculateHandicap = (rounds: Round[]) => {
  if (rounds.length < 3) return 0;

  // Get the last 20 rounds
  const recentRounds = [...rounds]
    .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
    .slice(0, 20);
  console.log(recentRounds);
  // Extract and sort differentials
  const difs = recentRounds
    .map((round) => round.differential)
    .sort((a, b) => a - b);

  console.log(difs);

  // Calculate handicap based on number of rounds
  switch (difs.length) {
    case 3:
      return Math.round((difs[0] - 2) * 10) / 10;
    case 4:
      return Math.round((difs[0] - 1) * 10) / 10;
    case 5:
      return Math.round(difs[0] * 10) / 10;
    case 6:
      return Math.round(((difs[0] + difs[1]) / 2 - 1) * 10) / 10;
    case 7:
    case 8:
      return Math.round(((difs[0] + difs[1]) / 2) * 10) / 10;
    case 9:
    case 10:
    case 11:
      return Math.round(((difs[0] + difs[1] + difs[2]) / 3) * 10) / 10;
    case 12:
    case 13:
    case 14:
      return (
        Math.round((difs.slice(0, 4).reduce((a, b) => a + b, 0) / 4) * 10) / 10
      );
    case 15:
    case 16:
      return (
        Math.round((difs.slice(0, 5).reduce((a, b) => a + b, 0) / 5) * 10) / 10
      );
    case 17:
    case 18:
      return (
        Math.round((difs.slice(0, 6).reduce((a, b) => a + b, 0) / 6) * 10) / 10
      );
    case 19:
      return (
        Math.round((difs.slice(0, 7).reduce((a, b) => a + b, 0) / 7) * 10) / 10
      );
    case 20:
      return (
        Math.round((difs.slice(0, 8).reduce((a, b) => a + b, 0) / 8) * 10) / 10
      );
    default:
      return 0;
  }
};</document_content>
</document>
<document index="10">
<source>golf-tracker/src/screens/Home/index.tsx</source>
<document_content>
// src/screens/Home/index.tsx
import React, { useCallback } from 'react';
import {
  View,
  Text,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  Alert
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useFocusEffect } from '@react-navigation/native';
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import { MainStackParamList } from '../../config/navigation';
import { useAuth } from '../../hooks/useAuth';
import { useRounds } from '../../hooks/useRounds';
import { Round } from 'shared';
import { LogOut, Target, Trophy } from 'lucide-react-native';
import { styles } from './styles';
import { calculateHandicap } from '../../utils/handicap';

type Props = NativeStackScreenProps<MainStackParamList, 'Home'>;

function HandicapCard({ handicap }: { handicap: number }) {
  return (
    <View style={styles.card}>
      <Text style={styles.cardTitle}>Current Handicap</Text>
      <Text style={styles.handicapText}>{handicap.toFixed(1)}</Text>
      <TouchableOpacity style={styles.actionButton}>
        <Text style={styles.actionButtonText}>View Details</Text>
      </TouchableOpacity>
    </View>
  );
}

function QuickActions({ onAddRound }: { onAddRound: () => void }) {
  return (
    <View style={styles.quickActions}>
      <TouchableOpacity style={styles.quickActionButton} onPress={onAddRound}>
        {/* <Golf size={24} color="#2f95dc" /> */}
        <Text style={styles.quickActionText}>New Round</Text>
      </TouchableOpacity>
      <TouchableOpacity style={styles.quickActionButton}>
        <Target size={24} color="#2f95dc" />
        <Text style={styles.quickActionText}>Statistics</Text>
      </TouchableOpacity>
      <TouchableOpacity style={styles.quickActionButton}>
        <Trophy size={24} color="#2f95dc" />
        <Text style={styles.quickActionText}>Goals</Text>
      </TouchableOpacity>
    </View>
  );
}

function RecentRounds({ 
  rounds,
  onViewAll
}: { 
  rounds: Round[],
  onViewAll: () => void
}) {
  const recentScores = rounds.slice(0, 5);

  return (
    <View style={styles.card}>
      <Text style={styles.cardTitle}>Recent Scores</Text>
      {rounds.length === 0 ? (
        <Text style={styles.noRoundsText}>
          Add rounds to begin tracking your stats!
        </Text>
      ) : (
        <View style={styles.recentScores}>
          {recentScores.map((round, index) => (
            <View key={round._id} style={styles.scoreItem}>
              <Text style={styles.scoreText}>{round.score}</Text>
              <Text style={styles.scoreDate}>
                {new Date(round.date).toLocaleDateString()}
              </Text>
            </View>
          ))}
        </View>
      )}
      <TouchableOpacity
        style={[styles.actionButton, rounds.length === 0 && styles.disabledButton]}
        disabled={rounds.length === 0}
        onPress={onViewAll}
      >
        <Text style={styles.actionButtonText}>View All Rounds</Text>
      </TouchableOpacity>
    </View>
  );
}

function TipCard() {
  return (
    <View style={styles.card}>
      <Text style={styles.cardTitle}>Today's Tip</Text>
      <Text style={styles.tipText}>
        "Focus on your tempo during practice swings. A consistent tempo leads to more consistent shots."
      </Text>
    </View>
  );
}

export function HomeScreen({ navigation }: Props) {
  const { user, logout } = useAuth();
  const { rounds, loading, error, getUserRounds } = useRounds();

  useFocusEffect(
    useCallback(() => {
      if (user) {
        getUserRounds();
      }
    }, [user, getUserRounds])
  );

  const handleLogout = async () => {
    try {
      await logout();
    } catch (error) {
      Alert.alert('Error', 'Failed to log out. Please try again.');
    }
  };

  if (loading) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#2f95dc" />
        </View>
      </SafeAreaView>
    );
  }

  if (error) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>{error}</Text>
          <TouchableOpacity 
            style={styles.retryButton}
            onPress={() => getUserRounds()}
          >
            <Text style={styles.retryButtonText}>Retry</Text>
          </TouchableOpacity>
        </View>
      </SafeAreaView>
    );
  }

  // Calculate handicap from rounds
  const handicap = calculateHandicap(rounds);

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView contentContainerStyle={styles.scrollContent}>
        {/* Header Section */}
        <View style={styles.header}>
          <View style={styles.welcomeContainer}>
            <Text style={styles.welcomeText}>Welcome back, </Text>
            <Text style={styles.nameText}>{user?.name?.split(' ')[0] || 'Golfer'}</Text>
          </View>
          <TouchableOpacity 
            style={styles.logoutButton} 
            onPress={handleLogout}
          >
            <LogOut size={20} color="#2f95dc" />
          </TouchableOpacity>
        </View>

        {/* Handicap Card */}
        <HandicapCard handicap={handicap} />

        {/* Quick Actions */}
        <QuickActions onAddRound={() => navigation.navigate('AddRound')} />

        {/* Recent Rounds */}
        <RecentRounds
          rounds={rounds}
          onViewAll={() => navigation.navigate('AllRounds')}
        />

        {/* Tip Card */}
        <TipCard />
      </ScrollView>
    </SafeAreaView>
  );
}</document_content>
</document>
<document index="11">
<source>golf-tracker/src/screens/Home/styles.ts</source>
<document_content>
// src/screens/Home/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollContent: {
    padding: 16,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  errorText: {
    color: '#dc3545',
    fontSize: 16,
    textAlign: 'center',
    marginBottom: 16,
  },
  retryButton: {
    backgroundColor: '#2f95dc',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 8,
  },
  retryButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  welcomeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  welcomeText: {
    fontSize: 20,
    color: '#666',
  },
  nameText: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
  },
  logoutButton: {
    padding: 8,
  },
  card: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  cardTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
    marginBottom: 12,
  },
  handicapText: {
    fontSize: 48,
    fontWeight: 'bold',
    color: '#2f95dc',
    textAlign: 'center',
    marginVertical: 16,
  },
  quickActions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 16,
  },
  quickActionButton: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    alignItems: 'center',
    width: '31%',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  quickActionText: {
    fontSize: 14,
    color: '#333',
    marginTop: 8,
    textAlign: 'center',
  },
  recentScores: {
    marginBottom: 12,
  },
  scoreItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  scoreText: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
  },
  scoreDate: {
    fontSize: 14,
    color: '#666',
  },
  actionButton: {
    backgroundColor: '#2f95dc',
    borderRadius: 8,
    padding: 12,
    alignItems: 'center',
    marginTop: 8,
  },
  actionButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  noRoundsText: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginVertical: 16,
  },
  disabledButton: {
    backgroundColor: '#ccc',
  },
  tipText: {
    fontSize: 16,
    color: '#666',
    fontStyle: 'italic',
    lineHeight: 24,
  },
});</document_content>
</document>
<document index="12">
<source>golf-tracker/src/screens/auth/Landing/index.tsx</source>
<document_content>
// src/screens/auth/Landing/index.tsx
import React from 'react';
import { View, Text, useWindowDimensions } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import { AuthStackParamList } from '../../../config/navigation';
import { FormButton } from '../../../components/forms/FormButton';
import { styles } from './styles';

type Props = NativeStackScreenProps<AuthStackParamList, 'Landing'>;

function FeaturePoint({ text }: { text: string }) {
  return (
    <View style={styles.featurePoint}>
      <Text style={styles.featureIcon}>✓</Text>
      <Text style={styles.featureText}>{text}</Text>
    </View>
  );
}

export function LandingScreen({ navigation }: Props) {
  const { height } = useWindowDimensions();

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.content}>
        {/* Top Section with Logo/Branding */}
        <View style={[styles.topSection, { height: height * 0.5 }]}>
          <View style={styles.logoContainer}>
            <Text style={styles.emoji}>⛳️</Text>
            <Text style={styles.appName}>HandiMan</Text>
          </View>
          <Text style={styles.tagline}>Track your scores.</Text>
          <Text style={styles.taglineSecondary}>Improve your game.</Text>
        </View>

        {/* Bottom Section with Feature Points and Buttons */}
        <View style={styles.bottomSection}>
          <View style={styles.features}>
            <FeaturePoint text="Track your rounds and progress" />
            <FeaturePoint text="Calculate your handicap" />
            <FeaturePoint text="Connect with other golfers" />
          </View>

          <View style={styles.buttonContainer}>
            <FormButton
              title="Get Started"
              onPress={() => navigation.navigate('Signup')}
            />
            <FormButton
              title="I already have an account"
              onPress={() => navigation.navigate('Login')}
              variant="secondary"
            />
          </View>
        </View>
      </View>
    </SafeAreaView>
  );
}</document_content>
</document>
<document index="13">
<source>golf-tracker/src/screens/auth/Landing/styles.ts</source>
<document_content>
// src/screens/auth/Landing/styles.ts
import { StyleSheet, Platform } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  content: {
    flex: 1,
  },
  topSection: {
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 20,
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 24,
  },
  emoji: {
    fontSize: 64,
    marginBottom: 16,
  },
  appName: {
    fontSize: 42,
    fontWeight: 'bold',
    color: '#2f95dc',
    letterSpacing: -1,
  },
  tagline: {
    fontSize: 28,
    fontWeight: '600',
    textAlign: 'center',
    marginBottom: 8,
  },
  taglineSecondary: {
    fontSize: 28,
    fontWeight: '600',
    textAlign: 'center',
    color: '#2f95dc',
  },
  bottomSection: {
    flex: 1,
    paddingHorizontal: 20,
    justifyContent: 'space-between',
    paddingBottom: Platform.OS === 'ios' ? 20 : 40,
  },
  features: {
    gap: 16,
    marginBottom: 32,
  },
  featurePoint: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  featureIcon: {
    color: '#2f95dc',
    fontSize: 20,
    fontWeight: 'bold',
  },
  featureText: {
    fontSize: 16,
    color: '#333',
  },
  buttonContainer: {
    gap: 12,
  },
});</document_content>
</document>
<document index="14">
<source>golf-tracker/src/screens/auth/Signup/index.tsx</source>
<document_content>
// src/screens/auth/Signup/index.tsx
import React from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import { AuthStackParamList } from '../../../config/navigation';
import { FormInput } from '../../../components/forms/FormInput';
import { FormButton } from '../../../components/forms/FormButton';
import { useAuth } from '../../../hooks/useAuth';
import { useForm } from '../../../hooks/useForm';
import { styles } from './styles';
import { 
  email,
  required, 
  minLength,
  matches,
  matchesField 
} from '../../../utils/validation';
import { BackButton } from '../../../components/common/BackButton';


type Props = NativeStackScreenProps<AuthStackParamList, 'Signup'>;

interface SignupForm {
  name: string;
  email: string;
  password: string;
  confirmPassword: string;
}

const initialValues: SignupForm = {
  name: '',
  email: '',
  password: '',
  confirmPassword: ''
};

const validationRules = {
  name: [required<SignupForm>('Name is required')],
  email: [
    required<SignupForm>('Email is required'), 
    email<SignupForm>()
  ],
  password: [
    required<SignupForm>('Password is required'),
    minLength<SignupForm>(8, 'Password must be at least 8 characters'),
    matches<SignupForm>(
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/,
      'Password must contain at least one uppercase letter, one lowercase letter, and one number'
    )
  ],
  confirmPassword: [
    required<SignupForm>('Please confirm your password'),
    matchesField<SignupForm>('password', 'Passwords do not match')
  ]
};

export function SignupScreen({ navigation }: Props) {
  const { signup } = useAuth();
  const {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleBlur,
    handleSubmit,
    setErrors
  } = useForm<SignupForm>({
    initialValues,
    validationRules,
    onSubmit: async (formValues) => {
      try {
        await signup({
          name: formValues.name,
          email: formValues.email,
          password: formValues.password
        });
        
        Alert.alert(
          'Success',
          'Your account has been created successfully!',
          [{ text: 'OK' }]
        );
      } catch (error) {
        if (error instanceof Error) {
          // Handle specific error cases
          if (error.message.toLowerCase().includes('email already registered')) {
            setErrors({ email: 'This email is already registered' });
          } else if (error.message.toLowerCase().includes('network')) {
            Alert.alert(
              'Connection Error',
              'Please check your internet connection and try again.'
            );
          } else {
            Alert.alert('Error', error.message);
          }
        } else {
          Alert.alert(
            'Error',
            'An unexpected error occurred. Please try again later.'
          );
        }
      }
    }
  });

  return (
    <SafeAreaView style={styles.container}>
      <BackButton />
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardView}
      >
        
        <ScrollView contentContainerStyle={styles.scrollContent}>
          
          <View style={styles.header}>
            <Text style={styles.title}>Create Account</Text>
            <Text style={styles.subtitle}>Track your golf progress</Text>
          </View>

          <View style={styles.form}>
            <FormInput
              label="Name"
              value={values.name}
              onChangeText={handleChange('name')}
              onBlur={handleBlur('name')}
              placeholder="Enter your name"
              autoComplete="name"
              error={touched.name ? errors.name : undefined}
              editable={!isSubmitting}
            />

            <FormInput
              label="Email"
              value={values.email}
              onChangeText={handleChange('email')}
              onBlur={handleBlur('email')}
              placeholder="Enter your email"
              autoCapitalize="none"
              autoComplete="email"
              keyboardType="email-address"
              error={touched.email ? errors.email : undefined}
              editable={!isSubmitting}
            />

            <FormInput
              label="Password"
              value={values.password}
              onChangeText={handleChange('password')}
              onBlur={handleBlur('password')}
              placeholder="Create a password"
              secureTextEntry
              autoComplete="new-password"
              error={touched.password ? errors.password : undefined}
              editable={!isSubmitting}
            />

            <FormInput
              label="Confirm Password"
              value={values.confirmPassword}
              onChangeText={handleChange('confirmPassword')}
              onBlur={handleBlur('confirmPassword')}
              placeholder="Confirm your password"
              secureTextEntry
              autoComplete="new-password"
              error={touched.confirmPassword ? errors.confirmPassword : undefined}
              editable={!isSubmitting}
            />

            <FormButton
              title="Create Account"
              onPress={() => handleSubmit()}
              loading={isSubmitting}
            />
          </View>

          <View style={styles.footer}>
            <Text style={styles.footerText}>Already have an account? </Text>
            <TouchableOpacity 
              onPress={() => navigation.navigate('Login')}
              disabled={isSubmitting}
            >
              <Text style={styles.footerLink}>Log In</Text>
            </TouchableOpacity>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}</document_content>
</document>
<document index="15">
<source>golf-tracker/src/screens/auth/Signup/styles.ts</source>
<document_content>
// src/screens/auth/Signup/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  keyboardView: {
    flex: 1,
  },
  scrollContent: {
    flexGrow: 1,
    padding: 20,
  },
  header: {
    marginTop: 40,
    marginBottom: 32,
    alignItems: 'center',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
  },
  form: {
    gap: 16,
    marginBottom: 24,
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginTop: 'auto',
    paddingVertical: 16,
  },
  footerText: {
    color: '#666',
  },
  footerLink: {
    color: '#2f95dc',
    fontWeight: '600',
  },
});</document_content>
</document>
<document index="16">
<source>golf-tracker/src/screens/auth/Login/index.tsx</source>
<document_content>
// src/screens/auth/Login/index.tsx
import React from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import { AuthStackParamList } from '../../../config/navigation';
import { FormInput } from '../../../components/forms/FormInput';
import { FormButton } from '../../../components/forms/FormButton';
import { useAuthContext } from '../../../components/providers/AuthProvider';
import { useForm } from '../../../hooks/useForm';
import { styles } from './styles';
import { email as emailValidator, required } from '../../../utils/validation';
import { BackButton } from '../../../components/common/BackButton';

type Props = NativeStackScreenProps<AuthStackParamList, 'Login'>;

interface LoginForm {
  email: string;
  password: string;
}

const initialValues: LoginForm = {
  email: '',
  password: ''
};

const validationRules = {
  email: [required('Email is required'), emailValidator()],
  password: [required('Password is required')]
};

export function LoginScreen({ navigation }: Props) {
  const { login } = useAuthContext();
  
  const {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleBlur,
    handleSubmit
  } = useForm<LoginForm>({
    initialValues,
    validationRules,
    onSubmit: async (formValues) => {
      console.log('Login form submitted:', formValues);
      try {
        await login(formValues.email, formValues.password);
        console.log('Login successful');
      } catch (error) {
        console.error('Login error in screen:', error);
        Alert.alert(
          'Login Error',
          error instanceof Error
            ? error.message
            : 'An error occurred during login'
        );
      }
    }
  });

  return (
    <SafeAreaView style={styles.container}>
      <BackButton />
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardView}
      >
        <ScrollView contentContainerStyle={styles.scrollContent}>
          <View style={styles.header}>
            <Text style={styles.title}>Welcome Back!</Text>
            <Text style={styles.subtitle}>Sign in to continue</Text>
          </View>
          <View style={styles.form}>
            <FormInput
              label="Email"
              value={values.email}
              onChangeText={handleChange('email')}
              onBlur={handleBlur('email')}
              placeholder="Enter your email"
              autoCapitalize="none"
              autoComplete="email"
              keyboardType="email-address"
              error={touched.email ? errors.email : undefined}
              editable={!isSubmitting}
            />

            <FormInput
              label="Password"
              value={values.password}
              onChangeText={handleChange('password')}
              onBlur={handleBlur('password')}
              placeholder="Enter your password"
              secureTextEntry
              autoComplete="password"
              error={touched.password ? errors.password : undefined}
              editable={!isSubmitting}
            />

            <FormButton
              title="Login"
              onPress={() => handleSubmit()}
              loading={isSubmitting}
            />
          </View>

          <View style={styles.footer}>
            <Text style={styles.footerText}>Don't have an account? </Text>
            <TouchableOpacity 
              onPress={() => navigation.navigate('Signup')}
              disabled={isSubmitting}
            >
              <Text style={styles.footerLink}>Sign Up</Text>
            </TouchableOpacity>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}</document_content>
</document>
<document index="17">
<source>golf-tracker/src/screens/auth/Login/styles.ts</source>
<document_content>
// src/screens/auth/Login/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  keyboardView: {
    flex: 1,
  },
  scrollContent: {
    flexGrow: 1,
    padding: 20,
  },
  header: {
    marginTop: 40,
    marginBottom: 32,
    alignItems: 'center',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
  },
  form: {
    gap: 16,
    marginBottom: 24,
  },
  generalError: {
    color: '#ff3b30',
    textAlign: 'center',
    marginBottom: 16,
    backgroundColor: '#ffebeb',
    padding: 10,
    borderRadius: 8,
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginTop: 'auto',
    paddingVertical: 16,
  },
  footerText: {
    color: '#666',
  },
  footerLink: {
    color: '#2f95dc',
    fontWeight: '600',
  },
});</document_content>
</document>
<document index="18">
<source>golf-tracker/src/screens/rounds/AllRounds/index.tsx</source>
<document_content>
// src/screens/rounds/AllRounds/index.tsx
import React, { useState, useCallback } from 'react';
import {
  View,
  Text,
  FlatList,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  RefreshControl
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { NativeStackScreenProps } from '@react-navigation/native-stack';
import { MainStackParamList } from '../../../config/navigation';
import { Round } from 'shared';
import { useRounds } from '../../../hooks/useRounds';
import { ChevronDown, Calendar, Flag, Target } from 'lucide-react-native';
import { styles } from './styles';
import { BackButton } from '../../../components/common/BackButton';

type Props = NativeStackScreenProps<MainStackParamList, 'AllRounds'>;

type SortOption = 'date' | 'score' | 'differential';
type SortDirection = 'asc' | 'desc';

interface RoundCardProps {
  round: Round;
  onPress?: () => void;
}

function RoundCard({ round, onPress }: RoundCardProps) {
  return (
    <TouchableOpacity style={styles.roundCard} onPress={onPress}>
      <View style={styles.roundHeader}>
        <View>
          <Text style={styles.courseName}>
            {typeof round.course === 'object' ? round.course.name : 'Unknown Course'}
          </Text>
          <Text style={styles.roundDate}>
            {new Date(round.date).toLocaleDateString()}
          </Text>
        </View>
        <Text style={styles.roundScore}>{round.score}</Text>
      </View>
      
      <View style={styles.roundStats}>
        <View style={styles.statItem}>
          <Target size={16} color="#666" />
          <Text style={styles.statText}>
            Differential: {round.differential.toFixed(1)}
          </Text>
        </View>
        <View style={styles.statItem}>
          <Flag size={16} color="#666" />
          <Text style={styles.statText}>
            {`FIR: ${round.fairways}`}
          </Text>
        </View>
        <View style={styles.statItem}>
          <Calendar size={16} color="#666" />
          <Text style={styles.statText}>
            {`Putts: ${round.putts}`}
          </Text>
        </View>
      </View>

      {round.notes && (
        <Text style={styles.notes} numberOfLines={2}>
          {round.notes}
        </Text>
      )}
    </TouchableOpacity>
  );
}

export function AllRoundsScreen({ navigation }: Props) {
  const { rounds, loading, error, getUserRounds, deleteRound } = useRounds();
  const [refreshing, setRefreshing] = useState(false);
  const [sortBy, setSortBy] = useState<SortOption>('date');
  const [sortDirection, setSortDirection] = useState<SortDirection>('desc');
  const [showSortOptions, setShowSortOptions] = useState(false);

  const onRefresh = useCallback(async () => {
    setRefreshing(true);
    try {
      await getUserRounds();
    } finally {
      setRefreshing(false);
    }
  }, [getUserRounds]);

  const sortedRounds = [...rounds].sort((a, b) => {
    let comparison = 0;
    switch (sortBy) {
      case 'date':
        comparison = new Date(b.date).getTime() - new Date(a.date).getTime();
        break;
      case 'score':
        comparison = a.score - b.score;
        break;
      case 'differential':
        comparison = a.differential - b.differential;
        break;
    }
    return sortDirection === 'desc' ? comparison : -comparison;
  });

  const toggleSort = (option: SortOption) => {
    if (sortBy === option) {
      setSortDirection(prev => prev === 'asc' ? 'desc' : 'asc');
    } else {
      setSortBy(option);
      setSortDirection('asc');
    }
    setShowSortOptions(false);
  };

  const handleDeleteRound = (roundId: string) => {
    Alert.alert(
      'Delete Round',
      'Are you sure you want to delete this round?',
      [
        {
          text: 'Cancel',
          style: 'cancel'
        },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: async () => {
            try {
              await deleteRound(roundId);
              Alert.alert('Success', 'Round deleted successfully');
            } catch (error) {
              Alert.alert('Error', 'Failed to delete round');
            }
          }
        }
      ]
    );
  };

  if (loading && !refreshing) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#2f95dc" />
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <BackButton /> 
      <View style={styles.header}>
        <Text style={styles.title}>Rounds History</Text>
        <TouchableOpacity 
          style={styles.sortButton}
          onPress={() => setShowSortOptions(!showSortOptions)}
        >
          <Text style={styles.sortButtonText}>
            Sort by {sortBy}
          </Text>
          <ChevronDown size={20} color="#2f95dc" />
        </TouchableOpacity>
      </View>

      {showSortOptions && (
        <View style={styles.sortOptions}>
          <TouchableOpacity 
            style={styles.sortOption} 
            onPress={() => toggleSort('date')}
          >
            <Text style={[
              styles.sortOptionText,
              sortBy === 'date' && styles.selectedSortOption
            ]}>Date</Text>
          </TouchableOpacity>
          <TouchableOpacity 
            style={styles.sortOption} 
            onPress={() => toggleSort('score')}
          >
            <Text style={[
              styles.sortOptionText,
              sortBy === 'score' && styles.selectedSortOption
            ]}>Score</Text>
          </TouchableOpacity>
          <TouchableOpacity 
            style={styles.sortOption} 
            onPress={() => toggleSort('differential')}
          >
            <Text style={[
              styles.sortOptionText,
              sortBy === 'differential' && styles.selectedSortOption
            ]}>Differential</Text>
          </TouchableOpacity>
        </View>
      )}

      <FlatList
        data={sortedRounds}
        renderItem={({ item }) => (
          <RoundCard 
            round={item}
            onPress={() => handleDeleteRound(item._id)}
          />
        )}
        keyExtractor={item => item._id}
        contentContainerStyle={styles.listContent}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
        }
        ListEmptyComponent={() => (
          <View style={styles.emptyContainer}>
            <Text style={styles.emptyText}>
              No rounds recorded yet.
            </Text>
            <TouchableOpacity
              style={styles.addButton}
              onPress={() => navigation.navigate('AddRound')}
            >
              <Text style={styles.addButtonText}>Add Your First Round</Text>
            </TouchableOpacity>
          </View>
        )}
      />
    </SafeAreaView>
  );
}</document_content>
</document>
<document index="19">
<source>golf-tracker/src/screens/rounds/AllRounds/styles.ts</source>
<document_content>
// src/screens/rounds/AllRounds/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
  },
  sortButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
  },
  sortButtonText: {
    color: '#2f95dc',
    fontSize: 16,
  },
  sortOptions: {
    backgroundColor: '#fff',
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
    padding: 8,
  },
  sortOption: {
    padding: 12,
  },
  sortOptionText: {
    fontSize: 16,
    color: '#666',
  },
  selectedSortOption: {
    color: '#2f95dc',
    fontWeight: '600',
  },
  listContent: {
    padding: 16,
    gap: 16,
  },
  roundCard: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  roundHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 12,
  },
  courseName: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 4,
  },
  roundDate: {
    fontSize: 14,
    color: '#666',
  },
  roundScore: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
  },
  roundStats: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 12,
  },
  statItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
  },
  statText: {
    fontSize: 14,
    color: '#666',
  },
  notes: {
    fontSize: 14,
    color: '#666',
    fontStyle: 'italic',
    borderTopWidth: 1,
    borderTopColor: '#eee',
    paddingTop: 12,
  },
  emptyContainer: {
    padding: 24,
    alignItems: 'center',
  },
  emptyText: {
    fontSize: 16,
    color: '#666',
    marginBottom: 16,
    textAlign: 'center',
  },
  addButton: {
    backgroundColor: '#2f95dc',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 8,
  },
  addButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
});</document_content>
</document>
<document index="20">
<source>golf-tracker/src/screens/rounds/AddRound/index.tsx</source>
<document_content>
// src/screens/rounds/AddRound/index.tsx
import React, { useState } from 'react';
import { ScrollView, Alert } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { NativeStackScreenProps } from '@react-navigation/native-stack';
import { MainStackParamList } from '../../../config/navigation';
import { useAuth } from '../../../hooks/useAuth';
import { useRounds } from '../../../hooks/useRounds';
import { Course } from 'shared';
import { CourseSearch } from '../../../components/course/CourseSearch';
import { RoundDetails } from '../../../components/round/RoundDetails';
import { styles } from './styles';
import { BackButton } from '../../../components/common/BackButton';

type Props = NativeStackScreenProps<MainStackParamList, 'AddRound'>;

export function AddRoundScreen({ navigation }: Props) {
  const { user } = useAuth();
  const { createRound } = useRounds();
  
  // Course selection state
  const [selectedCourse, setSelectedCourse] = useState<Course | null>(null);
  const [selectedTee, setSelectedTee] = useState('');
  
  // Round details state
  const [date, setDate] = useState(new Date());
  const [score, setScore] = useState('');
  const [putts, setPutts] = useState('');
  const [fairways, setFairways] = useState('');
  const [greens, setGreens] = useState('');
  const [notes, setNotes] = useState('');
  
  // Form state
  const [loading, setLoading] = useState(false);
  const [errors, setErrors] = useState<{[key: string]: string}>({});

  const validateForm = () => {
    const newErrors: {[key: string]: string} = {};
    
    if (!selectedCourse) {
      newErrors.course = 'Please select a course';
    }
    if (!selectedTee) {
      newErrors.tee = 'Please select tee';
    }
    if (!score) {
      newErrors.score = 'Score is required';
    } else if (isNaN(Number(score)) || Number(score) < 1) {
      newErrors.score = 'Please enter a valid score';
    }
    if (!putts) {
      newErrors.putts = 'Number of putts is required';
    } else if (isNaN(Number(putts)) || Number(putts) < 0) {
      newErrors.putts = 'Please enter a valid number of putts';
    }
    if (!fairways) {
      newErrors.fairways = 'Fairways hit is required';
    } else if (isNaN(Number(fairways)) || Number(fairways) < 0) {
      newErrors.fairways = 'Please enter a valid number of fairways';
    }
    if (!greens) {
      newErrors.greens = 'Greens hit is required';
    } else if (isNaN(Number(greens)) || Number(greens) < 0) {
      newErrors.greens = 'Please enter a valid number of greens';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async () => {
    if (!validateForm() || !user || !selectedCourse) return;

    setLoading(true);
    try {
      await createRound({
        course: selectedCourse,
        date: date.toISOString(),
        tees: selectedTee,
        score: Number(score),
        putts: Number(putts),
        fairways: Number(fairways),
        greens: Number(greens),
        notes: notes.trim() || undefined
      });

      Alert.alert(
        'Success',
        'Round added successfully',
        [{
          text: 'OK',
          onPress: () => navigation.goBack()
        }]
      );
    } catch (error) {
      console.error('Error submitting round:', error);
      Alert.alert(
        'Error',
        error instanceof Error 
          ? error.message 
          : 'Failed to add round. Please try again.'
      );
    } finally {
      setLoading(false);
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <BackButton/>
      <ScrollView contentContainerStyle={styles.content}>
        {!selectedCourse ? (
          <CourseSearch onSelect={setSelectedCourse} />
        ) : (
          <RoundDetails
            course={selectedCourse}
            selectedTee={selectedTee}
            onTeeSelect={setSelectedTee}
            date={date}
            onDateChange={setDate}
            score={score}
            onScoreChange={setScore}
            putts={putts}
            onPuttsChange={setPutts}
            fairways={fairways}
            onFairwaysChange={setFairways}
            greens={greens}
            onGreensChange={setGreens}
            notes={notes}
            onNotesChange={setNotes}
            errors={errors}
            loading={loading}
            onSubmit={handleSubmit}
            onChangeCourse={() => setSelectedCourse(null)}
          />
        )}
      </ScrollView>
    </SafeAreaView>
  );
}</document_content>
</document>
<document index="21">
<source>golf-tracker/src/screens/rounds/AddRound/styles.ts</source>
<document_content>
// src/screens/rounds/AddRound/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  content: {
    flexGrow: 1,
  },
});</document_content>
</document>
<document index="22">
<source>golf-tracker/src/components/course/CourseSearch/index.tsx</source>
<document_content>
// src/components/course/CourseSearch/index.tsx
import React, { useState, useCallback } from 'react';
import { 
  View, 
  Text, 
  TouchableOpacity, 
  TextInput, 
  ActivityIndicator 
} from 'react-native';
import { Search as SearchIcon, PlusCircle as PlusCircleIcon } from 'lucide-react-native';
import { Course } from 'shared';
import { useCourses } from '../../../hooks/useCourses';
import { debounce } from 'lodash';
import { styles } from './styles';

interface CourseSearchProps {
  onSelect: (course: Course) => void;
}

function NoResults({ onAddNew }: { onAddNew: () => void }) {
  return (
    <View style={styles.noResultsContainer}>
      <Text style={styles.noResultsText}>No courses found</Text>
      <TouchableOpacity style={styles.addButton} onPress={onAddNew}>
        <PlusCircleIcon size={20} color="#2f95dc" />
        <Text style={styles.addButtonText}>Add New Course</Text>
      </TouchableOpacity>
    </View>
  );
}

function CourseList({ courses, onSelect }: { courses: Course[], onSelect: (course: Course) => void }) {
  return (
    <View style={styles.resultsContainer}>
      {courses.map((course) => (
        <TouchableOpacity
          key={course._id}
          style={styles.courseItem}
          onPress={() => onSelect(course)}
        >
          <Text style={styles.courseName}>{course.name}</Text>
          {course.location.city && (
            <Text style={styles.courseLocation}>
              {[course.location.city, course.location.state]
                .filter(Boolean)
                .join(', ')}
            </Text>
          )}
        </TouchableOpacity>
      ))}
    </View>
  );
}

export function CourseSearch({ onSelect }: CourseSearchProps) {
  const { searchCourses, loading, error } = useCourses();
  const [query, setQuery] = useState('');
  const [courses, setCourses] = useState<Course[]>([]);
  
  const debouncedSearch = useCallback(
    debounce(async (searchQuery: string) => {
      if (searchQuery.trim().length < 2) {
        setCourses([]);
        return;
      }
        searchCourses(searchQuery);
    }, 300),
    []
  );

  const handleQueryChange = (text: string) => {
    setQuery(text);
    debouncedSearch(text);
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Find a Course</Text>

      <View style={styles.searchContainer}>
        <SearchIcon size={20} color="#666" />
        <TextInput
          style={styles.searchInput}
          value={query}
          onChangeText={handleQueryChange}
          placeholder="Search for a course"
          placeholderTextColor="#999"
          autoCapitalize="words"
        />
      </View>

      {loading && (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#2f95dc" />
        </View>
      )}

      {!loading && courses.length > 0 && (
        <CourseList courses={courses} onSelect={onSelect} />
      )}

      {!loading && query.length >= 2 && courses.length === 0 && (
        <NoResults onAddNew={() => {
          // TODO: Implement add new course functionality
          console.log('Add new course');
        }} />
      )}

      {error && (
        <Text style={styles.errorText}>
          Error searching courses. Please try again.
        </Text>
      )}
    </View>
  );
}</document_content>
</document>
<document index="23">
<source>golf-tracker/src/components/course/CourseSearch/styles.ts</source>
<document_content>
// src/components/course/CourseSearch/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    padding: 16,
    gap: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    paddingHorizontal: 12,
    height: 48,
    gap: 8,
  },
  searchInput: {
    flex: 1,
    fontSize: 16,
    color: '#333',
  },
  loadingContainer: {
    padding: 20,
    alignItems: 'center',
  },
  resultsContainer: {
    gap: 8,
  },
  courseItem: {
    backgroundColor: '#fff',
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#eee',
  },
  courseName: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 4,
  },
  courseLocation: {
    fontSize: 14,
    color: '#666',
  },
  noResultsContainer: {
    padding: 20,
    alignItems: 'center',
    backgroundColor: '#fff',
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#eee',
  },
  noResultsText: {
    fontSize: 16,
    color: '#666',
    marginBottom: 12,
  },
  addButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    padding: 8,
  },
  addButtonText: {
    color: '#2f95dc',
    fontSize: 16,
    fontWeight: '500',
  },
  errorText: {
    color: '#dc3545',
    textAlign: 'center',
    padding: 12,
  },
});</document_content>
</document>
<document index="24">
<source>golf-tracker/src/components/course/TeeSelector/index.tsx</source>
<document_content>
// src/components/course/TeeSelector/index.tsx
import React, { useState } from 'react';
import { 
  View, 
  Text, 
  TouchableOpacity, 
  Modal, 
  Alert 
} from 'react-native';
import { ChevronDown, Plus } from 'lucide-react-native';
import { Course } from 'shared';
import { FormInput } from '../../forms/FormInput';
import { FormButton } from '../../forms/FormButton';
import { useCourses } from '../../../hooks/useCourses';
import { styles } from './styles';

interface TeeSelectorProps {
  course: Course;
  selectedTee: string;
  onTeeSelect: (tee: string) => void;
  error?: string;
}

interface AddTeeFormData {
  name: string;
  rating: string;
  slope: string;
  numberOfFairways: string;
}

export function TeeSelector({
  course,
  selectedTee,
  onTeeSelect,
  error
}: TeeSelectorProps) {
  const { addTeeToCourse } = useCourses();
  const [isOpen, setIsOpen] = useState(false);
  const [showAddModal, setShowAddModal] = useState(false);
  const [loading, setLoading] = useState(false);
  const [formData, setFormData] = useState<AddTeeFormData>({
    name: '',
    rating: '',
    slope: '',
    numberOfFairways: ''
  });
  const [formErrors, setFormErrors] = useState<Partial<AddTeeFormData>>({});

  const handleOpenDropdown = () => {
    if (course.tees.length === 0) {
      setShowAddModal(true);
    } else {
      setIsOpen(!isOpen);
    }
  };

  const validateTeeForm = (): boolean => {
    const errors: Partial<AddTeeFormData> = {};
    
    if (!formData.name.trim()) {
      errors.name = 'Tee name is required';
    }
    
    if (!formData.rating) {
      errors.rating = 'Course rating is required';
    } else if (isNaN(Number(formData.rating)) || Number(formData.rating) < 60 || Number(formData.rating) > 80) {
      errors.rating = 'Rating must be between 60 and 80';
    }
    
    if (!formData.slope) {
      errors.slope = 'Slope rating is required';
    } else if (isNaN(Number(formData.slope)) || Number(formData.slope) < 55 || Number(formData.slope) > 155) {
      errors.slope = 'Slope must be between 55 and 155';
    }
    
    if (!formData.numberOfFairways) {
      errors.numberOfFairways = 'Number of fairways is required';
    } else if (isNaN(Number(formData.numberOfFairways)) || Number(formData.numberOfFairways) < 0 || Number(formData.numberOfFairways) > 18) {
      errors.numberOfFairways = 'Must be between 0 and 18';
    }

    setFormErrors(errors);
    return Object.keys(errors).length === 0;
  };

  const handleAddTee = async () => {
    if (!validateTeeForm()) return;
    
    setLoading(true);
    try {
      await addTeeToCourse(course._id, {
        name: formData.name.trim(),
        rating: Number(formData.rating),
        slope: Number(formData.slope),
        numberOfFairways: Number(formData.numberOfFairways)
      });
      
      setShowAddModal(false);
      onTeeSelect(formData.name.trim());
      
      // Reset form
      setFormData({
        name: '',
        rating: '',
        slope: '',
        numberOfFairways: ''
      });
      setFormErrors({});
    } catch (error) {
      Alert.alert(
        'Error',
        error instanceof Error ? error.message : 'Failed to add tee'
      );
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.label}>Select Tee</Text>

      <TouchableOpacity
        style={[styles.dropdown, error && styles.dropdownError]}
        onPress={handleOpenDropdown}
      >
        <Text style={[
          styles.dropdownText,
          !selectedTee && styles.placeholderText
        ]}>
          {selectedTee || "Select a tee"}
        </Text>
        <ChevronDown size={20} color="#666" />
      </TouchableOpacity>

      {error && <Text style={styles.errorText}>{error}</Text>}

      {isOpen && (
        <View style={styles.dropdownMenu}>
          {course.tees.map((tee) => (
            <TouchableOpacity
              key={tee.name}
              style={styles.dropdownItem}
              onPress={() => {
                onTeeSelect(tee.name);
                setIsOpen(false);
              }}
            >
              <Text style={[
                styles.dropdownItemText,
                selectedTee === tee.name && styles.selectedItemText
              ]}>
                {tee.name}
              </Text>
              <Text style={styles.teeDetails}>
                {`${tee.rating} / ${tee.slope}`}
              </Text>
            </TouchableOpacity>
          ))}

          <TouchableOpacity
            style={styles.addButton}
            onPress={() => {
              setIsOpen(false);
              setShowAddModal(true);
            }}
          >
            <Plus size={20} color="#2f95dc" />
            <Text style={styles.addButtonText}>Add New Tee</Text>
          </TouchableOpacity>
        </View>
      )}

      <Modal
        visible={showAddModal}
        animationType="slide"
        transparent
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Add New Tee</Text>

            <FormInput
              label="Tee Color/Name"
              value={formData.name}
              onChangeText={(text) => setFormData(prev => ({ ...prev, name: text }))}
              placeholder="e.g., Blue"
              error={formErrors.name}
              editable={!loading}
            />

            <FormInput
              label="Course Rating"
              value={formData.rating}
              onChangeText={(text) => setFormData(prev => ({ ...prev, rating: text }))}
              placeholder="e.g., 72.1"
              keyboardType="decimal-pad"
              error={formErrors.rating}
              editable={!loading}
            />

            <FormInput
              label="Slope Rating"
              value={formData.slope}
              onChangeText={(text) => setFormData(prev => ({ ...prev, slope: text }))}
              placeholder="e.g., 125"
              keyboardType="numeric"
              error={formErrors.slope}
              editable={!loading}
            />

            <FormInput
              label="Number of Fairways"
              value={formData.numberOfFairways}
              onChangeText={(text) => setFormData(prev => ({ ...prev, numberOfFairways: text }))}
              placeholder="e.g., 14"
              keyboardType="numeric"
              error={formErrors.numberOfFairways}
              editable={!loading}
            />

            <View style={styles.modalButtons}>
              <FormButton
                title="Cancel"
                onPress={() => setShowAddModal(false)}
                variant="secondary"
                loading={loading}
                style={styles.modalButton}
              />
              <FormButton
                title="Add Tee"
                onPress={handleAddTee}
                loading={loading}
                style={styles.modalButton}
              />
            </View>
          </View>
        </View>
      </Modal>
    </View>
  );
}</document_content>
</document>
<document index="25">
<source>golf-tracker/src/components/course/TeeSelector/styles.ts</source>
<document_content>
// src/components/course/TeeSelector/styles.ts
import { StyleSheet, Platform } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    marginBottom: 24,
  },
  label: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
  },
  dropdown: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    height: 48,
    paddingHorizontal: 16,
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    backgroundColor: '#fff',
  },
  dropdownError: {
    borderColor: '#dc3545',
  },
  dropdownText: {
    fontSize: 16,
    color: '#333',
  },
  placeholderText: {
    color: '#999',
  },
  errorText: {
    color: '#dc3545',
    fontSize: 14,
    marginTop: 4,
  },
  dropdownMenu: {
    marginTop: 4,
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    backgroundColor: '#fff',
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
      },
      android: {
        elevation: 3,
      },
    }),
  },
  dropdownItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  dropdownItemText: {
    fontSize: 16,
    color: '#333',
  },
  selectedItemText: {
    color: '#2f95dc',
    fontWeight: '600',
  },
  teeDetails: {
    fontSize: 14,
    color: '#666',
  },
  addButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 12,
    gap: 8,
  },
  addButtonText: {
    color: '#2f95dc',
    fontSize: 16,
    fontWeight: '500',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 20,
    width: '90%',
    maxWidth: 400,
    gap: 16,
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    gap: 12,
  },
  modalButton: {
    flex: 1,
  },
});</document_content>
</document>
<document index="26">
<source>golf-tracker/src/components/forms/FormInput/index.tsx</source>
<document_content>
// src/components/forms/FormInput/index.tsx
import React, { useState } from 'react';
import { 
  View, 
  Text, 
  TextInput, 
  TextInputProps,
  TouchableOpacity,
  ViewStyle,
} from 'react-native';
import { Eye, EyeOff } from 'lucide-react-native';
import { styles } from './styles';

interface FormInputProps extends TextInputProps {
  label?: string;
  error?: string;
  helper?: string;
  containerStyle?: ViewStyle;
  required?: boolean;
  showPasswordToggle?: boolean;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
}

export function FormInput({
  label,
  error,
  helper,
  containerStyle,
  required = false,
  showPasswordToggle = false,
  leftIcon,
  rightIcon,
  secureTextEntry,
  style,
  ...props
}: FormInputProps) {
  const [isPasswordVisible, setIsPasswordVisible] = useState(false);

  const togglePasswordVisibility = () => {
    setIsPasswordVisible(!isPasswordVisible);
  };

  const renderLeftIcon = () => {
    if (!leftIcon) return null;
    return <View style={styles.leftIcon}>{leftIcon}</View>;
  };

  const renderRightIcon = () => {
    if (showPasswordToggle) {
      return (
        <TouchableOpacity 
          style={styles.rightIcon}
          onPress={togglePasswordVisibility}
        >
          {isPasswordVisible ? (
            <EyeOff size={20} color="#666" />
          ) : (
            <Eye size={20} color="#666" />
          )}
        </TouchableOpacity>
      );
    }
    if (!rightIcon) return null;
    return <View style={styles.rightIcon}>{rightIcon}</View>;
  };

  return (
    <View style={[styles.container, containerStyle]}>
      {label && (
        <View style={styles.labelContainer}>
          <Text style={styles.label}>{label}</Text>
          {required && <Text style={styles.required}>*</Text>}
        </View>
      )}
      
      <View style={styles.inputWrapper}>
        {renderLeftIcon()}
        <TextInput
          style={[
            styles.input,
            leftIcon && styles.inputWithLeftIcon,
            (rightIcon || showPasswordToggle) && styles.inputWithRightIcon,
            error && styles.inputError,
            style,
          ]}
          placeholderTextColor="#999"
          secureTextEntry={showPasswordToggle ? !isPasswordVisible : secureTextEntry}
          {...props}
        />
        {renderRightIcon()}
      </View>

      {(error || helper) && (
        <Text style={[styles.helperText, error && styles.errorText]}>
          {error || helper}
        </Text>
      )}
    </View>
  );
}</document_content>
</document>
<document index="27">
<source>golf-tracker/src/components/forms/FormInput/styles.ts</source>
<document_content>
// src/components/forms/FormInput/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    marginBottom: 16,
  },
  labelContainer: {
    flexDirection: 'row',
    marginBottom: 8,
  },
  label: {
    fontSize: 16,
    color: '#333',
    fontWeight: '600',
  },
  required: {
    color: '#ff3b30',
    marginLeft: 4,
  },
  inputWrapper: {
    position: 'relative',
    flexDirection: 'row',
    alignItems: 'center',
  },
  input: {
    flex: 1,
    height: 48,
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    paddingHorizontal: 16,
    fontSize: 16,
    backgroundColor: '#fff',
    color: '#333',
  },
  inputWithLeftIcon: {
    paddingLeft: 48,
  },
  inputWithRightIcon: {
    paddingRight: 48,
  },
  inputError: {
    borderColor: '#ff3b30',
  },
  leftIcon: {
    position: 'absolute',
    left: 16,
    zIndex: 1,
  },
  rightIcon: {
    position: 'absolute',
    right: 16,
    zIndex: 1,
  },
  helperText: {
    fontSize: 14,
    color: '#666',
    marginTop: 4,
  },
  errorText: {
    color: '#ff3b30',
  },
});</document_content>
</document>
<document index="28">
<source>golf-tracker/src/components/forms/FormButton/index.tsx</source>
<document_content>
// src/components/forms/FormButton/index.tsx
import React from 'react';
import { 
  TouchableOpacity, 
  Text, 
  ActivityIndicator,
  ViewStyle,
  TextStyle,
  View,
} from 'react-native';
import { styles } from './styles';

export type ButtonVariant = 'primary' | 'secondary' | 'outline' | 'danger';
export type ButtonSize = 'small' | 'medium' | 'large';

interface FormButtonProps {
  title: string;
  onPress: () => void;
  variant?: ButtonVariant;
  size?: ButtonSize;
  loading?: boolean;
  disabled?: boolean;
  fullWidth?: boolean;
  style?: ViewStyle;
  textStyle?: TextStyle;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
}

export function FormButton({ 
  title, 
  onPress, 
  variant = 'primary',
  size = 'medium',
  loading = false,
  disabled = false,
  fullWidth = false,
  style,
  textStyle,
  leftIcon,
  rightIcon,
}: FormButtonProps) {
  const getButtonStyle = () => {
    const buttonStyles = [
      styles.button,
      styles[`button${size.charAt(0).toUpperCase()}${size.slice(1)}`],
      styles[`button${variant.charAt(0).toUpperCase()}${variant.slice(1)}`],
      fullWidth && styles.buttonFullWidth,
      (disabled || loading) && styles.buttonDisabled,
      style,
    ];
    
    return buttonStyles;
  };

  const getTextStyle = () => {
    const textStyles = [
      styles.buttonText,
      styles[`text${variant.charAt(0).toUpperCase()}${variant.slice(1)}`],
      styles[`text${size.charAt(0).toUpperCase()}${size.slice(1)}`],
      disabled && styles.textDisabled,
      textStyle,
    ];
    
    return textStyles;
  };

  return (
    <TouchableOpacity
      style={getButtonStyle()}
      onPress={onPress}
      disabled={disabled || loading}
      activeOpacity={0.7}
    >
      {loading ? (
        <ActivityIndicator 
          color={variant === 'primary' ? '#fff' : '#2f95dc'} 
          size={size === 'small' ? 'small' : 'small'}
        />
      ) : (
        <React.Fragment>
          {leftIcon && <View style={styles.iconLeft}>{leftIcon}</View>}
          <Text style={getTextStyle()}>{title}</Text>
          {rightIcon && <View style={styles.iconRight}>{rightIcon}</View>}
        </React.Fragment>
      )}
    </TouchableOpacity>
  );
}</document_content>
</document>
<document index="29">
<source>golf-tracker/src/components/forms/FormButton/styles.ts</source>
<document_content>
// src/components/forms/FormButton/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  button: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: 8,
  },
  buttonFullWidth: {
    width: '100%',
  },
  buttonDisabled: {
    opacity: 0.6,
  },

  // Size variations
  buttonSmall: {
    height: 36,
    paddingHorizontal: 16,
  },
  buttonMedium: {
    height: 48,
    paddingHorizontal: 24,
  },
  buttonLarge: {
    height: 56,
    paddingHorizontal: 32,
  },

  // Variant styles
  buttonPrimary: {
    backgroundColor: '#2f95dc',
  },
  buttonSecondary: {
    backgroundColor: '#f5f5f5',
  },
  buttonOutline: {
    backgroundColor: 'transparent',
    borderWidth: 2,
    borderColor: '#2f95dc',
  },
  buttonDanger: {
    backgroundColor: '#ff3b30',
  },

  // Text base style
  buttonText: {
    fontSize: 16,
    fontWeight: '600',
    textAlign: 'center',
  },

  // Text size variations
  textSmall: {
    fontSize: 14,
  },
  textMedium: {
    fontSize: 16,
  },
  textLarge: {
    fontSize: 18,
  },

  // Text variant styles
  textPrimary: {
    color: '#fff',
  },
  textSecondary: {
    color: '#333',
  },
  textOutline: {
    color: '#2f95dc',
  },
  textDanger: {
    color: '#fff',
  },
  textDisabled: {
    color: '#999',
  },

  // Icon styles
  iconLeft: {
    marginRight: 8,
  },
  iconRight: {
    marginLeft: 8,
  },
});</document_content>
</document>
<document index="30">
<source>golf-tracker/src/components/layout/AuthLayout/index.tsx</source>
<document_content>
// src/components/layout/AuthLayout/index.tsx
import React from 'react';
import {
  View,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  SafeAreaView,
  StatusBar,
  ViewStyle,
} from 'react-native';
import { ErrorBoundary } from '../../common/ErrorBoundary';
import { styles } from './styles';

interface AuthLayoutProps {
  children: React.ReactNode;
  contentContainerStyle?: ViewStyle;
  scrollEnabled?: boolean;
  showStatusBar?: boolean;
}

export function AuthLayout({
  children,
  contentContainerStyle,
  scrollEnabled = true,
  showStatusBar = true,
}: AuthLayoutProps) {
  return (
    <ErrorBoundary>
      <SafeAreaView style={styles.container}>
        {showStatusBar && (
          <StatusBar
            barStyle="dark-content"
            backgroundColor="#fff"
            animated={true}
          />
        )}
        
        <KeyboardAvoidingView
          style={styles.keyboardView}
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          keyboardVerticalOffset={Platform.OS === 'ios' ? 0 : 20}
        >
          {scrollEnabled ? (
            <ScrollView
              style={styles.scrollView}
              contentContainerStyle={[
                styles.scrollContent,
                contentContainerStyle,
              ]}
              keyboardShouldPersistTaps="handled"
              showsVerticalScrollIndicator={false}
            >
              {children}
            </ScrollView>
          ) : (
            <View style={[styles.content, contentContainerStyle]}>
              {children}
            </View>
          )}
        </KeyboardAvoidingView>
      </SafeAreaView>
    </ErrorBoundary>
  );
}
</document_content>
</document>
<document index="31">
<source>golf-tracker/src/components/layout/AuthLayout/styles.ts</source>
<document_content>
// src/components/layout/AuthLayout/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  keyboardView: {
    flex: 1,
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    flexGrow: 1,
    padding: 20,
  },
  content: {
    flex: 1,
    padding: 20,
  },
});</document_content>
</document>
<document index="32">
<source>golf-tracker/src/components/layout/MainLayout/index.tsx</source>
<document_content>
// src/components/layout/MainLayout/index.tsx
import React from 'react';
import {
  View,
  SafeAreaView,
  StatusBar,
  ViewStyle,
  ScrollView,
  RefreshControl,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { ErrorBoundary } from '../../common/ErrorBoundary';
import { BackButton } from '../../common/BackButton';
import { styles } from './styles';

interface MainLayoutProps {
  children: React.ReactNode;
  title?: string;
  showBack?: boolean;
  showHeader?: boolean;
  contentContainerStyle?: ViewStyle;
  headerRight?: React.ReactNode;
  scrollEnabled?: boolean;
  refreshing?: boolean;
  onRefresh?: () => void;
  headerStyle?: ViewStyle;
}

export function MainLayout({
  children,
  showBack = false,
  showHeader = true,
  contentContainerStyle,
  headerRight,
  scrollEnabled = true,
  refreshing = false,
  onRefresh,
  headerStyle,
}: MainLayoutProps) {
  const renderHeader = () => {
    if (!showHeader) return null;

    return (
      <View style={[styles.header, headerStyle]}>
        <View style={styles.headerLeft}>
          {showBack && <BackButton />}
        </View>
        <View style={styles.headerRight}>
          {headerRight}
        </View>
      </View>
    );
  };

  const renderContent = () => {
    if (!scrollEnabled) {
      return (
        <View style={[styles.content, contentContainerStyle]}>
          {children}
        </View>
      );
    }

    return (
      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={[styles.scrollContent, contentContainerStyle]}
        keyboardShouldPersistTaps="handled"
        showsVerticalScrollIndicator={false}
        refreshControl={
          onRefresh ? (
            <RefreshControl
              refreshing={refreshing}
              onRefresh={onRefresh}
              tintColor="#2f95dc"
              colors={['#2f95dc']}
            />
          ) : undefined
        }
      >
        {children}
      </ScrollView>
    );
  };

  return (
    <ErrorBoundary>
      <SafeAreaView style={styles.container}>
        <StatusBar
          barStyle="dark-content"
          backgroundColor="#fff"
          animated={true}
        />
        
        {renderHeader()}

        <KeyboardAvoidingView
          style={styles.keyboardView}
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          keyboardVerticalOffset={Platform.OS === 'ios' ? 0 : 20}
        >
          {renderContent()}
        </KeyboardAvoidingView>
      </SafeAreaView>
    </ErrorBoundary>
  );
}</document_content>
</document>
<document index="33">
<source>golf-tracker/src/components/layout/MainLayout/styles.ts</source>
<document_content>
// src/components/layout/MainLayout/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  keyboardView: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
    backgroundColor: '#fff',
    minHeight: 56,
  },
  headerLeft: {
    flex: 1,
  },
  headerRight: {
    flex: 1,
    alignItems: 'flex-end',
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    flexGrow: 1,
    padding: 16,
  },
  content: {
    flex: 1,
    padding: 16,
  },
});</document_content>
</document>
<document index="34">
<source>golf-tracker/src/components/providers/AuthProvider.tsx</source>
<document_content>
// src/components/providers/AuthProvider.tsx
import React, { createContext, useContext, useState, useEffect } from 'react';
import { User, CreateUserInput } from 'shared';
import { authService } from '../../services/api/auth';
import { secureStorage, STORAGE_KEYS } from '../../services/storage/secureStorage';

interface AuthContextType {
  user: User | null;
  loading: boolean;
  error: string | null;
  login: (email: string, password: string) => Promise<void>;
  signup: (userData: CreateUserInput) => Promise<void>;
  logout: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    checkAuthStatus();
  }, []);

  const checkAuthStatus = async () => {
    try {
      setLoading(true);
      const token = await secureStorage.retrieve<string>(STORAGE_KEYS.AUTH_TOKEN);
      
      if (!token) {
        setUser(null);
        setLoading(false);
        return;
      }

      const validatedUser = await authService.validateToken(token);
      if (validatedUser) {
        setUser(validatedUser);
      } else {
        await secureStorage.remove(STORAGE_KEYS.AUTH_TOKEN);
        setUser(null);
      }
    } catch (error) {
      console.error('Error checking auth status:', error);
      setError('Failed to check authentication status');
      setUser(null);
    } finally {
      setLoading(false);
    }
  };

  const login = async (email: string, password: string) => {
    try {
      setLoading(true);
      setError(null);
      
      const { user, token } = await authService.login(email, password);
      console.log('Login response:', { user, token });
      
      if (token) {
        await secureStorage.store(STORAGE_KEYS.AUTH_TOKEN, token);
      }
      
      if (user) {
        console.log('Setting user state:', user);
        setUser(user);
      }
    } catch (error) {
      console.error('Login error:', error);
      setError(error instanceof Error ? error.message : 'Failed to login');
      throw error;
    } finally {
      setLoading(false);
    }
  };

  const signup = async (userData: CreateUserInput) => {
    try {
      setLoading(true);
      setError(null);
      
      const { user, token } = await authService.signup(userData);
      
      if (token) {
        await secureStorage.store(STORAGE_KEYS.AUTH_TOKEN, token);
      }
      
      if (user) {
        setUser(user);
      }
    } catch (error) {
      console.error('Signup error:', error);
      setError(error instanceof Error ? error.message : 'Failed to create account');
      throw error;
    } finally {
      setLoading(false);
    }
  };

  const logout = async () => {
    try {
      setLoading(true);
      setError(null);
      
      await authService.logout();
      await secureStorage.remove(STORAGE_KEYS.AUTH_TOKEN);
      
      setUser(null);
    } catch (error) {
      console.error('Logout error:', error);
      setError(error instanceof Error ? error.message : 'Failed to logout');
      throw error;
    } finally {
      setLoading(false);
    }
  };

  const value = {
    user,
    loading,
    error,
    login,
    signup,
    logout
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuthContext() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuthContext must be used within an AuthProvider');
  }
  return context;
}</document_content>
</document>
<document index="35">
<source>golf-tracker/src/components/providers/CourseProvider.tsx</source>
<document_content>
// Optional: Create a context provider for app-wide course state
import React, { createContext, useContext } from 'react';
import { useCourses } from '../../hooks/useCourses';

const CoursesContext = createContext<ReturnType<typeof useCourses> | undefined>(undefined);

export function CoursesProvider({ children }: { children: React.ReactNode }) {
  const courses = useCourses();
  return <CoursesContext.Provider value={courses}>{children}</CoursesContext.Provider>;
}

export function useCoursesContext() {
  const context = useContext(CoursesContext);
  if (context === undefined) {
    throw new Error('useCoursesContext must be used within a CoursesProvider');
  }
  return context;
}</document_content>
</document>
<document index="36">
<source>golf-tracker/src/components/common/ErrorBoundary/index.tsx</source>
<document_content>
// src/components/common/ErrorBoundary/index.tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { View, Text, TouchableOpacity } from 'react-native';
import { styles } from './styles';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
  onReset?: () => void;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = {
      hasError: false,
      error: null
    };
  }

  static getDerivedStateFromError(error: Error): State {
    return {
      hasError: true,
      error
    };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // Log error to your error reporting service
    console.error('ErrorBoundary caught an error:', error, errorInfo);
  }

  handleReset = () => {
    this.setState({
      hasError: false,
      error: null
    });
    
    this.props.onReset?.();
  };

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <View style={styles.container}>
          <Text style={styles.title}>Oops! Something went wrong</Text>
          <Text style={styles.message}>
            {this.state.error?.message || 'An unexpected error occurred'}
          </Text>
          <TouchableOpacity 
            style={styles.button}
            onPress={this.handleReset}
          >
            <Text style={styles.buttonText}>Try Again</Text>
          </TouchableOpacity>
        </View>
      );
    }

    return this.props.children;
  }
}</document_content>
</document>
<document index="37">
<source>golf-tracker/src/components/common/ErrorBoundary/styles.ts</source>
<document_content>
// src/components/common/ErrorBoundary/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 12,
  },
  message: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginBottom: 24,
  },
  button: {
    backgroundColor: '#2f95dc',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 8,
  },
  buttonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
});</document_content>
</document>
<document index="38">
<source>golf-tracker/src/components/common/LoadingScreen/index.tsx</source>
<document_content>
// src/components/common/LoadingScreen/index.tsx
import React from 'react';
import { View, ActivityIndicator } from 'react-native';
import { styles } from './styles';

export function LoadingScreen() {
  return (
    <View style={styles.container}>
      <ActivityIndicator size="large" color="#2f95dc" />
    </View>
  );
}</document_content>
</document>
<document index="39">
<source>golf-tracker/src/components/common/LoadingScreen/styles.ts</source>
<document_content>
// src/components/common/LoadingScreen/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#fff',
  },
});</document_content>
</document>
<document index="40">
<source>golf-tracker/src/components/common/BackButton/index.tsx</source>
<document_content>
// src/components/common/BackButton/index.tsx
import React from 'react';
import { TouchableOpacity } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { ChevronLeft } from 'lucide-react-native';
import { styles } from './styles';
import { Text } from 'react-native';

interface BackButtonProps {
  onPress?: () => void;
  title?: string;
  color?: string;
}

export function BackButton({ 
  onPress, 
  title = 'Back',
  color = '#2f95dc' 
}: BackButtonProps) {
  const navigation = useNavigation();

  const handlePress = () => {
    if (onPress) {
      onPress();
    } else {
      navigation.goBack();
    }
  };

  return (
    <TouchableOpacity 
      style={styles.container}
      onPress={handlePress}
      hitSlop={{ top: 10, right: 10, bottom: 10, left: 10 }}
    >
      <ChevronLeft size={24} color={color} />
      <Text style={[styles.text, { color }]}>{title}</Text>
    </TouchableOpacity>
  );
}

</document_content>
</document>
<document index="41">
<source>golf-tracker/src/components/common/BackButton/styles.ts</source>
<document_content>
// src/components/common/BackButton/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    top: 45,
    left: 8,
    flexDirection: 'row',
    alignItems: 'center',
  },
  text: {
    fontSize: 16,
    fontWeight: '500',
    marginLeft: -4,
  },
});</document_content>
</document>
<document index="42">
<source>golf-tracker/src/components/round/RoundDetails/index.tsx</source>
<document_content>
// src/components/round/RoundDetails/index.tsx
import React from 'react';
import { View, Text, TouchableOpacity } from 'react-native';
import DateTimePicker from '@react-native-community/datetimepicker';
import { Course } from 'shared';
import { FormInput } from '../../forms/FormInput';
import { FormButton } from '../../forms/FormButton';
import { TeeSelector } from '../../course/TeeSelector';
import { styles } from './styles';

interface RoundDetailsProps {
  course: Course;
  selectedTee: string;
  onTeeSelect: (tee: string) => void;
  date: Date;
  onDateChange: (date: Date) => void;
  score: string;
  onScoreChange: (score: string) => void;
  putts: string;
  onPuttsChange: (putts: string) => void;
  fairways: string;
  onFairwaysChange: (fairways: string) => void;
  greens: string;
  onGreensChange: (greens: string) => void;
  notes: string;
  onNotesChange: (notes: string) => void;
  errors: {[key: string]: string};
  loading: boolean;
  onSubmit: () => void;
  onChangeCourse: () => void;
}

export function RoundDetails({
  course,
  selectedTee,
  onTeeSelect,
  date,
  onDateChange,
  score,
  onScoreChange,
  putts,
  onPuttsChange,
  fairways,
  onFairwaysChange,
  greens,
  onGreensChange,
  notes,
  onNotesChange,
  errors,
  loading,
  onSubmit,
  onChangeCourse,
}: RoundDetailsProps) {
  return (
    <View style={styles.container}>
      <View style={styles.courseHeader}>
        <View>
          <Text style={styles.courseName}>{course.name}</Text>
          {course.location.city && (
            <Text style={styles.courseLocation}>
              {[course.location.city, course.location.state]
                .filter(Boolean)
                .join(', ')}
            </Text>
          )}
        </View>
        <TouchableOpacity
          onPress={onChangeCourse}
          style={styles.changeButton}
        >
          <Text style={styles.changeButtonText}>Change</Text>
        </TouchableOpacity>
      </View>

      <TeeSelector
        course={course}
        selectedTee={selectedTee}
        onTeeSelect={onTeeSelect}
        error={errors.tee}
      />

      <View style={styles.dateContainer}>
        <Text style={styles.label}>Date Played</Text>
        <DateTimePicker
          value={date}
          mode="date"
          display="default"
          onChange={(event, selectedDate) => {
            if (selectedDate) {
              onDateChange(selectedDate);
            }
          }}
          maximumDate={new Date()}
          style={styles.datePicker}
        />
      </View>

      <View style={styles.statsContainer}>
        <FormInput
          label="Score"
          value={score}
          onChangeText={onScoreChange}
          keyboardType="numeric"
          placeholder="Enter total score"
          error={errors.score}
          editable={!loading}
          containerStyle={styles.halfInput}
        />

        <FormInput
          label="Putts"
          value={putts}
          onChangeText={onPuttsChange}
          keyboardType="numeric"
          placeholder="Total putts"
          error={errors.putts}
          editable={!loading}
          containerStyle={styles.halfInput}
        />

        <FormInput
          label="Fairways Hit"
          value={fairways}
          onChangeText={onFairwaysChange}
          keyboardType="numeric"
          placeholder="# of fairways"
          error={errors.fairways}
          editable={!loading}
          containerStyle={styles.halfInput}
        />

        <FormInput
          label="Greens in Regulation"
          value={greens}
          onChangeText={onGreensChange}
          keyboardType="numeric"
          placeholder="# of GIRs"
          error={errors.greens}
          editable={!loading}
          containerStyle={styles.halfInput}
        />
      </View>

      <FormInput
        label="Notes"
        value={notes}
        onChangeText={onNotesChange}
        placeholder="Add notes about your round"
        multiline
        numberOfLines={4}
        editable={!loading}
        containerStyle={styles.notesInput}
      />

      <FormButton
        title="Save Round"
        onPress={onSubmit}
        loading={loading}
        style={styles.submitButton}
      />
    </View>
  );
}</document_content>
</document>
<document index="43">
<source>golf-tracker/src/components/round/RoundDetails/styles.ts</source>
<document_content>
// src/components/round/RoundDetails/styles.ts
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  container: {
    padding: 16,
  },
  courseHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 24,
  },
  courseName: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#333',
  },
  courseLocation: {
    fontSize: 14,
    color: '#666',
    marginTop: 4,
  },
  changeButton: {
    padding: 8,
  },
  changeButtonText: {
    color: '#2f95dc',
    fontSize: 16,
    fontWeight: '500',
  },
  dateContainer: {
    marginBottom: 24,
  },
  label: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
  },
  datePicker: {
    backgroundColor: '#fff',
    borderRadius: 8,
  },
  statsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    marginBottom: 24,
    gap: 16,
  },
  halfInput: {
    width: '48%',
  },
  notesInput: {
    marginBottom: 24,
  },
  submitButton: {
    marginTop: 'auto',
  },
});</document_content>
</document>
<document index="44">
<source>golf-tracker/src/hooks/useForm.ts</source>
<document_content>
// src/hooks/useForm.ts
import { useState, useCallback } from 'react';

type ValidationRule<T> = {
  validate: (value: any, formValues?: T) => boolean;
  message: string;
};

type ValidationRules<T> = {
  [K in keyof T]?: ValidationRule<T>[];
};

type FormErrors<T> = {
  [K in keyof T]?: string;
};

type TouchedFields<T> = {
  [K in keyof T]?: boolean;
};

interface UseFormConfig<T extends Record<string, any>> {
  initialValues: T;
  validationRules?: ValidationRules<T>;
  onSubmit: (values: T) => void | Promise<void>;
}

interface UseFormReturn<T> {
  values: T;
  errors: FormErrors<T>;
  touched: TouchedFields<T>;
  isSubmitting: boolean;
  handleChange: <K extends keyof T>(field: K) => (value: T[K]) => void;
  handleBlur: (field: keyof T) => () => void;
  setFieldValue: <K extends keyof T>(field: K, value: T[K]) => void;
  setFieldError: <K extends keyof T>(field: K, error: string) => void;
  setErrors: (errors: FormErrors<T>) => void;
  handleSubmit: () => Promise<void>;
  resetForm: () => void;
  setTouched: (touched: TouchedFields<T>) => void;
  validateField: (field: keyof T) => string | undefined;
  validateForm: () => FormErrors<T>;
}

export function useForm<T extends Record<string, any>>({
  initialValues,
  validationRules = {},
  onSubmit
}: UseFormConfig<T>): UseFormReturn<T> {
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<FormErrors<T>>({});
  const [touched, setTouched] = useState<TouchedFields<T>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Validate a single field
  const validateField = useCallback(
    (field: keyof T): string | undefined => {
      const fieldRules = validationRules[field];
      if (!fieldRules) return undefined;

      for (const rule of fieldRules) {
        if (!rule.validate(values[field], values)) {
          return rule.message;
        }
      }
      return undefined;
    },
    [values, validationRules]
  );

  // Validate all form fields
  const validateForm = useCallback((): FormErrors<T> => {
    const newErrors: FormErrors<T> = {};
    
    for (const field in validationRules) {
      const error = validateField(field as keyof T);
      if (error) {
        newErrors[field as keyof T] = error;
      }
    }
    
    return newErrors;
  }, [validateField, validationRules]);

  // Handle field change
  const handleChange = useCallback(<K extends keyof T>(field: K) => (value: T[K]) => {
    setValues(prev => ({ ...prev, [field]: value }));
    if (errors[field]) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors[field];
        return newErrors;
      });
    }
  }, [errors]);

  // Handle field blur
  const handleBlur = useCallback((field: keyof T) => () => {
    setTouched(prev => ({ ...prev, [field]: true }));

    const error = validateField(field);
    if (error) {
      setErrors(prev => ({ ...prev, [field]: error }));
    }
  }, [validateField]);

  // Set a specific field's value
  const setFieldValue = useCallback(<K extends keyof T>(field: K, value: T[K]) => {
    setValues(prev => ({ ...prev, [field]: value }));
  }, []);

  // Set a specific field's error
  const setFieldError = useCallback(<K extends keyof T>(field: K, error: string) => {
    setErrors(prev => ({ ...prev, [field]: error }));
  }, []);

  // Handle form submission
  const handleSubmit = async () => {
    try {
      setIsSubmitting(true);

      // Validate all fields
      const newErrors = validateForm();
      setErrors(newErrors);

      // Mark all fields as touched
      const allTouched: TouchedFields<T> = {};
      for (const field in values) {
        allTouched[field as keyof T] = true;
      }
      setTouched(allTouched);

      // If there are any errors, stop submission
      if (Object.keys(newErrors).length > 0) {
        return;
      }

      // Call the onSubmit handler
      await onSubmit(values);
    } catch (error) {
      // Let the error propagate to be handled by the form component
      throw error;
    } finally {
      setIsSubmitting(false);
    }
  };

  // Reset form to initial state
  const resetForm = useCallback(() => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
    setIsSubmitting(false);
  }, [initialValues]);

  return {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleBlur,
    setFieldValue,
    setFieldError,
    setErrors,
    handleSubmit,
    resetForm,
    setTouched,
    validateField,
    validateForm
  };
}

// Example Usage:
/*
const form = useForm({
  initialValues: {
    email: '',
    password: ''
  },
  validationRules: {
    email: [
      {
        validate: (value) => !!value,
        message: 'Email is required'
      }
    ],
    password: [
      {
        validate: (value) => !!value,
        message: 'Password is required'
      }
    ]
  },
  onSubmit: async (values) => {
    await submitFunction(values);
  }
});
*/</document_content>
</document>
<document index="45">
<source>golf-tracker/src/hooks/useRounds.ts</source>
<document_content>
// src/hooks/useRounds.ts
import { useState, useCallback } from 'react';
import { Round, CreateRoundInput } from 'shared';
import { roundService } from '../services/api/rounds';
import { useAuth } from './useAuth';

interface UseRounds {
  rounds: Round[];
  loading: boolean;
  error: string | null;
  getUserRounds: () => Promise<void>;
  createRound: (roundData: Omit<CreateRoundInput, 'addedBy'>) => Promise<Round>;
  deleteRound: (roundId: string) => Promise<void>;
}

export function useRounds(): UseRounds {
  const { user } = useAuth();
  const [rounds, setRounds] = useState<Round[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const getUserRounds = useCallback(async () => {
    if (!user?._id) return;

    try {
      setLoading(true);
      setError(null);
      
      const userRounds = await roundService.getUserRounds(user._id, {
        sortBy: 'date',
        sortOrder: 'desc'
      });
      setRounds(userRounds);
    } catch (error) {
      console.error('Error fetching rounds:', error);
      setError(error instanceof Error ? error.message : 'Failed to fetch rounds');
      setRounds([]);
    } finally {
      setLoading(false);
    }
  }, [user?._id]);

  const createRound = useCallback(async (roundData: Omit<CreateRoundInput, 'addedBy'>) => {
    if (!user?._id) throw new Error('User not authenticated');

    try {
      setLoading(true);
      setError(null);
      
      const newRound = await roundService.createRound({
        ...roundData,
        addedBy: user._id
      });

      setRounds(prev => [newRound, ...prev].sort((a, b) => 
        new Date(b.date).getTime() - new Date(a.date).getTime()
      ));

      return newRound;
    } catch (error) {
      console.error('Error creating round:', error);
      setError(error instanceof Error ? error.message : 'Failed to create round');
      throw error;
    } finally {
      setLoading(false);
    }
  }, [user?._id]);

  const deleteRound = useCallback(async (roundId: string) => {
    try {
      setLoading(true);
      setError(null);
      
      await roundService.deleteRound(roundId);
      setRounds(prev => prev.filter(round => round._id !== roundId));
    } catch (error) {
      console.error('Error deleting round:', error);
      setError(error instanceof Error ? error.message : 'Failed to delete round');
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  return {
    rounds,
    loading,
    error,
    getUserRounds,
    createRound,
    deleteRound
  };
}</document_content>
</document>
<document index="46">
<source>golf-tracker/src/hooks/useCourses.ts</source>
<document_content>
// src/hooks/useCourses.ts
import { useState, useCallback } from 'react';
import { Course, CreateCourseInput } from 'shared';
import { courseService } from '../services/api/courses';

interface UseCourses {
  courses: Course[];
  loading: boolean;
  error: string | null;
  searchCourses: (query: string) => Promise<void>;
  createCourse: (courseData: CreateCourseInput) => Promise<Course>;
  addTeeToCourse: (
    courseId: string,
    teeData: {
      name: string;
      rating: number;
      slope: number;
      numberOfFairways: number;
    }
  ) => Promise<Course>;
}

export function useCourses(): UseCourses {
  const [courses, setCourses] = useState<Course[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const searchCourses = useCallback(async (query: string) => {
    try {
      setLoading(true);
      setError(null);
      
      const results = await courseService.searchCourses(query);
      setCourses(results);
    } catch (error) {
      console.error('Error searching courses:', error);
      setError(error instanceof Error ? error.message : 'Failed to search courses');
      setCourses([]);
    } finally {
      setLoading(false);
    }
  }, []);

  const createCourse = useCallback(async (courseData: CreateCourseInput) => {
    try {
      setLoading(true);
      setError(null);
      
      const newCourse = await courseService.createCourse(courseData);
      setCourses(prev => [...prev, newCourse]);
      return newCourse;
    } catch (error) {
      console.error('Error creating course:', error);
      setError(error instanceof Error ? error.message : 'Failed to create course');
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  const addTeeToCourse = useCallback(async (
    courseId: string,
    teeData: {
      name: string;
      rating: number;
      slope: number;
      numberOfFairways: number;
    }
  ) => {
    try {
      setLoading(true);
      setError(null);
      
      const updatedCourse = await courseService.addTeeToCourse(courseId, teeData);
      setCourses(prev => prev.map(course => 
        course._id === courseId ? updatedCourse : course
      ));
      return updatedCourse;
    } catch (error) {
      console.error('Error adding tee to course:', error);
      setError(error instanceof Error ? error.message : 'Failed to add tee');
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  return {
    courses,
    loading,
    error,
    searchCourses,
    createCourse,
    addTeeToCourse
  };
}</document_content>
</document>
<document index="47">
<source>golf-tracker/src/hooks/useAuth.ts</source>
<document_content>
// src/hooks/useAuth.ts
import { useState, useEffect, useCallback } from 'react';
import { User, CreateUserInput } from 'shared';
import { authService } from '../services/api/auth';
import { secureStorage, STORAGE_KEYS } from '../services/storage/secureStorage';

interface AuthState {
  user: User | null;
  loading: boolean;
  error: string | null;
}

interface UseAuth {
  user: User | null;
  loading: boolean;
  error: string | null;
  login: (email: string, password: string) => Promise<void>;
  signup: (userData: CreateUserInput) => Promise<void>;
  logout: () => Promise<void>;
}

export function useAuth(): UseAuth {
  const [state, setState] = useState<AuthState>({
    user: null,
    loading: true,
    error: null,
  });

  useEffect(() => {
    checkAuthStatus();
  }, []);

  const checkAuthStatus = async () => {
    try {
      setState(prev => ({ ...prev, loading: true }));
      const token = await secureStorage.retrieve<string>(STORAGE_KEYS.AUTH_TOKEN);
      
      if (!token) {
        setState({ user: null, loading: false, error: null });
        return;
      }

      const user = await authService.validateToken(token);
      if (user) {
        setState({ user, loading: false, error: null });
      } else {
        await authService.logout();
        setState({ user: null, loading: false, error: null });
      }
    } catch (error) {
      console.error('Error checking auth status:', error);
      setState({
        user: null,
        loading: false,
        error: 'Failed to check authentication status'
      });
    }
  };

  const login = useCallback(async (email: string, password: string) => {
    try {
      setState(prev => ({ ...prev, loading: true, error: null }));
      const { user, token } = await authService.login(email, password);
      
      // Store the token
      await secureStorage.store(STORAGE_KEYS.AUTH_TOKEN, token);
      
      // Update state with user
      setState({ user, loading: false, error: null });
      
      console.log('Login successful, user state updated:', user); // Debug log
    } catch (error) {
      console.error('Login error:', error);
      setState(prev => ({
        ...prev,
        loading: false,
        error: error instanceof Error ? error.message : 'Failed to login'
      }));
      throw error;
    }
  }, []);

  const signup = useCallback(async (userData: CreateUserInput) => {
    try {
      setState(prev => ({ ...prev, loading: true, error: null }));
      const user = await authService.signup(userData);
      setState({ user, loading: false, error: null });
    } catch (error) {
      console.error('Signup error:', error);
      setState(prev => ({
        ...prev,
        loading: false,
        error: error instanceof Error ? error.message : 'Failed to create account'
      }));
      throw error;
    }
  }, []);

  const logout = useCallback(async () => {
    try {
      setState(prev => ({ ...prev, loading: true, error: null }));
      await authService.logout();
      setState({ user: null, loading: false, error: null });
    } catch (error) {
      console.error('Logout error:', error);
      setState(prev => ({
        ...prev,
        loading: false,
        error: error instanceof Error ? error.message : 'Failed to logout'
      }));
      throw error;
    }
  }, []);

  return {
    user: state.user,
    loading: state.loading,
    error: state.error,
    login,
    signup,
    logout
  };
}</document_content>
</document>
<document index="48">
<source>golf-tracker/src/services/storage/secureStorage.ts</source>
<document_content>
// src/services/storage/secureStorage.ts
import * as SecureStore from 'expo-secure-store';

// Storage keys
export const STORAGE_KEYS = {
  AUTH_TOKEN: 'auth_token',
  USER_DATA: 'user_data',
  SETTINGS: 'user_settings',
} as const;

type StorageKey = typeof STORAGE_KEYS[keyof typeof STORAGE_KEYS];

/**
 * Generic secure storage service with type safety
 */
class SecureStorageService {
  /**
   * Store a value securely
   */
  async store<T>(key: StorageKey, value: T): Promise<void> {
    try {
      const jsonValue = JSON.stringify(value);
      await SecureStore.setItemAsync(key, jsonValue);
    } catch (error) {
      console.error(`Error storing ${key}:`, error);
      throw new Error(`Failed to store ${key}`);
    }
  }

  /**
   * Retrieve a value from secure storage
   */
  async retrieve<T>(key: StorageKey): Promise<T | null> {
    try {
      const jsonValue = await SecureStore.getItemAsync(key);
      return jsonValue ? JSON.parse(jsonValue) : null;
    } catch (error) {
      console.error(`Error retrieving ${key}:`, error);
      throw new Error(`Failed to retrieve ${key}`);
    }
  }

  /**
   * Remove a value from secure storage
   */
  async remove(key: StorageKey): Promise<void> {
    try {
      await SecureStore.deleteItemAsync(key);
    } catch (error) {
      console.error(`Error removing ${key}:`, error);
      throw new Error(`Failed to remove ${key}`);
    }
  }

  /**
   * Clear all stored values
   */
  async clear(): Promise<void> {
    try {
      const keys = Object.values(STORAGE_KEYS);
      await Promise.all(keys.map(key => this.remove(key)));
    } catch (error) {
      console.error('Error clearing storage:', error);
      throw new Error('Failed to clear storage');
    }
  }
}

// Export singleton instance
export const secureStorage = new SecureStorageService();</document_content>
</document>
<document index="49">
<source>golf-tracker/src/services/api/courses.ts</source>
<document_content>
// src/services/api/courses.ts
import { Course, CreateCourseInput } from 'shared';
import { authService } from './auth';

const API_URL = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:3000/api';

export class CourseError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'CourseError';
  }
}

interface CourseResponse {
  success: boolean;
  data: Course | Course[];
  message?: string;
}

class CourseService {
  /**
   * Get auth headers
   */
  private async getHeaders(): Promise<Headers> {
    const token = await authService.getToken();
    if (!token) {
      throw new CourseError('No auth token found');
    }

    return new Headers({
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    });
  }

  /**
   * Handle API response
   */
  private async handleResponse(response: Response): Promise<CourseResponse> {
    const data = await response.json();
    if (!response.ok) {
      throw new CourseError(data.message || 'Course operation failed');
    }
    return data;
  }

  /**
   * Search courses
   */
  async searchCourses(query: string): Promise<Course[]> {
    const headers = await this.getHeaders();
    const response = await fetch(
      `${API_URL}/courses?search=${encodeURIComponent(query)}`,
      { method: 'GET', headers }
    );

    const data = await this.handleResponse(response);
    return Array.isArray(data.data) ? data.data : [];
  }

  /**
   * Create course
   */
  async createCourse(courseData: CreateCourseInput): Promise<Course> {
    const headers = await this.getHeaders();
    const response = await fetch(`${API_URL}/courses`, {
      method: 'POST',
      headers,
      body: JSON.stringify(courseData)
    });

    const data = await this.handleResponse(response);
    return data.data as Course;
  }

  /**
   * Add tee to course
   */
  async addTeeToCourse(
    courseId: string,
    teeData: {
      name: string;
      rating: number;
      slope: number;
      numberOfFairways: number;
    }
  ): Promise<Course> {
    const headers = await this.getHeaders();
    const response = await fetch(`${API_URL}/courses/${courseId}/tees`, {
      method: 'POST',
      headers,
      body: JSON.stringify(teeData)
    });

    const data = await this.handleResponse(response);
    return data.data as Course;
  }

  /**
   * Delete course
   */
  async deleteCourse(courseId: string): Promise<void> {
    const headers = await this.getHeaders();
    const response = await fetch(`${API_URL}/courses/${courseId}`, {
      method: 'DELETE',
      headers
    });

    if (!response.ok) {
      const data = await response.json();
      throw new CourseError(data.message || 'Failed to delete course');
    }
  }
}

// Export singleton instance
export const courseService = new CourseService();</document_content>
</document>
<document index="50">
<source>golf-tracker/src/services/api/rounds.ts</source>
<document_content>
// src/services/api/rounds.ts
import { Round, CreateRoundInput } from 'shared';
import { authService } from './auth';

const API_URL = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:3000/api';

export class RoundError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'RoundError';
  }
}

interface RoundResponse {
  success: boolean;
  data: Round | Round[];
  message?: string;
}

class RoundService {
  /**
   * Get auth headers
   */
  private async getHeaders(): Promise<Headers> {
    const token = await authService.getToken();
    if (!token) {
      throw new RoundError('No auth token found');
    }

    return new Headers({
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    });
  }

  /**
   * Handle API response
   */
  private async handleResponse(response: Response): Promise<RoundResponse> {
    const data = await response.json();
    if (!response.ok) {
      throw new RoundError(data.message || 'Round operation failed');
    }
    return data;
  }

  /**
   * Format date for API
   */
  private formatDate(date: Date | string): string {
    return date instanceof Date ? date.toISOString() : date;
  }

  /**
   * Get user rounds
   */
  async getUserRounds(userId: string, options?: {
    limit?: number;
    offset?: number;
    sortBy?: 'date' | 'score';
    sortOrder?: 'asc' | 'desc';
  }): Promise<Round[]> {
    const headers = await this.getHeaders();
    const url = new URL(`${API_URL}/rounds`);
    
    url.searchParams.append('userId', userId);
    if (options?.limit) url.searchParams.append('limit', options.limit.toString());
    if (options?.offset) url.searchParams.append('offset', options.offset.toString());
    if (options?.sortBy) url.searchParams.append('sortBy', options.sortBy);
    if (options?.sortOrder) url.searchParams.append('sortOrder', options.sortOrder);

    const response = await fetch(url.toString(), { method: 'GET', headers });
    const data = await this.handleResponse(response);
    return Array.isArray(data.data) ? data.data : [];
  }

  /**
   * Create round
   */
  async createRound(roundData: CreateRoundInput): Promise<Round> {
    const headers = await this.getHeaders();
    const formattedData = {
      ...roundData,
      date: this.formatDate(roundData.date)
    };

    const response = await fetch(`${API_URL}/rounds`, {
      method: 'POST',
      headers,
      body: JSON.stringify(formattedData)
    });

    const data = await this.handleResponse(response);
    return data.data as Round;
  }

  /**
   * Delete round
   */
  async deleteRound(roundId: string): Promise<void> {
    const headers = await this.getHeaders();
    const response = await fetch(`${API_URL}/rounds/${roundId}`, {
      method: 'DELETE',
      headers
    });

    if (!response.ok) {
      const data = await response.json();
      throw new RoundError(data.message || 'Failed to delete round');
    }
  }
}

// Export singleton instance
export const roundService = new RoundService();</document_content>
</document>
<document index="51">
<source>golf-tracker/src/services/api/auth.ts</source>
<document_content>
// src/services/api/auth.ts
import { User, CreateUserInput } from 'shared';
import { secureStorage, STORAGE_KEYS } from '../storage/secureStorage';

const API_URL = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:3000/api';

export class AuthError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'AuthError';
  }
}

interface AuthResponse {
  success: boolean;
  data: {
    user: User;
    token: string;
  };
  message?: string;
}

interface AuthResult {
  user: User;
  token: string;
}

class AuthService {
  private async handleAuthResponse(response: Response): Promise<AuthResponse> {
    const data = await response.json();
    if (!response.ok) {
      throw new AuthError(data.message || 'Authentication failed');
    }
    return data as AuthResponse;
  }

  async login(email: string, password: string): Promise<AuthResult> {
    try {
      const response = await fetch(`${API_URL}/auth/login`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password }),
      });

      const data = await this.handleAuthResponse(response);
      if (!data.data?.token || !data.data?.user) {
        throw new AuthError('Invalid server response');
      }

      return {
        user: data.data.user,
        token: data.data.token
      };
    } catch (error) {
      if (error instanceof AuthError) throw error;
      throw new AuthError('Failed to log in');
    }
  }

  async signup(userData: CreateUserInput): Promise<AuthResult> {
    try {
      const response = await fetch(`${API_URL}/auth/signup`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(userData),
      });

      const data = await this.handleAuthResponse(response);
      if (!data.data?.token || !data.data?.user) {
        throw new AuthError('Invalid server response');
      }

      return {
        user: data.data.user,
        token: data.data.token
      };
    } catch (error) {
      if (error instanceof AuthError) throw error;
      throw new AuthError('Failed to create account');
    }
  }

  async validateToken(token: string): Promise<User | null> {
    try {
      const response = await fetch(`${API_URL}/auth/validate`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });

      if (!response.ok) return null;

      const data = await response.json();
      return data.data?.user || null;
    } catch {
      return null;
    }
  }

  async logout(): Promise<void> {
    await secureStorage.remove(STORAGE_KEYS.AUTH_TOKEN);
  }

  async getToken(): Promise<string | null> {
    return secureStorage.retrieve<string>(STORAGE_KEYS.AUTH_TOKEN);
  }
}

export const authService = new AuthService();</document_content>
</document>
<document index="2">
<source>server/middleware/auth.ts</source>
<document_content>
// server/middleware/auth.ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { User } from 'shared';
import UserModel, { IUser } from '../models/User';

interface JwtPayload {
  userId: string;
  email: string;
}

// Helper function to convert MongoDB document to User type
export function mapUserToResponse(user: IUser): User {
  const userObj = user.toObject();
  return {
    _id: userObj._id.toString(),
    email: userObj.email,
    name: userObj.name,
    createdAt: userObj.createdAt,
    updatedAt: userObj.updatedAt,
    savedCourses: (userObj.savedCourses || []).map((course: any) => ({
      ...course,
      _id: course._id.toString(),
      addedBy: course.addedBy.toString()
    })),
    rounds: (userObj.rounds || []).map((round: any) => ({
      ...round,
      _id: round._id.toString(),
      addedBy: round.addedBy.toString(),
      course: {
        ...round.course,
        _id: round.course._id.toString(),
        addedBy: round.course.addedBy.toString()
      }
    }))
  };
}

export const authenticateToken = async (
  req: Request & { user?: User },
  res: Response,
  next: NextFunction
) => {
  console.log('Authenticating token...');

  try {
    const authHeader = req.headers.authorization;
    if (!authHeader?.startsWith('Bearer ')) {
      return res.status(401).json({
        success: false,
        message: 'No token provided'
      });
    }

    const token = authHeader.split(' ')[1];
    
    if (!process.env.JWT_SECRET) {
      console.error('JWT_SECRET not configured');
      return res.status(500).json({
        success: false,
        message: 'Server configuration error'
      });
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET) as JwtPayload;
    console.log('Token decoded:', decoded);

    const user = await UserModel.findById(decoded.userId)
      .select('-password')
      .populate({
        path: 'rounds',
        populate: {
          path: 'course'
        }
      })
      .populate('savedCourses');

    if (!user) {
      console.log('User not found for token');
      return res.status(401).json({
        success: false,
        message: 'User not found'
      });
    }

    console.log('User found:', user.email);
    req.user = mapUserToResponse(user);
    next();
  } catch (error) {
    console.error('Auth middleware error:', error);
    if (error instanceof jwt.JsonWebTokenError) {
      return res.status(401).json({
        success: false,
        message: 'Invalid token'
      });
    }

    return res.status(500).json({
      success: false,
      message: 'Internal server error'
    });
  }
};</document_content>
</document>
<document index="3">
<source>server/models/Round.ts</source>
<document_content>
// server/models/Round.ts
import mongoose, { Schema } from 'mongoose';
import { Round } from 'shared';
import CourseModel from './Course';

export interface IRound extends Omit<Round, '_id' | 'course' | 'addedBy'> {
  _id: mongoose.Types.ObjectId;
  course: mongoose.Types.ObjectId;
  addedBy: mongoose.Types.ObjectId;
}

const roundSchema = new Schema({
  course: {
    type: Schema.Types.ObjectId,
    ref: 'Course',
    required: true
  },
  date: {
    type: Date,
    required: true,
    default: Date.now
  },
  tees: {
    type: String,
    required: true
  },
  score: {
    type: Number,
    required: true
  },
  putts: {
    type: Number,
    required: true
  },
  fairways: {
    type: Number,
    required: true
  },
  greens: {
    type: Number,
    required: true
  },
  notes: {
    type: String
  },
  differential: {
    type: Number,
    required: true
  },
  addedBy: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
  }
}, {
  timestamps: true
});

// Add indexes for common queries
roundSchema.index({ addedBy: 1, date: -1 });
roundSchema.index({ course: 1, addedBy: 1 });

// Pre-save middleware to calculate differential
roundSchema.pre('save', async function(next) {
  if (this.isModified('score') || this.isModified('course') || this.isModified('tees')) {
    try {
      const course = await CourseModel.findById(this.course);
      if (!course) {
        throw new Error('Course not found');
      }

      const tee = course.tees.find(t => t.name === this.tees);
      if (!tee) {
        throw new Error('Tee not found');
      }

      // Calculate differential using USGA formula
      this.differential = ((this.score - tee.rating) * 113) / tee.slope;
      // Round to one decimal place
      this.differential = Math.round(this.differential * 10) / 10;
    } catch (error) {
      next(error as Error);
      return;
    }
  }
  next();
});

const Round = mongoose.model<IRound>('Round', roundSchema);
export default Round;</document_content>
</document>
<document index="4">
<source>server/models/Course.ts</source>
<document_content>
// server/models/Course.ts
import mongoose from 'mongoose';
import { Course } from 'shared';

export interface ICourse extends Omit<Course, '_id' | 'addedBy'> {
  _id: mongoose.Types.ObjectId;
  addedBy: mongoose.Types.ObjectId;
}

const teeSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true
  },
  rating: {
    type: Number,
    required: true
  },
  slope: {
    type: Number,
    required: true
  },
  numberOfFairways: {
    type: Number,
    required: true,
    min: 0,
    max: 18,
    validate: {
      validator: Number.isInteger,
      message: 'Number of fairways must be a whole number'
    }
  }
});

const courseSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  location: {
    city: {
      type: String,
      trim: true
    },
    state: {
      type: String,
      trim: true
    },
    country: {
      type: String,
      trim: true
    }
  },
  tees: [teeSchema],
  addedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  }
}, {
  timestamps: true
});

// Make courses unique by name + location
courseSchema.index({ 
  name: 1, 
  'location.city': 1, 
  'location.state': 1,
  'location.country': 1
}, { 
  unique: true,
  collation: { locale: 'en', strength: 2 } // Case-insensitive uniqueness
});

const Course = mongoose.model<ICourse>('Course', courseSchema);
export default Course;</document_content>
</document>
<document index="5">
<source>server/models/User.ts</source>
<document_content>
// server/models/User.ts
import mongoose from 'mongoose';
import bcrypt from 'bcryptjs';
import { ICourse } from './Course';
import { IRound } from './Round';

export interface IUser {
  _id: mongoose.Types.ObjectId;
  email: string;
  password: string;
  name?: string;
  savedCourses: mongoose.Types.ObjectId[] | ICourse[];
  rounds: mongoose.Types.ObjectId[] | IRound[];
  createdAt: Date;
  updatedAt: Date;
  comparePassword(candidatePassword: string): Promise<boolean>;
  toObject(): any;
}

const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: true,
    unique: true,
  },
  password: {
    type: String,
    required: true,
  },
  name: String,
  savedCourses: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Course'
  }],
  rounds: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Round'
  }]
}, {
  timestamps: true
});

// Hash password before saving
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();

  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error as Error);
  }
});

// Method to compare passwords
userSchema.methods.comparePassword = async function(candidatePassword: string): Promise<boolean> {
  try {
    return await bcrypt.compare(candidatePassword, this.password);
  } catch (error) {
    throw error;
  }
};

const User = mongoose.model<IUser>('User', userSchema);

export default User;</document_content>
</document>
<document index="6">
<source>server/index.ts</source>
<document_content>
// server/index.ts
import express from 'express';
import mongoose from 'mongoose';
import cors from 'cors';
import dotenv from 'dotenv';
import authRoutes from './routes/auth';
import courseRoutes from './routes/courses';
import roundRoutes from './routes/rounds';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;
const MONGODB_URI = process.env.MONGODB_URI;

if (!MONGODB_URI) {
  throw new Error('MONGODB_URI must be defined in environment variables');
}

// Configure CORS
app.use(cors({
  origin: ['http://localhost:19006', 'http://localhost:19000', 'exp://localhost:19000'],
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'Accept'],
  credentials: true
}));

// Parse JSON bodies
app.use(express.json());

// Connect to MongoDB
mongoose.connect(MONGODB_URI)
  .then(() => console.log('Connected to MongoDB'))
  .catch(err => {
    console.error('MongoDB connection error:', err);
    process.exit(1);
  });

// Mount routes
app.use('/api/auth', authRoutes);
app.use('/api/courses', courseRoutes);
app.use('/api/rounds', roundRoutes);

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ 
    status: 'healthy',
    timestamp: new Date().toISOString()
  });
});

// Error handling middleware
app.use((err: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {
  console.error('Server error:', err);
  res.status(500).json({
    success: false,
    message: 'Internal server error'
  });
});

// Start server
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});</document_content>
</document>
<document index="7">
<source>server/routes/courses.ts</source>
<document_content>
// server/routes/courses.ts
import express, { Request } from 'express';
import { Course, CreateCourseInput } from 'shared';
import CourseModel, { ICourse } from '../models/Course';
import { authenticateToken } from '../middleware/auth';

const router = express.Router();

function mapCourseToResponse(course: ICourse): Course {
  return {
    _id: course._id.toString(),
    name: course.name,
    location: course.location,
    tees: course.tees,
    addedBy: course.addedBy.toString(),
    createdAt: course.createdAt,
    updatedAt: course.updatedAt
  };
}

router.get('/', authenticateToken, async (req, res) => {
  try {
    const { search } = req.query;
    const query = search ? {
      $or: [
        { name: new RegExp(search as string, 'i') },
        { 'location.city': new RegExp(search as string, 'i') }
      ]
    } : {};

    const courses = await CourseModel.find(query).sort({ name: 1 }).limit(50);
    res.json({
      success: true,
      data: courses.map(mapCourseToResponse)
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching courses'
    });
  }
});

router.post('/', authenticateToken, async (req: Request & { user?: { _id: string } }, res) => {
  try {
    const userId = req.user?._id;
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'Unauthorized'
      });
    }

    const courseData: CreateCourseInput = {
      ...req.body,
      addedBy: userId
    };

    const course = new CourseModel(courseData);
    await course.save();

    res.status(201).json({
      success: true,
      data: mapCourseToResponse(course)
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error creating course'
    });
  }
});

router.post('/:courseId/tees', authenticateToken, async (req: Request & { user?: { _id: string } }, res) => {
  try {
    const { courseId } = req.params;
    const userId = req.user?._id;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'Unauthorized'
      });
    }

    // Find the course and verify ownership
    const course = await CourseModel.findById(courseId);
    if (!course) {
      return res.status(404).json({
        success: false,
        message: 'Course not found'
      });
    }

    if (course.addedBy.toString() !== userId) {
      return res.status(403).json({
        success: false,
        message: 'Not authorized to modify this course'
      });
    }

    // Validate tee data
    const teeData = req.body;
    if (!teeData.name || !teeData.rating || !teeData.slope || !teeData.numberOfFairways) {
      return res.status(400).json({
        success: false,
        message: 'Missing required tee information'
      });
    }

    // Validate tee data values
    if (typeof teeData.rating !== 'number' || teeData.rating < 0 || teeData.rating > 100) {
      return res.status(400).json({
        success: false,
        message: 'Invalid course rating. Must be between 0 and 100'
      });
    }

    if (typeof teeData.slope !== 'number' || teeData.slope < 55 || teeData.slope > 155) {
      return res.status(400).json({
        success: false,
        message: 'Invalid slope rating. Must be between 55 and 155'
      });
    }

    if (typeof teeData.numberOfFairways !== 'number' || 
        !Number.isInteger(teeData.numberOfFairways) || 
        teeData.numberOfFairways < 0 || 
        teeData.numberOfFairways > 18) {
      return res.status(400).json({
        success: false,
        message: 'Invalid number of fairways. Must be an integer between 0 and 18'
      });
    }

    // Check if tee color already exists
    const teeExists = course.tees.some(tee => 
      tee.name.toLowerCase() === teeData.name.toLowerCase()
    );

    if (teeExists) {
      return res.status(400).json({
        success: false,
        message: 'Tee color already exists'
      });
    }

    // Add the new tee
    course.tees.push({
      name: teeData.name.trim(),
      rating: Number(teeData.rating),
      slope: Number(teeData.slope),
      numberOfFairways: Number(teeData.numberOfFairways)
    });

    await course.save();

    res.json({
      success: true,
      data: mapCourseToResponse(course)
    });
  } catch (error) {
    console.error('Error adding tee to course:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while adding tee'
    });
  }
});

export default router;</document_content>
</document>
<document index="8">
<source>server/routes/rounds.ts</source>
<document_content>
// server/routes/rounds.ts
import express, { Request } from 'express';
import { Round, Course } from 'shared';
import RoundModel, { IRound } from '../models/Round';
import { ICourse } from '../models/Course';
import { authenticateToken } from '../middleware/auth';
import { Document, PopulatedDoc } from 'mongoose';

interface AuthRequest extends Request {
  user?: {
    _id: string;
    email: string;
  };
}

// Define an interface for a populated round document
interface PopulatedRound extends Omit<IRound, 'course'> {
  course: ICourse;
}

const router = express.Router();

function calculateDifferential(round: PopulatedRound): number {
  const tee = round.course.tees.find(t => t.name === round.tees);
  if (!tee) {
    throw new Error('Selected tee not found on course');
  }

  const differential = ((round.score - tee.rating) * 113) / tee.slope;
  return Math.round(differential * 10) / 10;
}

function mapCourseToResponse(course: any) {
  return {
    _id: course._id.toString(),
    name: course.name,
    location: course.location,
    tees: course.tees,
    addedBy: course.addedBy.toString(),
    createdAt: course.createdAt,
    updatedAt: course.updatedAt
  };
}

function mapRoundToResponse(round: PopulatedRound): Round {
  return {
    _id: round._id.toString(),
    course: mapCourseToResponse(round.course),
    date: round.date,
    tees: round.tees,
    score: round.score,
    putts: round.putts,
    fairways: round.fairways,
    greens: round.greens,
    notes: round.notes,
    differential: round.differential,
    addedBy: round.addedBy.toString(),
    createdAt: round.createdAt,
    updatedAt: round.updatedAt
  };
}

router.post('/', authenticateToken, async (req: AuthRequest, res) => {
  try {
    const userId = req.user?._id;
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User not authenticated'
      });
    }

    // Create round instance but don't save yet
    const round = new RoundModel({
      ...req.body,
      addedBy: userId
    });

    // Populate course data for differential calculation
    await round.populate<{ course: ICourse }>('course');

    // Now we can safely access the populated course data
    const populatedRound = round as unknown as PopulatedRound;
    
    // Calculate and set differential
    const differential = calculateDifferential(populatedRound);
    round.differential = differential;

    // Save the round with the calculated differential
    await round.save();

    res.status(201).json({
      success: true,
      data: mapRoundToResponse(populatedRound)
    });
  } catch (error) {
    console.error('Error creating round:', {
      error,
      roundData: req.body,
      userId: req.user?._id
    });
    
    if (error instanceof Error) {
      const errorMessage = error.message || 'Error creating round';
      res.status(400).json({
        success: false,
        message: errorMessage
      });
    } else {
      res.status(500).json({
        success: false,
        message: 'Internal server error creating round'
      });
    }
  }
});

interface PopulatedRound extends Omit<IRound, 'course'> {
  course: ICourse;
}

router.get('/', authenticateToken, async (req: AuthRequest, res) => {
  try {
    const userId = req.user?._id;
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User not authenticated'
      });
    }

    const rounds = await RoundModel.find({ addedBy: userId })
      .populate<{ course: ICourse }>('course')
      .sort({ date: -1 });

    const mappedRounds = rounds.map(round => {
      const roundObj = round.toObject();
      return {
        ...roundObj,
        _id: roundObj._id.toString(),
        course: {
          ...roundObj.course,
          _id: roundObj.course._id.toString(),
          addedBy: roundObj.course.addedBy.toString()
        },
        addedBy: roundObj.addedBy.toString()
      };
    });

    res.json({
      success: true,
      data: mappedRounds
    });
  } catch (error) {
    console.error('Error fetching rounds:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching rounds'
    });
  }
});

export default router;</document_content>
</document>
<document index="9">
<source>server/routes/auth.ts</source>
<document_content>
// server/routes/auth.ts
import express from 'express';
import jwt from 'jsonwebtoken';
import { z } from 'zod';
import { User } from 'shared';
import UserModel, { IUser } from '../models/User';
import { authenticateToken, mapUserToResponse } from '../middleware/auth';
import { Request } from 'express';

const router = express.Router();

async function getPopulatedUser(userId: string) {
  return await UserModel.findById(userId)
    .select('-password')
    .populate({
      path: 'rounds',
      populate: {
        path: 'course'
      }
    })
    .populate('savedCourses');
}

router.get('/validate', authenticateToken, async (req: Request & { user?: IUser }, res) => {
  try {
    if (!req.user?._id) {
      return res.status(401).json({
        success: false,
        message: 'User not found'
      });
    }

    const user = await getPopulatedUser(req.user._id.toString());
    if (!user) {
      return res.status(401).json({
        success: false,
        message: 'User not found'
      });
    }

    res.json({
      success: true,
      data: {
        user: user.toObject({
          transform: (doc, ret) => {
            ret._id = ret._id.toString();
            ret.rounds = ret.rounds.map((round: any) => ({
              ...round,
              _id: round._id.toString(),
              addedBy: round.addedBy.toString(),
              course: {
                ...round.course,
                _id: round.course._id.toString(),
                addedBy: round.course.addedBy.toString()
              }
            }));
            ret.savedCourses = ret.savedCourses.map((course: any) => ({
              ...course,
              _id: course._id.toString(),
              addedBy: course.addedBy.toString()
            }));
            return ret;
          }
        }),
        token: req.headers.authorization?.split(' ')[1]
      }
    });
  } catch (error) {
    console.error('Token validation error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

router.use((req, res, next) => {
  console.log('Auth Route:', req.method, req.path);
  console.log('Headers:', req.headers);
  next();
});

const signupSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
  name: z.string().min(1)
});

const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8)
});

function generateToken(user: IUser): string {
  if (!process.env.JWT_SECRET) {
    throw new Error('JWT_SECRET is not defined');
  }
  
  return jwt.sign(
    { userId: user._id.toString(), email: user.email },
    process.env.JWT_SECRET,
    { expiresIn: '30d' } // Extended token expiration to 30 days
  );
}


router.get('/validate', authenticateToken, async (req: Request & { user?: IUser }, res) => {
  try {
    // The authenticateToken middleware has already verified the token
    // and attached the user to the request
    const user = await UserModel.findById(req.user?._id).select('-password');
    
    if (!user) {
      return res.status(401).json({
        success: false,
        message: 'User not found'
      });
    }

    res.json({
      success: true,
      data: {
        user: mapUserToResponse(user),
        token: req.headers.authorization?.split(' ')[1] // Return the same token
      }
    });
  } catch (error) {
    console.error('Token validation error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

router.post('/signup', async (req, res) => {
  try {
    const validatedData = signupSchema.parse(req.body);
    const existingUser = await UserModel.findOne({
      email: { $regex: new RegExp(`^${validatedData.email}$`, 'i') }
    });

    if (existingUser) {
      return res.status(400).json({
        success: false,
        message: 'Email already registered'
      });
    }

    const user = new UserModel(validatedData);
    await user.save();

    const token = generateToken(user);

    res.status(201).json({
      success: true,
      data: {
        user: mapUserToResponse(user),
        token
      }
    });
  } catch (error) {
    console.error('Signup error:', error);
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        success: false,
        message: 'Validation error',
        errors: error.errors
      });
    }
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

router.post('/login', async (req, res) => {
  try {
    const validatedData = loginSchema.parse(req.body);
    const user = await UserModel.findOne({
      email: { $regex: new RegExp(`^${validatedData.email}$`, 'i') }
    });

    if (!user) {
      return res.status(401).json({
        success: false,
        message: 'Invalid credentials'
      });
    }

    const isValidPassword = await user.comparePassword(validatedData.password);
    if (!isValidPassword) {
      return res.status(401).json({
        success: false,
        message: 'Invalid credentials'
      });
    }

    const token = generateToken(user);

    res.json({
      success: true,
      data: {
        user: mapUserToResponse(user),
        token
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        success: false,
        message: 'Validation error',
        errors: error.errors
      });
    }
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

export default router;</document_content>
</document>
<document index="2">
<source>shared/dist/types/course.d.ts</source>
<document_content>
import { BaseDocument } from './base';
export interface Course extends BaseDocument {
    name: string;
    location: {
        city?: string;
        state?: string;
        country?: string;
    };
    tees: Array<{
        name: string;
        rating: number;
        slope: number;
        numberOfFairways: number;
    }>;
    addedBy: string;
}
export interface CreateCourseInput {
    name: string;
    location: {
        city?: string;
        state?: string;
        country?: string;
    };
    addedBy: string;
}
</document_content>
</document>
<document index="3">
<source>shared/dist/types/user.d.ts</source>
<document_content>
import { BaseDocument } from './base';
import { Round } from './round';
import { Course } from './course';
export interface User extends BaseDocument {
    email: string;
    name?: string;
    savedCourses: Course[];
    rounds: Round[];
}
export interface CreateUserInput {
    email: string;
    password: string;
    name?: string;
}
</document_content>
</document>
<document index="4">
<source>shared/dist/types/base.d.ts</source>
<document_content>
export interface BaseDocument {
    _id: string;
    createdAt: Date;
    updatedAt: Date;
}
</document_content>
</document>
<document index="5">
<source>shared/dist/types/round.d.ts</source>
<document_content>
import { BaseDocument } from './base';
import { Course } from './course';
export interface Round extends BaseDocument {
    course: Course;
    date: Date | string;
    tees: string;
    score: number;
    putts: number;
    fairways: number;
    greens: number;
    notes?: string;
    differential: number;
    addedBy: string;
}
export interface CreateRoundInput {
    course: Course;
    date: Date | string;
    tees: string;
    score: number;
    putts: number;
    fairways: number;
    greens: number;
    notes?: string;
    addedBy: string;
}
</document_content>
</document>
<document index="6">
<source>shared/dist/index.d.ts</source>
<document_content>
export * from './types/user';
export * from './types/course';
export * from './types/round';
</document_content>
</document>
<document index="7">
<source>shared/src/types/base.ts</source>
<document_content>
// shared/src/types/base.ts
export interface BaseDocument {
  _id: string;
  createdAt: Date;
  updatedAt: Date;
}
</document_content>
</document>
<document index="8">
<source>shared/src/types/round.ts</source>
<document_content>
import { BaseDocument } from './base';
import { Course } from './course';
export interface Round extends BaseDocument {
  course: Course;
  date: Date | string;
  tees: string;
  score: number;
  putts: number;
  fairways: number;
  greens: number;
  notes?: string;
  differential: number;
  addedBy: string;
}

export interface CreateRoundInput {
  course: Course;
  date: Date | string;
  tees: string;
  score: number;
  putts: number;
  fairways: number;
  greens: number;
  notes?: string;
  addedBy: string;
}</document_content>
</document>
<document index="9">
<source>shared/src/types/course.ts</source>
<document_content>
// shared/src/types/course.ts
import { BaseDocument } from './base';

export interface Course extends BaseDocument {
  name: string;
  location: {
    city?: string;
    state?: string;
    country?: string;
  };
  tees: Array<{
    name: string;
    rating: number;
    slope: number;
    numberOfFairways: number;
  }>;
  addedBy: string;
}

export interface CreateCourseInput {
  name: string;
  location: {
    city?: string;
    state?: string;
    country?: string;
  };
  addedBy: string;
}</document_content>
</document>
<document index="10">
<source>shared/src/types/user.ts</source>
<document_content>
// shared/src/types/user.ts
import { BaseDocument } from './base';
import { Round } from './round';
import { Course, CreateCourseInput } from './course';

export interface User extends BaseDocument {
  email: string;
  name?: string;
  savedCourses: Course[];
  rounds: Round[];
}

export interface CreateUserInput {
  email: string;
  password: string;
  name?: string;
}</document_content>
</document>
<document index="11">
<source>shared/src/index.ts</source>
<document_content>
// shared/src/index.ts
export * from './types/user';
export * from './types/course';
export * from './types/round';</document_content>
</document>
</documents>
