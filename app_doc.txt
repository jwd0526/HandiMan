<documents>
<document index="1">
<source>directory-structure.txt</source>
<document_content>
.
├── golf-tracker
│   ├── src
│   │   ├── components
│   │   │   ├── FormButton.tsx
│   │   │   └── FormInput.tsx
│   │   ├── config
│   │   │   └── database.ts
│   │   ├── contexts
│   │   │   └── AuthContext.tsx
│   │   ├── models
│   │   │   ├── Course.ts
│   │   │   ├── Round.ts
│   │   │   └── User.ts
│   │   ├── screens
│   │   │   ├── auth
│   │   │   │   ├── LandingScreen.tsx
│   │   │   │   ├── LoginScreen.tsx
│   │   │   │   └── SignupScreen.tsx
│   │   │   └── HomeScreen.tsx
│   │   ├── services
│   │   │   └── auth.ts
│   │   ├── types
│   │   │   └── navigation.ts
│   │   └── utils
│   ├── .gitignore
│   ├── App.tsx
│   ├── app.json
│   ├── index.js
│   ├── package-lock.json
│   ├── package.json
│   └── tsconfig.json
├── server
│   ├── middleware
│   │   └── auth.ts
│   ├── models
│   │   ├── Course.ts
│   │   ├── Round.ts
│   │   └── User.ts
│   ├── routes
│   │   ├── auth.ts
│   │   ├── courses.ts
│   │   └── rounds.ts
│   ├── .env
│   ├── index.ts
│   ├── package-lock.json
│   ├── package.json
│   └── tsconfig.json
├── shared
│   ├── src
│   │   ├── types
│   │   │   ├── base.ts
│   │   │   ├── course.ts
│   │   │   ├── round.ts
│   │   │   └── user.ts
│   │   └── index.ts
│   ├── package-lock.json
│   ├── package.json
│   └── tsconfig.json
├── .DS_Store
├── .gitignore
├── app_doc.txt
├── dev.sh
└── document-app.sh

19 directories, 45 files
</document_content>
</document>
<document index="2">
<source>golf-tracker/App.tsx</source>
<document_content>
// App.tsx
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { StatusBar } from 'expo-status-bar';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { AuthProvider, useAuth } from './src/contexts/AuthContext';

// Screens
import LandingScreen from './src/screens/auth/LandingScreen';
import LoginScreen from './src/screens/auth/LoginScreen';
import SignupScreen from './src/screens/auth/SignupScreen';
import HomeScreen from './src/screens/HomeScreen';

const AuthStack = createNativeStackNavigator();
const MainStack = createNativeStackNavigator();

// Separate the navigation components
function AuthNavigator() {
  return (
    <AuthStack.Navigator
      id={null}
      initialRouteName="Landing"
      screenOptions={{
        headerShown: false,
        contentStyle: { backgroundColor: '#fff' }
      }}
    >
      <AuthStack.Screen name="Landing" component={LandingScreen} />
      <AuthStack.Screen name="Login" component={LoginScreen} />
      <AuthStack.Screen name="Signup" component={SignupScreen} />
    </AuthStack.Navigator>
  );
}

function MainNavigator() {
  return (
    <MainStack.Navigator
      id={null}
      screenOptions={{
        headerShown: false,
        contentStyle: { backgroundColor: '#fff' }
      }}
    >
      <MainStack.Screen name="Home" component={HomeScreen} />
    </MainStack.Navigator>
  );
}

// Create a separate Navigation component
function Navigation() {
  const { user } = useAuth();
  
  return (
    <NavigationContainer>
      {user ? <MainNavigator /> : <AuthNavigator />}
    </NavigationContainer>
  );
}

// Main App component
export default function App() {
  return (
    <SafeAreaProvider>
      <AuthProvider>
        <StatusBar style="auto" />
        <Navigation />
      </AuthProvider>
    </SafeAreaProvider>
  );
}</document_content>
</document>
<document index="3">
<source>golf-tracker/src/types/navigation.ts</source>
<document_content>
// src/types/navigation.ts
export type AuthStackParamList = {
  Landing: undefined;
  Login: undefined;
  Signup: undefined;
};

export type MainStackParamList = {
  Home: undefined;
  // Add other main app screens here
};</document_content>
</document>
<document index="4">
<source>golf-tracker/src/contexts/AuthContext.tsx</source>
<document_content>
// src/contexts/AuthContext.tsx
import React, { createContext, useState, useContext, useEffect } from 'react';
import { User } from 'shared';
import { getAuthToken, validateToken, logout as authLogout } from '../services/auth';

interface AuthContextType {
  user: User | null;
  setUser: (user: User | null) => void;
  logout: () => Promise<void>;
  isLoading: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    checkAuthStatus();
  }, []);

  const checkAuthStatus = async () => {
    try {
      const token = await getAuthToken();
      if (token) {
        const userData = await validateToken(token);
        if (userData) {
          setUser(userData);
        }
      }
    } catch (error) {
      console.error('Error checking auth status:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const logout = async () => {
    try {
      await authLogout();
      setUser(null);
    } catch (error) {
      console.error('Error logging out:', error);
      throw error;
    }
  };

  return (
    <AuthContext.Provider value={{ user, setUser, logout, isLoading }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}</document_content>
</document>
<document index="5">
<source>golf-tracker/src/config/database.ts</source>
<document_content>
// src/config/database.ts
import mongoose from 'mongoose';

const connectDB = async () => {
  try {
    await mongoose.connect('your_mongodb_connection_string');
    console.log('MongoDB Connected...');
  } catch (err) {
    console.error('MongoDB connection error:', err);
    process.exit(1);
  }
};

export default connectDB;</document_content>
</document>
<document index="6">
<source>golf-tracker/src/models/Round.ts</source>
<document_content>
// server/models/Round.ts
import mongoose, { Schema } from 'mongoose';

const roundSchema = new Schema({
  course: {
    type: Schema.Types.ObjectId,
    ref: 'Course',
    required: true
  },
  date: {
    type: Date,
    required: true
  },
  tees: {
    type: String,
    required: true
  },
  score: {
    type: Number,
    required: true
  },
  putts: {
    type: Number,
    required: true
  },
  fairways: {
    type: Number,
    required: true
  },
  notes: {
    type: String
  },
  addedBy: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
  }
}, {
  timestamps: true
});

// Add indexes for common queries
roundSchema.index({ addedBy: 1, date: -1 });
roundSchema.index({ course: 1, addedBy: 1 });

export interface IRound extends mongoose.Document {
  course: mongoose.Types.ObjectId;
  date: Date;
  tees: string;
  score: number;
  putts: number;
  fairways: number;
  notes?: string;
  addedBy: mongoose.Types.ObjectId;
  createdAt: Date;
  updatedAt: Date;
}

const Round = mongoose.model<IRound>('Round', roundSchema);
export default Round;</document_content>
</document>
<document index="7">
<source>golf-tracker/src/models/Course.ts</source>
<document_content>
// server/models/Course.ts
import mongoose, { Schema } from 'mongoose';

const teeSchema = new Schema({
  name: {
    type: String,
    required: true,
  },
  rating: {
    type: Number,
    required: true,
  },
  slope: {
    type: Number,
    required: true,
  },
  numberOfFairways: {
    type: Number,
    required: true,
  }
});

const courseSchema = new Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  location: {
    city: {
      type: String,
      trim: true
    },
    state: {
      type: String,
      trim: true
    },
    country: {
      type: String,
      trim: true
    }
  },
  tees: [teeSchema],
  addedBy: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
  }
}, {
  timestamps: true
});

// Make courses unique by name + location
courseSchema.index({ 
  name: 1, 
  'location.city': 1, 
  'location.state': 1,
  'location.country': 1
}, { 
  unique: true,
  collation: { locale: 'en', strength: 2 } // Case-insensitive uniqueness
});

export interface ICourse extends mongoose.Document {
  name: string;
  location: {
    city?: string;
    state?: string;
    country?: string;
  };
  tees: Array<{
    name: string;
    rating: number;
    slope: number;
    numberOfFairways: number;
  }>;
  addedBy: mongoose.Types.ObjectId;
  createdAt: Date;
  updatedAt: Date;
}

const Course = mongoose.model<ICourse>('Course', courseSchema);
export default Course;</document_content>
</document>
<document index="8">
<source>golf-tracker/src/models/User.ts</source>
<document_content>
// src/models/User.ts
import mongoose from 'mongoose';
import bcrypt from 'bcryptjs';

const SALT_ROUNDS = 10;

const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: true,
    unique: true,
  },
  password: {
    type: String,
    required: true,
  },
  name: {
    type: String,
    required: false,
  }
}, {
  timestamps: true
});

// Hash password before saving
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();

  try {
    const salt = await bcrypt.genSalt(SALT_ROUNDS);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error as Error);
  }
});

// Method to compare passwords
userSchema.methods.comparePassword = async function(candidatePassword: string): Promise<boolean> {
  try {
    return await bcrypt.compare(candidatePassword, this.password);
  } catch (error) {
    throw error;
  }
};

export interface IUser extends mongoose.Document {
  email: string;
  password: string;
  name?: string;
  createdAt: Date;
  updatedAt: Date;
  comparePassword(candidatePassword: string): Promise<boolean>;
}

const User = mongoose.model<IUser>('User', userSchema);

export default User;</document_content>
</document>
<document index="9">
<source>golf-tracker/src/screens/auth/SignupScreen.tsx</source>
<document_content>
// src/screens/auth/SignupScreen.tsx
import React, { useState } from 'react';
import {
  StyleSheet,
  View,
  Text,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import { AuthStackParamList } from '../../types/navigation';
import { FormInput } from '../../components/FormInput';
import { FormButton } from '../../components/FormButton';
import { signup, AuthError } from '../../services/auth';

type Props = NativeStackScreenProps<AuthStackParamList, 'Signup'>;

interface FormErrors {
  name?: string;
  email?: string;
  password?: string;
  confirmPassword?: string;
}

export default function SignupScreen({ navigation }: Props) {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const [formErrors, setFormErrors] = useState<FormErrors>({});
  const [generalError, setGeneralError] = useState('');

  const validateForm = (): boolean => {
    const errors: FormErrors = {};
    let isValid = true;

    // Reset errors
    setFormErrors({});
    setGeneralError('');

    // Name validation
    if (!name.trim()) {
      errors.name = 'Name is required';
      isValid = false;
    }

    // Email validation
    if (!email) {
      errors.email = 'Email is required';
      isValid = false;
    } else if (!/\S+@\S+\.\S+/.test(email)) {
      errors.email = 'Please enter a valid email';
      isValid = false;
    }

    // Password validation
    if (!password) {
      errors.password = 'Password is required';
      isValid = false;
    } else if (password.length < 8) {
      errors.password = 'Password must be at least 8 characters';
      isValid = false;
    }

    // Confirm password validation
    if (!confirmPassword) {
      errors.confirmPassword = 'Please confirm your password';
      isValid = false;
    } else if (password !== confirmPassword) {
      errors.confirmPassword = 'Passwords do not match';
      isValid = false;
    }

    setFormErrors(errors);
    return isValid;
  };

  const handleSignup = async () => {
    if (!validateForm()) {
      return;
    }

    setLoading(true);
    setGeneralError('');

    try {
      const user = await signup({
        name,
        email,
        password,
      });
      
      // TODO: Store user data in your app's global state (e.g., Context or Redux)
      console.log('Signup successful:', user);
      
      // Show success message
      Alert.alert(
        'Success',
        'Your account has been created successfully!',
        [
          {
            text: 'OK',
            onPress: () => {
              // TODO: Navigate to main app screen
              // navigation.replace('MainApp');
            },
          },
        ]
      );
      
    } catch (err) {
      if (err instanceof AuthError) {
        // Handle specific auth errors
        if (err.message.toLowerCase().includes('email already registered')) {
          setFormErrors(prev => ({
            ...prev,
            email: 'This email is already registered'
          }));
        } else if (err.message.toLowerCase().includes('network')) {
          Alert.alert(
            'Connection Error',
            'Please check your internet connection and try again.'
          );
        } else {
          setGeneralError(err.message);
        }
      } else {
        // Handle unexpected errors
        console.error('Signup error:', err);
        Alert.alert(
          'Error',
          'An unexpected error occurred. Please try again later.'
        );
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardView}
      >
        <ScrollView contentContainerStyle={styles.scrollContent}>
          <View style={styles.header}>
            <Text style={styles.title}>Create Account</Text>
            <Text style={styles.subtitle}>Track your golf progress</Text>
          </View>

          <View style={styles.form}>
            {generalError ? (
              <Text style={styles.generalError}>{generalError}</Text>
            ) : null}

            <FormInput
              label="Name"
              value={name}
              onChangeText={(text) => {
                setName(text);
                setFormErrors(prev => ({ ...prev, name: undefined }));
              }}
              placeholder="Enter your name"
              autoComplete="name"
              error={formErrors.name}
              editable={!loading}
            />

            <FormInput
              label="Email"
              value={email}
              onChangeText={(text) => {
                setEmail(text);
                setFormErrors(prev => ({ ...prev, email: undefined }));
              }}
              placeholder="Enter your email"
              autoCapitalize="none"
              autoComplete="email"
              keyboardType="email-address"
              error={formErrors.email}
              editable={!loading}
            />

            <FormInput
              label="Password"
              value={password}
              onChangeText={(text) => {
                setPassword(text);
                setFormErrors(prev => ({ ...prev, password: undefined }));
              }}
              placeholder="Create a password"
              secureTextEntry
              autoComplete="new-password"
              error={formErrors.password}
              editable={!loading}
            />

            <FormInput
              label="Confirm Password"
              value={confirmPassword}
              onChangeText={(text) => {
                setConfirmPassword(text);
                setFormErrors(prev => ({ ...prev, confirmPassword: undefined }));
              }}
              placeholder="Confirm your password"
              secureTextEntry
              autoComplete="new-password"
              error={formErrors.confirmPassword}
              editable={!loading}
            />

            <FormButton
              title="Create Account"
              onPress={handleSignup}
              loading={loading}
            />
          </View>

          <View style={styles.footer}>
            <Text style={styles.footerText}>Already have an account? </Text>
            <TouchableOpacity 
              onPress={() => navigation.navigate('Login')}
              disabled={loading}
            >
              <Text style={styles.footerLink}>Log In</Text>
            </TouchableOpacity>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  keyboardView: {
    flex: 1,
  },
  scrollContent: {
    flexGrow: 1,
    padding: 20,
  },
  header: {
    marginTop: 40,
    marginBottom: 32,
    alignItems: 'center',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
  },
  form: {
    marginBottom: 24,
  },
  generalError: {
    color: '#ff3b30',
    textAlign: 'center',
    marginBottom: 16,
    backgroundColor: '#ffebeb',
    padding: 10,
    borderRadius: 8,
  },
  error: {
    color: '#ff3b30',
    textAlign: 'center',
    marginBottom: 16,
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginTop: 'auto',
    paddingVertical: 16,
  },
  footerText: {
    color: '#666',
  },
  footerLink: {
    color: '#2f95dc',
    fontWeight: '600',
  },
});</document_content>
</document>
<document index="10">
<source>golf-tracker/src/screens/auth/LandingScreen.tsx</source>
<document_content>
// src/screens/auth/LandingScreen.tsx
import React from 'react';
import {
  StyleSheet,
  View,
  Text,
  useWindowDimensions,
  Platform,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import { AuthStackParamList } from '../../types/navigation';
import { FormButton } from '../../components/FormButton';

type Props = NativeStackScreenProps<AuthStackParamList, 'Landing'>;

export default function LandingScreen({ navigation }: Props) {
  const { height } = useWindowDimensions();

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.content}>
        {/* Top Section with Logo/Branding */}
        <View style={[styles.topSection, { height: height * 0.5 }]}>
          <View style={styles.logoContainer}>
            <Text style={styles.emoji}>⛳️</Text>
            <Text style={styles.appName}>HandiMan</Text>
          </View>
          <Text style={styles.tagline}>Track your scores.</Text>
          <Text style={styles.taglineSecondary}>Improve your game.</Text>
        </View>

        {/* Bottom Section with Feature Points and Buttons */}
        <View style={styles.bottomSection}>
          <View style={styles.features}>
            <FeaturePoint text="Track your rounds and progress" />
            <FeaturePoint text="Calculate your handicap" />
            <FeaturePoint text="Connect with other golfers" />
          </View>

          <View style={styles.buttonContainer}>
            <FormButton
              title="Get Started"
              onPress={() => navigation.navigate('Signup')}
            />
            <FormButton
              title="I already have an account"
              onPress={() => navigation.navigate('Login')}
              variant="secondary"
            />
          </View>
        </View>
      </View>
    </SafeAreaView>
  );
}

function FeaturePoint({ text }: { text: string }) {
  return (
    <View style={styles.featurePoint}>
      <Text style={styles.featureIcon}>✓</Text>
      <Text style={styles.featureText}>{text}</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  content: {
    flex: 1,
  },
  topSection: {
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 20,
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 24,
  },
  emoji: {
    fontSize: 64,
    marginBottom: 16,
  },
  appName: {
    fontSize: 42,
    fontWeight: 'bold',
    color: '#2f95dc',
    letterSpacing: -1,
  },
  tagline: {
    fontSize: 28,
    fontWeight: '600',
    textAlign: 'center',
    marginBottom: 8,
  },
  taglineSecondary: {
    fontSize: 28,
    fontWeight: '600',
    textAlign: 'center',
    color: '#2f95dc',
  },
  bottomSection: {
    flex: 1,
    paddingHorizontal: 20,
    justifyContent: 'space-between',
    paddingBottom: Platform.OS === 'ios' ? 20 : 40,
  },
  features: {
    gap: 16,
    marginBottom: 32,
  },
  featurePoint: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  featureIcon: {
    color: '#2f95dc',
    fontSize: 20,
    fontWeight: 'bold',
  },
  featureText: {
    fontSize: 16,
    color: '#333',
  },
  buttonContainer: {
    gap: 12,
  },
});</document_content>
</document>
<document index="11">
<source>golf-tracker/src/screens/auth/LoginScreen.tsx</source>
<document_content>
import React, { useState } from 'react';
import {
  StyleSheet,
  View,
  Text,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import { AuthStackParamList } from '../../types/navigation';
import { FormInput } from '../../components/FormInput';
import { FormButton } from '../../components/FormButton';
import { login, AuthError } from '../../services/auth';
import { useAuth } from '../../contexts/AuthContext';
import { User } from 'shared';

type Props = NativeStackScreenProps<AuthStackParamList, 'Login'>;

interface FormErrors {
  email?: string;
  password?: string;
}

export default function LoginScreen({ navigation }: Props) {
  const { setUser } = useAuth();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const [formErrors, setFormErrors] = useState<FormErrors>({});
  const [generalError, setGeneralError] = useState('');

  const validateForm = (): boolean => {
    const errors: FormErrors = {};
    let isValid = true;

    setFormErrors({});
    setGeneralError('');

    if (!email) {
      errors.email = 'Email is required';
      isValid = false;
    } else if (!/\S+@\S+\.\S+/.test(email)) {
      errors.email = 'Please enter a valid email';
      isValid = false;
    }

    if (!password) {
      errors.password = 'Password is required';
      isValid = false;
    }

    setFormErrors(errors);
    return isValid;
  };

  const handleLogin = async () => {
    if (!validateForm()) return;
  
    setLoading(true);
    setGeneralError('');
  
    try {
      const userData = await login(email, password);
      const user: User = {
        _id: userData._id,
        email: userData.email,
        name: userData.name,
        createdAt: new Date(userData.createdAt),
        updatedAt: new Date(userData.updatedAt)
      };
      setUser(user);
    } catch (err) {
      console.error('Login error:', err);
      if (err instanceof AuthError) {
        if (err.message.toLowerCase().includes('invalid credentials')) {
          setGeneralError('Invalid email or password');
        } else if (err.message.toLowerCase().includes('network')) {
          Alert.alert(
            'Connection Error',
            'Please check your internet connection and try again.'
          );
        } else {
          setGeneralError(err.message);
        }
      } else {
        console.error('Login error:', err);
        Alert.alert(
          'Error',
          'An unexpected error occurred. Please try again later.'
        );
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardView}
      >
        <ScrollView contentContainerStyle={styles.scrollContent}>
          <View style={styles.header}>
            <Text style={styles.title}>Welcome Back!</Text>
            <Text style={styles.subtitle}>Sign in to continue</Text>
          </View>

          <View style={styles.form}>
            {generalError ? (
              <Text style={styles.generalError}>{generalError}</Text>
            ) : null}

            <FormInput
              label="Email"
              value={email}
              onChangeText={(text) => {
                setEmail(text);
                setFormErrors(prev => ({ ...prev, email: undefined }));
              }}
              placeholder="Enter your email"
              autoCapitalize="none"
              autoComplete="email"
              keyboardType="email-address"
              error={formErrors.email}
              editable={!loading}
            />

            <FormInput
              label="Password"
              value={password}
              onChangeText={(text) => {
                setPassword(text);
                setFormErrors(prev => ({ ...prev, password: undefined }));
              }}
              placeholder="Enter your password"
              secureTextEntry
              autoComplete="password"
              error={formErrors.password}
              editable={!loading}
            />

            <FormButton
              title="Login"
              onPress={handleLogin}
              loading={loading}
            />
          </View>

          <View style={styles.footer}>
            <Text style={styles.footerText}>Don't have an account? </Text>
            <TouchableOpacity 
              onPress={() => navigation.navigate('Signup')}
              disabled={loading}
            >
              <Text style={styles.footerLink}>Sign Up</Text>
            </TouchableOpacity>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  keyboardView: {
    flex: 1,
  },
  scrollContent: {
    flexGrow: 1,
    padding: 20,
  },
  header: {
    marginTop: 40,
    marginBottom: 32,
    alignItems: 'center',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
  },
  form: {
    marginBottom: 24,
  },
  generalError: {
    color: '#ff3b30',
    textAlign: 'center',
    marginBottom: 16,
    backgroundColor: '#ffebeb',
    padding: 10,
    borderRadius: 8,
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginTop: 'auto',
    paddingVertical: 16,
  },
  footerText: {
    color: '#666',
  },
  footerLink: {
    color: '#2f95dc',
    fontWeight: '600',
  },
});</document_content>
</document>
<document index="12">
<source>golf-tracker/src/screens/HomeScreen.tsx</source>
<document_content>
import React from 'react';
import {
  StyleSheet,
  View,
  Text,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useAuth } from '../contexts/AuthContext';

export default function HomeScreen() {
  const { user, logout } = useAuth();

  const handleLogout = async () => {
    try {
      await logout();
    } catch (error) {
      console.error('Error logging out:', error);
      Alert.alert(
        'Error',
        'There was a problem logging out. Please try again.'
      );
    }
  };

  if (!user) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#2f95dc" />
        </View>
      </SafeAreaView>
    );
  }

  const handicapIndex = 14.2; // This would come from actual user data
  const recentScores = [83, 87, 82, 85, 81]; // This would come from actual user data

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView contentContainerStyle={styles.scrollContent}>
        {/* Header Section */}
        <View style={styles.header}>
          <View style={styles.welcomeContainer}>
            <Text style={styles.welcomeText}>Welcome back, </Text>
            <Text style={styles.nameText}>{user.name || 'Golfer'}</Text>
          </View>
          <TouchableOpacity 
            style={styles.logoutButton}
            onPress={handleLogout}
          >
            <Text style={styles.logoutText}>Logout</Text>
          </TouchableOpacity>
        </View>

        {/* Handicap Card */}
        <View style={styles.card}>
          <Text style={styles.cardTitle}>Current Handicap</Text>
          <Text style={styles.handicapText}>{handicapIndex}</Text>
          <TouchableOpacity style={styles.actionButton}>
            <Text style={styles.actionButtonText}>View Details</Text>
          </TouchableOpacity>
        </View>

        {/* Quick Actions */}
        <View style={styles.quickActions}>
          <TouchableOpacity style={styles.quickActionButton}>
            <Text style={styles.quickActionEmoji}>🏌️</Text>
            <Text style={styles.quickActionText}>New Round</Text>
          </TouchableOpacity>
          <TouchableOpacity style={styles.quickActionButton}>
            <Text style={styles.quickActionEmoji}>📊</Text>
            <Text style={styles.quickActionText}>Statistics</Text>
          </TouchableOpacity>
          <TouchableOpacity style={styles.quickActionButton}>
            <Text style={styles.quickActionEmoji}>🎯</Text>
            <Text style={styles.quickActionText}>Goals</Text>
          </TouchableOpacity>
        </View>

        {/* Recent Scores */}
        <View style={styles.card}>
          <Text style={styles.cardTitle}>Recent Scores</Text>
          <View style={styles.recentScores}>
            {recentScores.map((score, index) => (
              <View key={index} style={styles.scoreItem}>
                <Text style={styles.scoreText}>{score}</Text>
                <Text style={styles.scoreDate}>
                  {new Date(Date.now() - index * 24 * 60 * 60 * 1000).toLocaleDateString()}
                </Text>
              </View>
            ))}
          </View>
          <TouchableOpacity style={styles.actionButton}>
            <Text style={styles.actionButtonText}>View All Rounds</Text>
          </TouchableOpacity>
        </View>

        {/* Tips Section */}
        <View style={styles.card}>
          <Text style={styles.cardTitle}>Today's Tip</Text>
          <Text style={styles.tipText}>
            "Focus on your tempo during practice swings. A consistent tempo leads to more consistent shots."
          </Text>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  scrollContent: {
    padding: 16,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  welcomeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  welcomeText: {
    fontSize: 20,
    color: '#666',
  },
  nameText: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
  },
  logoutButton: {
    padding: 8,
  },
  logoutText: {
    color: '#2f95dc',
    fontSize: 16,
  },
  card: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  cardTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
    marginBottom: 12,
  },
  handicapText: {
    fontSize: 48,
    fontWeight: 'bold',
    color: '#2f95dc',
    textAlign: 'center',
    marginVertical: 16,
  },
  quickActions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 16,
  },
  quickActionButton: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    alignItems: 'center',
    width: '31%',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  quickActionEmoji: {
    fontSize: 24,
    marginBottom: 8,
  },
  quickActionText: {
    fontSize: 14,
    color: '#333',
    textAlign: 'center',
  },
  recentScores: {
    marginBottom: 12,
  },
  scoreItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  scoreText: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
  },
  scoreDate: {
    fontSize: 14,
    color: '#666',
  },
  actionButton: {
    backgroundColor: '#2f95dc',
    borderRadius: 8,
    padding: 12,
    alignItems: 'center',
    marginTop: 8,
  },
  actionButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  tipText: {
    fontSize: 16,
    color: '#666',
    fontStyle: 'italic',
    lineHeight: 24,
  },
});</document_content>
</document>
<document index="13">
<source>golf-tracker/src/components/FormButton.tsx</source>
<document_content>
// src/components/FormButton.tsx
import React from 'react';
import { 
  StyleSheet, 
  TouchableOpacity, 
  Text, 
  ActivityIndicator 
} from 'react-native';

interface FormButtonProps {
  title: string;
  onPress: () => void;
  variant?: 'primary' | 'secondary';
  loading?: boolean;
}

export function FormButton({ 
  title, 
  onPress, 
  variant = 'primary',
  loading = false 
}: FormButtonProps) {
  return (
    <TouchableOpacity
      style={[
        styles.button,
        variant === 'secondary' && styles.secondaryButton,
        loading && styles.buttonDisabled
      ]}
      onPress={onPress}
      disabled={loading}
    >
      {loading ? (
        <ActivityIndicator color={variant === 'primary' ? '#fff' : '#2f95dc'} />
      ) : (
        <Text 
          style={[
            styles.buttonText,
            variant === 'secondary' && styles.secondaryButtonText
          ]}
        >
          {title}
        </Text>
      )}
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  button: {
    height: 48,
    borderRadius: 8,
    backgroundColor: '#2f95dc',
    justifyContent: 'center',
    alignItems: 'center',
  },
  secondaryButton: {
    backgroundColor: 'transparent',
    borderWidth: 2,
    borderColor: '#2f95dc',
  },
  buttonDisabled: {
    opacity: 0.6,
  },
  buttonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  secondaryButtonText: {
    color: '#2f95dc',
  },
});</document_content>
</document>
<document index="14">
<source>golf-tracker/src/components/FormInput.tsx</source>
<document_content>
// src/components/FormInput.tsx
import React from 'react';
import { StyleSheet, TextInput, TextInputProps, View, Text } from 'react-native';

interface FormInputProps extends TextInputProps {
  label?: string;
  error?: string;
}

export function FormInput({ label, error, style, ...props }: FormInputProps) {
  return (
    <View style={styles.container}>
      {label && <Text style={styles.label}>{label}</Text>}
      <TextInput
        style={[styles.input, error && styles.inputError, style]}
        placeholderTextColor="#999"
        {...props}
      />
      {error && <Text style={styles.errorText}>{error}</Text>}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    marginBottom: 16,
  },
  label: {
    fontSize: 16,
    marginBottom: 8,
    color: '#333',
  },
  input: {
    height: 48,
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    paddingHorizontal: 16,
    fontSize: 16,
    backgroundColor: '#fff',
  },
  inputError: {
    borderColor: '#ff3b30',
  },
  errorText: {
    color: '#ff3b30',
    fontSize: 14,
    marginTop: 4,
  },
});</document_content>
</document>
<document index="15">
<source>golf-tracker/src/services/auth.ts</source>
<document_content>
// src/services/auth.ts
import * as SecureStore from 'expo-secure-store';
import { User, CreateUserInput } from 'shared';

const API_URL = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:3000/api';
const AUTH_TOKEN_KEY = 'auth_token';

export class AuthError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'AuthError';
  }
}

interface ServerUser {
  _id: string;
  email: string;
  name?: string;
  createdAt: string;
  updatedAt: string;
}

interface AuthResponse {
  success: boolean;
  message?: string;
  data?: {
    user: ServerUser;
    token: string;
  };
}

function transformUser(serverUser: ServerUser): User {
  return {
    ...serverUser,
    createdAt: new Date(serverUser.createdAt),
    updatedAt: new Date(serverUser.updatedAt)
  };
}

async function storeAuthToken(token: string): Promise<void> {
  await SecureStore.setItemAsync(AUTH_TOKEN_KEY, token);
}

export async function getAuthToken(): Promise<string | null> {
  return await SecureStore.getItemAsync(AUTH_TOKEN_KEY);
}

export async function removeAuthToken(): Promise<void> {
  await SecureStore.deleteItemAsync(AUTH_TOKEN_KEY);
}

export async function validateToken(token: string): Promise<User | null> {
  try {
    const response = await fetch(`${API_URL}/auth/validate`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) return null;

    const data: AuthResponse = await response.json();
    return data.success && data.data?.user ? transformUser(data.data.user) : null;
  } catch (error) {
    console.error('Token validation error:', error);
    return null;
  }
}

export async function signup(userData: CreateUserInput): Promise<User> {
  const response = await fetch(`${API_URL}/auth/signup`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(userData),
  });

  const data: AuthResponse = await response.json();

  if (!data.success || !data.data?.user || !data.data?.token) {
    throw new AuthError(data.message || 'Error creating account');
  }

  await storeAuthToken(data.data.token);
  return transformUser(data.data.user);
}

export async function login(email: string, password: string): Promise<User> {
  try {
    const response = await fetch(`${API_URL}/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    });

    console.log('Response status:', response.status);
    const text = await response.text();
    console.log('Raw response:', text);

    let data;
    try {
      data = JSON.parse(text);
    } catch (e) {
      console.error('JSON parse error:', e);
      throw new AuthError('Invalid server response');
    }
    console.log('API Response:', JSON.stringify(data, null, 2));

    if (!data.success || !data.data?.user || !data.data?.token) {
      throw new AuthError(data.message || 'Invalid credentials');
    }

    const { user, token } = data.data;
    console.log('User data before transform:', user);

    await storeAuthToken(token);

    // Create user object explicitly
    const transformedUser: User = {
      _id: user._id,
      email: user.email,
      name: user.name,
      createdAt: new Date(user.createdAt),
      updatedAt: new Date(user.updatedAt)
    };

    console.log('Transformed user:', transformedUser);
    return transformedUser;
    
    } catch (error) {
      console.error('Login error:', error);
      throw new AuthError('Error logging in');
    }
}

export async function logout(): Promise<void> {
  try {
    await removeAuthToken();
  } catch (error) {
    throw new AuthError('Error logging out');
  }
}</document_content>
</document>
<document index="2">
<source>server/middleware/auth.ts</source>
<document_content>
// server/middleware/auth.ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { User } from 'shared';
import UserModel, { IUser } from '../models/User';

// Extend Express Request type to include user
interface AuthRequest extends Request {
  user?: User;
}

interface JwtPayload {
  userId: string;
  email: string;
}

export const authenticateToken = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader?.startsWith('Bearer ')) {
      return res.status(401).json({
        success: false,
        message: 'No token provided'
      });
    }

    const token = authHeader.split(' ')[1];
    
    const decoded = jwt.verify(
      token, 
      process.env.JWT_SECRET!
    ) as JwtPayload;
    
    // Explicitly type the mongoose document
    const user = await UserModel.findById(decoded.userId)
      .select('-password') as IUser | null;

    if (!user) {
      return res.status(401).json({
        success: false,
        message: 'User not found'
      });
    }

    // Transform mongoose document to shared User type
    req.user = {
      _id: user._id.toString(), // Convert mongoose ObjectId to string
      email: user.email,
      name: user.name,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt
    };

    next();
  } catch (error) {
    if (error instanceof jwt.JsonWebTokenError) {
      return res.status(401).json({
        success: false,
        message: 'Invalid token'
      });
    }

    console.error('Auth middleware error:', error);
    return res.status(500).json({
      success: false,
      message: 'Internal server error'
    });
  }
};</document_content>
</document>
<document index="3">
<source>server/models/Round.ts</source>
<document_content>
// server/models/Round.ts
import mongoose from 'mongoose';
import { Round } from 'shared';

export interface IRound extends Omit<Round, '_id' | 'course' | 'addedBy'> {
  _id: mongoose.Types.ObjectId;
  course: mongoose.Types.ObjectId;
  addedBy: mongoose.Types.ObjectId;
  calculateDifferential(): Promise<number>;
}

const roundSchema = new mongoose.Schema({
  course: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Course',
    required: true
  },
  date: {
    type: Date,
    required: true,
    default: Date.now
  },
  tees: {
    type: String,
    required: true
  },
  score: {
    type: Number,
    required: true
  },
  putts: {
    type: Number,
    required: true
  },
  fairways: {
    type: Number,
    required: true
  },
  notes: {
    type: String
  },
  addedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  }
}, {
  timestamps: true
});

// Add indexes for common queries
roundSchema.index({ addedBy: 1, date: -1 });
roundSchema.index({ course: 1, addedBy: 1 });

// Calculate differential for handicap index
roundSchema.methods.calculateDifferential = async function(): Promise<number> {
  const course = await mongoose.model('Course').findById(this.course);
  if (!course) throw new Error('Course not found');
  
  const tee = course.tees.find((t: { name: string; }) => t.name === this.tees);
  if (!tee) throw new Error('Tee not found');
  
  return ((this.score - tee.rating) * 113) / tee.slope;
};

const Round = mongoose.model<IRound>('Round', roundSchema);
export default Round;</document_content>
</document>
<document index="4">
<source>server/models/Course.ts</source>
<document_content>
// server/models/Course.ts
import mongoose from 'mongoose';
import { Course } from 'shared';

export interface ICourse extends Omit<Course, '_id' | 'addedBy'> {
  _id: mongoose.Types.ObjectId;
  addedBy: mongoose.Types.ObjectId;
}

const teeSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true
  },
  rating: {
    type: Number,
    required: true
  },
  slope: {
    type: Number,
    required: true
  },
  numberOfFairways: {
    type: Number,
    required: true,
    min: 0,
    max: 18,
    validate: {
      validator: Number.isInteger,
      message: 'Number of fairways must be a whole number'
    }
  }
});

const courseSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  location: {
    city: {
      type: String,
      trim: true
    },
    state: {
      type: String,
      trim: true
    },
    country: {
      type: String,
      trim: true
    }
  },
  tees: [teeSchema],
  addedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  }
}, {
  timestamps: true
});

// Make courses unique by name + location
courseSchema.index({ 
  name: 1, 
  'location.city': 1, 
  'location.state': 1,
  'location.country': 1
}, { 
  unique: true,
  collation: { locale: 'en', strength: 2 } // Case-insensitive uniqueness
});

const Course = mongoose.model<ICourse>('Course', courseSchema);
export default Course;</document_content>
</document>
<document index="5">
<source>server/models/User.ts</source>
<document_content>
// server/models/User.ts
import mongoose from 'mongoose';
import { User } from 'shared';
import bcrypt from 'bcryptjs';

const SALT_ROUNDS = 10;

export interface IUser extends Omit<User, '_id'> {
  _id: mongoose.Types.ObjectId;
  password: string;
  comparePassword(candidatePassword: string): Promise<boolean>;
}

const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: true,
    unique: true,
  },
  password: {
    type: String,
    required: true,
  },
  name: String
}, {
  timestamps: true
});

// Hash password before saving
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();

  try {
    const salt = await bcrypt.genSalt(SALT_ROUNDS);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error as Error);
  }
});

// Method to compare passwords
userSchema.methods.comparePassword = async function(candidatePassword: string): Promise<boolean> {
  try {
    return await bcrypt.compare(candidatePassword, this.password);
  } catch (error) {
    throw error;
  }
};

const UserModel = mongoose.model<IUser>('User', userSchema);

export default UserModel;</document_content>
</document>
<document index="6">
<source>server/index.ts</source>
<document_content>
// server/index.ts
import express from 'express';
import mongoose from 'mongoose';
import cors from 'cors';
import dotenv from 'dotenv';
import authRoutes from './routes/auth';
import courseRoutes from './routes/courses';
import roundRoutes from './routes/rounds';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;
const MONGODB_URI = process.env.MONGODB_URI;

if (!MONGODB_URI) {
  throw new Error('MONGODB_URI must be defined in environment variables');
}

app.use(cors({
  origin: ['http://localhost:19006', 'http://localhost:19000'],
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'Accept'],
  credentials: true
}));

app.use(express.json());

mongoose.connect(MONGODB_URI)
  .then(() => console.log('Connected to MongoDB'))
  .catch(err => {
    console.error('MongoDB connection error:', err);
    process.exit(1);
  });

app.use('/api/auth', authRoutes);
app.use('/api/courses', courseRoutes);
app.use('/api/rounds', roundRoutes);

app.get('/health', (req, res) => {
  res.json({ 
    status: 'healthy',
    timestamp: new Date().toISOString()
  });
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});</document_content>
</document>
<document index="7">
<source>server/routes/courses.ts</source>
<document_content>
// server/routes/courses.ts
import express from 'express';
import { Course } from 'shared';
import CourseModel, { ICourse } from '../models/Course';
import { authenticateToken } from '../middleware/auth';
import exp from 'constants';

const router = express.Router();

function mapCourseToResponse(course: ICourse): Course {
  return {
    _id: course._id.toString(),
    name: course.name,
    location: course.location,
    tees: course.tees,
    addedBy: course.addedBy.toString(),
    createdAt: course.createdAt,
    updatedAt: course.updatedAt
  };
}

router.get('/', authenticateToken, async (req, res) => {
  try {
    const { search } = req.query;
    const query = search ? {
      $or: [
        { name: new RegExp(search as string, 'i') },
        { 'location.city': new RegExp(search as string, 'i') }
      ]
    } : {};

    const courses = await CourseModel.find(query).sort({ name: 1 }).limit(50);
    res.json({
      success: true,
      data: courses.map(mapCourseToResponse)
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching courses'
    });
  }
});

export default router;</document_content>
</document>
<document index="8">
<source>server/routes/rounds.ts</source>
<document_content>
// server/routes/courses.ts
import express, { Request } from 'express';
import { Course } from 'shared';
import CourseModel, { ICourse } from '../models/Course';
import { authenticateToken } from '../middleware/auth';

interface AuthRequest extends Request {
  user?: {
    _id: string;
    email: string;
  };
}

const router = express.Router();

function mapCourseToResponse(course: ICourse): Course {
  return {
    _id: course._id.toString(),
    name: course.name,
    location: course.location,
    tees: course.tees,
    addedBy: course.addedBy.toString(),
    createdAt: course.createdAt,
    updatedAt: course.updatedAt
  };
}

router.get('/', authenticateToken, async (req: AuthRequest, res) => {
  try {
    const { search } = req.query;
    const query = search ? {
      $or: [
        { name: new RegExp(String(search), 'i') },
        { 'location.city': new RegExp(String(search), 'i') }
      ]
    } : {};

    const courses = await CourseModel.find(query).sort({ name: 1 }).limit(50);
    res.json({
      success: true,
      data: courses.map(mapCourseToResponse)
    });
  } catch (error) {
    console.error('Error fetching courses:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching courses'
    });
  }
});

router.post('/', authenticateToken, async (req: AuthRequest, res) => {
  try {
    if (!req.user?._id) {
      return res.status(401).json({
        success: false,
        message: 'User not authenticated'
      });
    }

    const course = new CourseModel({
      ...req.body,
      addedBy: req.user._id
    });

    await course.save();
    res.status(201).json({
      success: true,
      data: mapCourseToResponse(course)
    });
  } catch (error) {
    if ((error as any).code === 11000) {
      return res.status(400).json({
        success: false,
        message: 'A course with this name and location already exists'
      });
    }

    console.error('Error creating course:', error);
    res.status(500).json({
      success: false,
      message: 'Error creating course'
    });
  }
});

export default router;</document_content>
</document>
<document index="9">
<source>server/routes/auth.ts</source>
<document_content>
// server/routes/auth.ts
import express from 'express';
import jwt from 'jsonwebtoken';
import { z } from 'zod';
import { User, CreateUserInput } from 'shared';
import UserModel, { IUser } from '../models/User';

const router = express.Router();

const signupSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
  name: z.string().min(1)
});

function generateToken(user: IUser): string {
  return jwt.sign(
    { userId: user._id.toString(), email: user.email },
    process.env.JWT_SECRET!,
    { expiresIn: '24h' }
  );
}

function mapUserToResponse(user: IUser): User {
  return {
    _id: user._id.toString(),
    email: user.email,
    name: user.name,
    createdAt: user.createdAt,
    updatedAt: user.updatedAt
  };
}

router.post('/signup', async (req, res) => {
  try {
    const validatedData = signupSchema.parse(req.body);
    const existingUser = await UserModel.findOne({
      email: { $regex: new RegExp(`^${validatedData.email}$`, 'i') }
    });

    if (existingUser) {
      return res.status(400).json({
        success: false,
        message: 'Email already registered'
      });
    }

    const user = new UserModel(validatedData);
    await user.save();

    res.status(201).json({
      success: true,
      data: {
        user: mapUserToResponse(user),
        token: generateToken(user)
      }
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        success: false,
        message: 'Validation error',
        errors: error.errors
      });
    }
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

export default router;</document_content>
</document>
<document index="2">
<source>shared/dist/types/course.d.ts</source>
<document_content>
import { BaseDocument } from './base';
export interface Course extends BaseDocument {
    name: string;
    location: {
        city?: string;
        state?: string;
        country?: string;
    };
    tees: Array<{
        name: string;
        rating: number;
        slope: number;
        numberOfFairways: number;
    }>;
    addedBy: string;
}
</document_content>
</document>
<document index="3">
<source>shared/dist/types/user.d.ts</source>
<document_content>
import { BaseDocument } from './base';
export interface User extends BaseDocument {
    email: string;
    name?: string;
}
export interface CreateUserInput {
    email: string;
    password: string;
    name?: string;
}
</document_content>
</document>
<document index="4">
<source>shared/dist/types/base.d.ts</source>
<document_content>
export interface BaseDocument {
    _id: string;
    createdAt: Date;
    updatedAt: Date;
}
</document_content>
</document>
<document index="5">
<source>shared/dist/types/round.d.ts</source>
<document_content>
import { BaseDocument } from './base';
export interface Round extends BaseDocument {
    course: string;
    date: Date;
    tees: string;
    score: number;
    putts: number;
    fairways: number;
    notes?: string;
    addedBy: string;
}
</document_content>
</document>
<document index="6">
<source>shared/dist/index.d.ts</source>
<document_content>
export * from './types/user';
export * from './types/course';
export * from './types/round';
</document_content>
</document>
<document index="7">
<source>shared/src/types/base.ts</source>
<document_content>
// shared/src/types/base.ts
export interface BaseDocument {
  _id: string;
  createdAt: Date;
  updatedAt: Date;
}
</document_content>
</document>
<document index="8">
<source>shared/src/types/round.ts</source>
<document_content>
// shared/src/types/round.ts
import { BaseDocument } from './base';

export interface Round extends BaseDocument {
  course: string;
  date: Date;
  tees: string;
  score: number;
  putts: number;
  fairways: number;
  notes?: string;
  addedBy: string;
}</document_content>
</document>
<document index="9">
<source>shared/src/types/course.ts</source>
<document_content>
// shared/src/types/course.ts
import { BaseDocument } from './base';

export interface Course extends BaseDocument {
  name: string;
  location: {
    city?: string;
    state?: string;
    country?: string;
  };
  tees: Array<{
    name: string;
    rating: number;
    slope: number;
    numberOfFairways: number;
  }>;
  addedBy: string;
}</document_content>
</document>
<document index="10">
<source>shared/src/types/user.ts</source>
<document_content>
// shared/src/types/user.ts
import { BaseDocument } from './base';

export interface User extends BaseDocument {
  email: string;
  name?: string;
}

export interface CreateUserInput {
  email: string;
  password: string;
  name?: string;
}</document_content>
</document>
<document index="11">
<source>shared/src/index.ts</source>
<document_content>
// shared/src/index.ts
export * from './types/user';
export * from './types/course';
export * from './types/round';</document_content>
</document>
</documents>
